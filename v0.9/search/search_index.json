{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Frequenz Repository Configuration","text":""},{"location":"#introduction","title":"Introduction","text":"<p>This is a highly opinionated set of tools and configurations to set up a Python repository for Frequenz projects.</p> <p>It offers:</p> <ul> <li>Cookiecutter templates for scaffolding new projects.</li> <li>Trivial build of <code>noxfile.py</code> with some predefined sessions that include all   common checks.</li> <li>Tools to build protobuf/grpc files as Python, including type information.</li> </ul>"},{"location":"#user-guide","title":"User Guide","text":"<p>Please refer to the User Guide for more information.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to Frequenz Repository Configuration","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#golden-tests","title":"Golden Tests","text":"<p>To test the generated files using the Cookiecutter templates, the golden testing technique is used to ensure that changes in the templates don't occur unexpectedly.</p> <p>If a golden test fails, a <code>diff</code> of the contents will be provided in the test results.</p> <p>Failures in the golden tests could indicate two things:</p> <ol> <li> <p>The generated files don't match the golden files because an unintended    change was introduced. For example, there may be a bug that needs to be fixed    so that the generated files match the golden files again.</p> </li> <li> <p>The generated files don't match the golden files because an intended change    was introduced. In this case, the golden files need to be updated.</p> </li> </ol> <p>In the latter case, manually updating files is complicated and error-prone, so a simpler (though hacky) way is provided.</p> <p>To update the golden files, simply run <code>pytest</code> for the tests using golden files setting the environment variable <code>UPDATE_GOLDEN</code> to <code>1</code>:</p> <pre><code>UPDATE_GOLDEN=1 pytest tests/integration/test_cookiecutter_generation.py::test_golden\n</code></pre> <p>This will replace the existing golden files (stored in <code>tests_golden/</code>) with the newly generated files.</p> <p>Note that if you rename, or remove golden files, you should also manually remove the files that were affected. An easy way to make sure there are no old unused golden files left is to just wipe the whole <code>tests_golden/</code> directory before running <code>pytest</code> to generate the new ones.</p> <p>Please ensure that all introduced changes are intended before updating the golden files.</p>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"CONTRIBUTING/#cross-arch-testing","title":"Cross-Arch Testing","text":"<p>This project has built-in support for testing across multiple architectures. Currently, our CI conducts tests on <code>arm64</code> machines using QEMU emulation. We also have the flexibility to expand this support to include additional architectures in the future.</p> <p>This project contains Dockerfiles that can be used in the CI to test the python package in non-native machine architectures, e.g., <code>arm64</code>. The Dockerfiles exist in the directory <code>.github/containers/nox-cross-arch</code>, and follow a naming scheme so that they can be easily used in build matrices in the CI, in <code>nox-cross-arch</code> job. The naming scheme is:</p> <pre><code>&lt;arch&gt;-&lt;os&gt;-python-&lt;python-version&gt;.Dockerfile\n</code></pre> <p>E.g.,</p> <pre><code>arm64-ubuntu-20.04-python-3.11.Dockerfile\n</code></pre> <p>If a Dockerfile for your desired target architecture, OS, and python version does not exist here, please add one before proceeding to add your options to the test matrix.</p>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>User Guide</li> <li>API Reference</li> <li>Contributing</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>repo<ul> <li>config<ul> <li>cli<ul> <li>version<ul> <li>mike<ul> <li>info</li> <li>sort</li> </ul> </li> </ul> </li> </ul> </li> <li>github</li> <li>mkdocs<ul> <li>api_pages</li> <li>mike</li> </ul> </li> <li>nox<ul> <li>config</li> <li>default</li> <li>session</li> <li>util</li> </ul> </li> <li>protobuf</li> <li>pytest<ul> <li>examples</li> </ul> </li> <li>setuptools<ul> <li>grpc_tools</li> </ul> </li> <li>version</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/frequenz/repo/config/","title":"Index","text":""},{"location":"reference/frequenz/repo/config/#frequenz.repo.config","title":"frequenz.repo.config","text":"<p>Frequenz project setup tools and common configuration.</p> <p>The tools are provided to configure the main types of repositories most commonly used at Frequenz, defined in <code>frequenz.repo.config.RepositoryType</code>.</p> <ul> <li>actor: SDK actors</li> <li>api: gRPC APIs</li> <li>app: SDK applications</li> <li>lib: General purpose Python libraries</li> <li>model: SDK machine learning models</li> </ul>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config--common","title":"Common","text":""},{"location":"reference/frequenz/repo/config/#frequenz.repo.config--nox-running-tests-and-linters","title":"<code>nox</code> (running tests and linters)","text":""},{"location":"reference/frequenz/repo/config/#frequenz.repo.config--writing-the-noxfilepy","title":"Writing the <code>noxfile.py</code>","text":"<p>Projects wanting to use <code>nox</code> to run lint checkers and other utilities can use the <code>frequenz.repo.config.nox</code> package.</p> <p>When writing the <code>noxfile.py</code> you should import the <code>nox</code> module from this package and use the <code>frequenz.repo.config.nox.configure</code> function, which will configure all nox sessions.</p> <p>To use the default options, you should call <code>configure()</code> using one of the repository types.  For example:</p> <pre><code>from frequenz.repo.config import RepositoryType, nox\nnox.configure(RepositoryType.LIB)\n</code></pre> <p>Again, make sure to pick the correct project typedefault configuration based on the type of your project (<code>actor_config</code>, <code>api_config</code>, <code>app_config</code>, <code>lib_config</code>, <code>model_config</code>).</p> <p>If you need to use some custom configuration, you can start from the default settings in the <code>frequenz.repo.config.nox.default</code> module, copying it and changing whatever you need to customize.  For example:</p> <pre><code>from frequenz.repo.config import nox\nfrom frequenz.repo.config.nox import default\nconfig = default.lib_config.copy()\nconfig.opts.black.append(\"--diff\")\nnox.configure(config)\n</code></pre> <p>Note</p> <p>When possible, it is recommended to define options in the <code>pyproject.toml</code> file (most tools can do this), so they can be consistently used even if the tool is used outside of <code>nox</code>.</p> <p>If you need further customization or to define new sessions, you can use the following modules:</p> <ul> <li> <p><code>frequenz.repo.config.nox.config</code>: Low-level utilities to configure nox   sessions. It defines the <code>Config</code> and CommandsOptions<code>classes and the actual   implementation of the</code>configure()<code>function. It also defines the</code>get()`   function, which can be used to get the currently used configuration object.</p> </li> <li> <p><code>frequenz.repo.config.nox.session</code>: Predefined nox sessions. These are   the sessions that are used by default.</p> </li> <li> <p><code>frequenz.repo.config.nox.util</code>: General purpose utility functions.</p> </li> </ul>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config--pyprojecttoml-configuration","title":"<code>pyproject.toml</code> configuration","text":"<p>All sessions configured by this package expect the <code>pyproject.toml</code> file to define specific dev dependencies that will be used by the different <code>nox</code> sessions.</p> <p>The following optional dependencies are used and must be defined:</p> <ul> <li><code>dev-flake8</code>: Dependencies to do flake8 lint, including the documentation.</li> </ul> <p>At least these packages should be included:</p> <ul> <li><code>pydocstyle</code>: To check the docstrings' format.</li> <li> <p><code>pydoclint</code>: To check the docstrings' content.</p> </li> <li> <p><code>dev-formatting</code>: Dependencies to check the code's formatting.</p> </li> </ul> <p>At least these packages should be included:</p> <ul> <li><code>black</code>: To check the code's formatting.</li> <li> <p><code>isort</code>: To check the imports' formatting.</p> </li> <li> <p><code>dev-mypy</code>: Dependencies to run <code>mypy</code> to check the code's type annotations.</p> </li> </ul> <p>At least these packages should be included:</p> <ul> <li> <p><code>mypy</code>: To check the code's type annotations.</p> </li> <li> <p><code>dev-pylint</code>: Dependencies to run <code>pylint</code> to lint the code.</p> </li> </ul> <p>At least these packages should be included:</p> <ul> <li> <p><code>pylint</code>: To lint the code.</p> </li> <li> <p><code>dev-pytest</code>: Dependencies to run the tests using <code>pytest</code>.</p> </li> </ul> <p>At least these packages should be included:</p> <ul> <li><code>pytest</code>: To run the tests.</li> </ul> <p>For some of these you should install too any other dependencies that are used by the project. For example, if the project uses <code>pytest-asyncio</code>, you should include it in the <code>dev-pytest</code> optional dependency.</p> <p>It is also recommended, but not required, to provide a global <code>dev</code> optional dependency that includes all the other optional dependencies, so users can install all the dependencies needed while developing the project without having to run <code>nox</code>, which might be a bit slow if you want to do quick iterations.</p> <pre><code>$ pip install -e .[dev]\n...\n$ pytest\n...\n</code></pre> <p>Here is a sample <code>pyproject.toml</code> file that defines all the optional dependencies:</p> <pre><code>[project]\nname = \"my-package\"\n# ...\n[project.optional-dependencies]\ndev-flake8 = [\n\"flake8 == 6.1.0\",\n\"flake8-docstrings == 1.7.0\",\n\"flake8-pyproject == 1.2.3\",  # For reading the flake8 config from pyproject.toml\n\"pydoclint == 0.3.1\",\n\"pydocstyle == 6.3.0\",\n]\ndev-formatting = [\"black == 23.3.0\", \"isort == 5.12.0\"]\ndev-mkdocs = [\n\"mike == 1.1.2\",\n\"mkdocs-gen-files == 0.5.0\",\n\"mkdocs-literate-nav == 0.6.0\",\n\"mkdocs-material == 9.1.16\",\n\"mkdocs-section-index == 0.3.5\",\n\"mkdocstrings[python] == 0.22.0\",\n]\ndev-mypy = [\n\"mypy == 1.1.1\",\n# For checking tests\n\"my-package[dev-mkdocs,dev-pytest]\",\n]\ndev-pylint = [\n\"pylint == 2.17.1\",\n\"pylint-google-style-guide-imports-enforcing == 1.3.0\",\n# For checking tests\n\"my-package[dev-mkdocs,dev-pytest]\",\n]\ndev-pytest = [\n\"pytest == 8.0.0\",\n\"pytest-asyncio == 0.21.0\",\n\"pytest-mock == 3.10.0\",\n]\ndev = [\n\"my-package[dev-mkdocs,dev-flake8,dev-formatting,dev-mypy,dev-nox,dev-pylint,dev-pytest]\",\n]\n</code></pre>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config--mypy-static-type-checking","title":"<code>mypy</code> (static type checking)","text":"<p>To configure <code>mypy</code> you can add the recommended options to the <code>pyproject.toml</code> file as follows:</p> <pre><code>[tool.mypy]\nexplicit_package_bases = true\nnamespace_packages = true\npackages = [\"your_package_name\"]  # Use the actual package name here\nstrict = true\n</code></pre> <p>You can just call <code>mypy</code> to check the package of your sources or you can use <code>mypy tests</code> to check the tests, for example.</p> <p>You might also need to extra optional dependencies to install type checking stubs for some packages.  For example for API projects you need the <code>grpc-stubs</code> package:</p> <pre><code>[project.optional-dependencies]\n# ...\ndev-mypy = [\n# ...\n\"grpc-stubs == 1.53.0.2\",\n# ...\n]\n</code></pre> <p>You can use <code>mypy --install-types</code> to install to get a list of missing stubs, <code>mypy</code> will list them for you and ask if you want to proceed with the installation.  You can answer no and copy the list of missing stubs to the <code>pyproject.toml</code> file.</p>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config--mkdocs-generating-documentation","title":"<code>mkdocs</code> (generating documentation)","text":""},{"location":"reference/frequenz/repo/config/#frequenz.repo.config--api-reference-generation","title":"API reference generation","text":"<p>The API documnentation can be automatically generated from the source files using the <code>frequenz.repo.config.mkdocs</code> package as when run as a <code>mkdocs-gen-files</code> plugin script.</p> <p>To enable it you just need to make sure the <code>mkdocs-gen-files</code>, <code>mkdocs-literate-nav</code> and <code>mkdocstrings[python]</code> packages are installed (look at the <code>pyproject.toml</code> configuration in the <code>nox</code> section) and add the following configuration to the <code>mkdocs.yml</code> file:</p> <pre><code>plugins:\n- gen-files:\nscripts:\n- path/to/my/custom/script.py\n</code></pre> <p>By default this script will look for files in the <code>src/</code> directory and generate the documentation files in the <code>python-reference/</code> directory inside <code>mkdocs</code> output directory (<code>site</code> by defaul).</p> <p>If you need to customize the above paths, you can create a new script to use with the <code>mkdocs-gen-files</code> plugin as follows:</p> <pre><code>from frequenz.repo.config.mkdocs import api_pages\napi_pages.generate_python_api_pages(\"my_sources\", \"API\")\n</code></pre> <p>Where <code>my_sources</code> is the directory containing the source files and <code>API</code> is the directory where to generate the documentation files (relative to <code>mkdocs</code> output directory).</p> <p>And then replace this configuration in the <code>mkdocs.yml</code> file:</p> <pre><code>plugins:\n- gen-files:\nscripts:\n- path/to/my/custom/script.py\n</code></pre>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config--pytest-running-tests","title":"<code>pytest</code> (running tests)","text":""},{"location":"reference/frequenz/repo/config/#frequenz.repo.config--linting-examples-in-the-source-codes-docstrings","title":"Linting examples in the source code's docstrings","text":"<p>To make sure the examples included in your source code's docstrings are valid, you can use <code>pytest</code> to automatically collect all the examples wrapped in triple backticks (<code>```python</code>) within our docstrings and validate them using <code>pylint</code>.</p> <p>To do so there is some setup that's needed:</p> <ol> <li> <p>Add a <code>conftest.py</code> file to the root directory containing your source code with the    following contents:</p> <pre><code>from frequenz.repo.config.pytest import examples\nfrom sybil import Sybil\npytest_collect_file = Sybil(**examples.get_sybil_arguments()).pytest()\n</code></pre> <p>Unfortunately, because of how Sybil works, the <code>Sybil</code> class needs to be instantiated in the <code>conftest.py</code> file. To easily do this, the convenience function <code>get_sybil_arguments()</code> is provided to get the arguments to pass to the <code>Sybil()</code> constructor to be able to collect and lint the examples.</p> </li> <li> <p>Add the following configuration to your <code>pyproject.toml</code> file (see    the <code>nox</code> section for details on how to configure    dependencies to play nicely with <code>nox</code>):</p> <pre><code>[project.optional-dependencies]\n# ...\ndev-pytest = [\n# ...\n\"frequenz-repo-config[extra-lint-examples] == 0.9.0\",\n]\n# ...\n[[tool.mypy.overrides]]\nmodule = [\n# ...\n\"sybil\",\n\"sybil.*\",\n]\nignore_missing_imports = true\n# ...\n[tool.pytest.ini_options]\ntestpaths = [\n# ...\n\"src\",\n]\n</code></pre> </li> </ol> <p>This will make sure that you have the appropriate dependencies installed to run the    the tests linting and that <code>mypy</code> doesn't complain about the <code>sybil</code> module not being    typed.</p> <ol> <li> <p>Exclude the <code>src/conftest.py</code> file from the distribution package, as it shouldn't be    shipped with the code, it is only for delelopment purposes. To do so, add the    following line to the <code>MANIFEST.in</code> file:</p> <pre><code># ...\nexclude src/conftest.py\n</code></pre> </li> </ol> <p>Now you should be able to run <code>nox -s pytest</code> (or <code>pytest</code> directly) and see the tests linting the examples in your code's docstrings.</p>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config--apis","title":"APIs","text":""},{"location":"reference/frequenz/repo/config/#frequenz.repo.config--protobuf-configuation","title":"Protobuf configuation","text":"<p>Support is provided to generate files from protobuf files.  To do this, it is possible to configure the options to use while generating the files for different purposes (language bindings, documentation, etc.).</p> <p>The configuration can be done in the <code>pyproject.toml</code> file as follows:</p> <pre><code>[tool.frequenz-repo-config.protobuf]\n# Location of the proto files relative to the root of the repository (default: \"proto\")\nproto_path = \"proto_files\"\n# Glob pattern to use to find the proto files in the proto_path (default: \"*.proto\")\nproto_glob = \"*.prt\"  # Default: \"*.proto\"\n# List of paths to pass to the protoc compiler as include paths (default:\n# [\"submodules/api-common-protos\", \"submodules/frequenz-api-common/proto\"])\ninclude_paths = [\"submodules/api-common-protos\"]\n# Path where to generate the Python files (default: \"py\")\npy_path = \"generated\"\n# Path where to generate the documentation files (default: \"protobuf-reference\")\ndocs_path = \"API\"\n</code></pre> <p>If the defaults are not suitable for you (for example you need to use more or less submodules or your proto files are located somewhere else), please adjust the configuration to match your project structure.</p>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config--mkdocs-api-reference-generation","title":"<code>mkdocs</code> API reference generation","text":"<p>If your project provides protobuf files, you can also generate the API documentation for them adding one more line to the script provided in the common section:</p> <pre><code>from frequenz.repo.config.mkdocs import api_pages\napi_pages.generate_python_api_pages(\"my_sources\", \"API-py\")\napi_pages.generate_protobuf_api_pages()\n</code></pre> <p>This will use the configuration in the <code>pyproject.toml</code> file and requires <code>docker</code> to run (it uses the <code>pseudomuto/protoc-gen-doc</code> docker image.</p>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config--setuptools-grpc-support","title":"<code>setuptools</code> gRPC support","text":"<p>When configuring APIs it is assumed that they have a gRPC interface.</p> <p>The project structure is assumed to be as described in the Protobuf configuration section plus the following:</p> <ul> <li><code>pytests/</code>: Directory containing the tests for the Python code.</li> <li><code>submodules/api-common-protos</code>: Directory containing the Git submodule with the   <code>google/api-common-protos</code> repository.</li> <li><code>submodules/frequenz-api-common</code>: Directory containing the Git submodule with the   <code>frequenz-floss/frequenz-api-common</code> repository.</li> </ul> <p>Normally Frequenz APIs use basic types from <code>google/api-common-protos</code> and <code>frequenz-floss/frequenz-api-common</code>, so you need to make sure the proper submodules are added to your project:</p> <pre><code>mkdir submodules\ngit submodule add https://github.com/googleapis/api-common-protos.git \\\nsubmodules/api-common-protos\ngit submodule add https://github.com/frequenz-floss/frequenz-api-common.git \\\nsubmodules/frequenz-api-common\ngit commit -m \"Add api-common-protos and frequenz-api-common submodules\" submodules\n</code></pre> <p>Then you need to add this package as a build dependency and a few extra dependencies to your project, for example:</p> <pre><code>requires = [\n\"setuptools &gt;= 67.3.2, &lt; 68\",\n\"setuptools_scm[toml] &gt;= 7.1.0, &lt; 8\",\n\"frequenz-repo-config[api] == 0.9.0\",\n]\nbuild-backend = \"setuptools.build_meta\"\n[project]\ndependencies = [\n\"frequenz-api-common &gt;= 0.2.0, &lt; 0.3.0\",\n\"googleapis-common-protos &gt;= 1.56.2, &lt; 2\",\n\"grpcio &gt;= 1.51.1, &lt; 2\",\n]\n</code></pre> <p>Note the <code>api</code> extra in <code>frequenz-repo-config[api]</code>, this will ensure all dependencies to build the protocol files will be installed when building the package. Of course you need to replace the version numbers with the correct ones too.</p> <p>You should also add the following configuration to your <code>pyproject.toml</code> file to make sure the generated files are included in the wheel:</p> <pre><code>[tool.setuptools.package-dir]\n\"\" = \"py\"\n[tool.setuptools.package-data]\n\"*\" = [\"*.pyi\"]\n[tools.pytest.ini_options]\ntestpaths = [\"pytests\"]\n</code></pre> <p>Finally you need to make sure to include the generated <code>*.pyi</code> files in the source distribution, as well as the Google api-common-protos files, as it is not handled automatically yet (#13). Make sure to include these lines in the <code>MANIFEST.in</code> file:</p> <pre><code>recursive-include submodules/api-common-protos/google *.proto\nrecursive-include submodules/frequenz-api-common/proto *.proto\n</code></pre> <p>Please adapt the instructions above to your project structure if you need to change the defaults.</p>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config-classes","title":"Classes","text":""},{"location":"reference/frequenz/repo/config/#frequenz.repo.config.RepositoryType","title":"frequenz.repo.config.RepositoryType","text":"<p>             Bases: <code>Enum</code></p> <p>Supported types of repository.</p> Source code in <code>frequenz/repo/config/_core.py</code> <pre><code>class RepositoryType(_enum.Enum):\n\"\"\"Supported types of repository.\"\"\"\nACTOR = \"actor\"\n\"\"\"SDK actor repository.\"\"\"\nAPI = \"api\"\n\"\"\"gRPC API repository.\"\"\"\nAPP = \"app\"\n\"\"\"SDK application repository.\"\"\"\nLIB = \"lib\"\n\"\"\"General purpose library repository.\"\"\"\nMODEL = \"model\"\n\"\"\"SDK machine learning model repository.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config.RepositoryType-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/repo/config/#frequenz.repo.config.RepositoryType.ACTOR","title":"ACTOR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ACTOR = 'actor'\n</code></pre> <p>SDK actor repository.</p>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config.RepositoryType.API","title":"API  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>API = 'api'\n</code></pre> <p>gRPC API repository.</p>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config.RepositoryType.APP","title":"APP  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>APP = 'app'\n</code></pre> <p>SDK application repository.</p>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config.RepositoryType.LIB","title":"LIB  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>LIB = 'lib'\n</code></pre> <p>General purpose library repository.</p>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config.RepositoryType.MODEL","title":"MODEL  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MODEL = 'model'\n</code></pre> <p>SDK machine learning model repository.</p>"},{"location":"reference/frequenz/repo/config/github/","title":"github","text":""},{"location":"reference/frequenz/repo/config/github/#frequenz.repo.config.github","title":"frequenz.repo.config.github","text":"<p>Utilities to work with GitHub.</p> <ul> <li><code>abort()</code> to print an error message using GitHub     Actions commands and exit.</li> <li><code>require_env()</code> to get an environment     variable or exit with an error if it is not defined.</li> <li><code>get_tags()</code> to get the tags of a repository.</li> <li><code>get_branches()</code> to get the branches of a     repository.</li> <li><code>configure_logging()</code> to configure     logging for GitHub Actions.</li> </ul>"},{"location":"reference/frequenz/repo/config/github/#frequenz.repo.config.github-classes","title":"Classes","text":""},{"location":"reference/frequenz/repo/config/github/#frequenz.repo.config.github.GitHubActionsFormatter","title":"frequenz.repo.config.github.GitHubActionsFormatter","text":"<p>             Bases: <code>Formatter</code></p> <p>A formatter for GitHub Actions.</p> Source code in <code>frequenz/repo/config/github.py</code> <pre><code>class GitHubActionsFormatter(logging.Formatter):\n\"\"\"A formatter for GitHub Actions.\"\"\"\nlevel_mapping: dict[int, str] = {\nlogging.CRITICAL: \"error\",\nlogging.ERROR: \"error\",\nlogging.WARNING: \"warning\",\nlogging.INFO: \"notice\",\nlogging.DEBUG: \"debug\",\n}\n\"\"\"The mapping from logging levels to GitHub Actions levels.\"\"\"\ndef format(self, record: logging.LogRecord) -&gt; str:\n\"\"\"Format the record using GitHub Actions commands.\n        Args:\n            record: The record to format.\n        Returns:\n            The formatted record.\n        \"\"\"\ngithub_level = self.level_mapping.get(record.levelno, \"notice\")\ngithub_command = f\"::{github_level}::{record.getMessage()}\"\nreturn github_command\n</code></pre>"},{"location":"reference/frequenz/repo/config/github/#frequenz.repo.config.github.GitHubActionsFormatter-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/repo/config/github/#frequenz.repo.config.github.GitHubActionsFormatter.level_mapping","title":"level_mapping  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>level_mapping: dict[int, str] = {\nCRITICAL: \"error\",\nERROR: \"error\",\nWARNING: \"warning\",\nINFO: \"notice\",\nDEBUG: \"debug\",\n}\n</code></pre> <p>The mapping from logging levels to GitHub Actions levels.</p>"},{"location":"reference/frequenz/repo/config/github/#frequenz.repo.config.github.GitHubActionsFormatter-functions","title":"Functions","text":""},{"location":"reference/frequenz/repo/config/github/#frequenz.repo.config.github.GitHubActionsFormatter.format","title":"format","text":"<pre><code>format(record: LogRecord) -&gt; str\n</code></pre> <p>Format the record using GitHub Actions commands.</p> PARAMETER  DESCRIPTION <code>record</code> <p>The record to format.</p> <p> TYPE: <code>LogRecord</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The formatted record.</p> Source code in <code>frequenz/repo/config/github.py</code> <pre><code>def format(self, record: logging.LogRecord) -&gt; str:\n\"\"\"Format the record using GitHub Actions commands.\n    Args:\n        record: The record to format.\n    Returns:\n        The formatted record.\n    \"\"\"\ngithub_level = self.level_mapping.get(record.levelno, \"notice\")\ngithub_command = f\"::{github_level}::{record.getMessage()}\"\nreturn github_command\n</code></pre>"},{"location":"reference/frequenz/repo/config/github/#frequenz.repo.config.github-functions","title":"Functions","text":""},{"location":"reference/frequenz/repo/config/github/#frequenz.repo.config.github.abort","title":"frequenz.repo.config.github.abort","text":"<pre><code>abort(\nmessage: str,\ntitle: str | None = None,\nfile: str | None = None,\ncol: int | None = None,\nend_column: int | None = None,\nline: int | None = None,\nend_line: int | None = None,\nuse_subprocess: bool = False,\nerror_code: int = 1,\n) -&gt; NoReturn\n</code></pre> <p>Print an error message using GitHub Actions commands and exit.</p> PARAMETER  DESCRIPTION <code>message</code> <p>The message of the error.</p> <p> TYPE: <code>str</code> </p> <code>title</code> <p>The title of the error.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>file</code> <p>The file where the error occurred.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>col</code> <p>The column where the error occurred.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>end_column</code> <p>The end column where the error occurred.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>line</code> <p>The line where the error occurred.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>end_line</code> <p>The end line where the error occurred.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>use_subprocess</code> <p>Whether to use subprocess to print the error.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>error_code</code> <p>The error code to exit with.</p> <p> TYPE: <code>int</code> DEFAULT: <code>1</code> </p> Source code in <code>frequenz/repo/config/github.py</code> <pre><code>def abort(  # pylint: disable=too-many-arguments\nmessage: str,\ntitle: str | None = None,\nfile: str | None = None,\ncol: int | None = None,\nend_column: int | None = None,\nline: int | None = None,\nend_line: int | None = None,\nuse_subprocess: bool = False,\nerror_code: int = 1,\n) -&gt; NoReturn:\n\"\"\"Print an error message using GitHub Actions commands and exit.\n    Args:\n        message: The message of the error.\n        title: The title of the error.\n        file: The file where the error occurred.\n        col: The column where the error occurred.\n        end_column: The end column where the error occurred.\n        line: The line where the error occurred.\n        end_line: The end line where the error occurred.\n        use_subprocess: Whether to use subprocess to print the error.\n        error_code: The error code to exit with.\n    \"\"\"\ngha.error(\nmessage,\ntitle=title,\nfile=file,\ncol=col,\nend_column=end_column,\nline=line,\nend_line=end_line,\nuse_subprocess=use_subprocess,\n)\nsys.exit(error_code)\n</code></pre>"},{"location":"reference/frequenz/repo/config/github/#frequenz.repo.config.github.configure_logging","title":"frequenz.repo.config.github.configure_logging","text":"<pre><code>configure_logging(level: int | None = None) -&gt; None\n</code></pre> <p>Configure logging for GitHub Actions.</p> <p>The <code>GitHubActionsFormatter</code> is used to format the logs, using GitHub Action commands.</p> PARAMETER  DESCRIPTION <code>level</code> <p>The logging level to use. If <code>None</code>, the level is set to <code>logging.INFO</code> unless the <code>RUNNER_DEBUG</code> environment variable is set to <code>1</code>, in which case the level is set to <code>logging.DEBUG</code>.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/repo/config/github.py</code> <pre><code>def configure_logging(level: int | None = None) -&gt; None:\n\"\"\"Configure logging for GitHub Actions.\n    The\n    [`GitHubActionsFormatter`][frequenz.repo.config.github.GitHubActionsFormatter]\n    is used to format the logs, using [GitHub Action\n    commands](https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions).\n    Args:\n        level: The logging level to use. If `None`, the level is set to\n            `logging.INFO` unless the `RUNNER_DEBUG` environment variable\n            is set to `1`, in which case the level is set to\n            `logging.DEBUG`.\n    \"\"\"\n# Just for checking it is defined, github_action_utils deals with it automatically.\nrequire_env(\"GITHUB_OUTPUT\")\nis_debug_run = os.environ.get(\"RUNNER_DEBUG\", None) == \"1\"\nhandler = logging.StreamHandler()\nhandler.setFormatter(GitHubActionsFormatter())\nif level is None:\nlevel = logging.DEBUG if is_debug_run else logging.INFO\nlogging.basicConfig(level=level, handlers=[handler])\n</code></pre>"},{"location":"reference/frequenz/repo/config/github/#frequenz.repo.config.github.get_branches","title":"frequenz.repo.config.github.get_branches","text":"<pre><code>get_branches(repository: str) -&gt; list[str]\n</code></pre> <p>Get the branches of the repository.</p> <p>This function uses the <code>BRANCHES</code> environment variable if it is defined. If it is not defined, it uses the GitHub <code>gh</code> CLI tool to get them. This means the tool needs to be properly configured and have at least read access over <code>repository</code>.</p> PARAMETER  DESCRIPTION <code>repository</code> <p>The repository to get the branches of.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>The branches of the repository.</p> Source code in <code>frequenz/repo/config/github.py</code> <pre><code>def get_branches(repository: str) -&gt; list[str]:\n\"\"\"Get the branches of the repository.\n    This function uses the `BRANCHES` environment variable if it is defined. If it\n    is not defined, it uses the GitHub `gh` CLI tool to get them. This means the\n    tool needs to be properly configured and have at least read access over\n    `repository`.\n    Args:\n        repository: The repository to get the branches of.\n    Returns:\n        The branches of the repository.\n    \"\"\"\nbranches_str: list[str]\nif env_branches := os.environ.get(\"BRANCHES\", None):\nbranches_str = env_branches.split()\nelse:\nbranches_str = (\nsubprocess.check_output(\n[\n\"gh\",\n\"api\",\n\"-q\",\n\".[].name\",\n\"-H\",\n\"Accept: application/vnd.github+json\",\n\"-H\",\n\"X-GitHub-Api-Version: 2022-11-28\",\nf\"/repos/{repository}/branches\",\n]\n)\n.decode(\"utf-8\")\n.splitlines()\n)\n_logger.debug(\"Got branches: %r\", branches_str)\nreturn branches_str\n</code></pre>"},{"location":"reference/frequenz/repo/config/github/#frequenz.repo.config.github.get_repo_version_info","title":"frequenz.repo.config.github.get_repo_version_info","text":"<pre><code>get_repo_version_info() -&gt; RepoVersionInfo\n</code></pre> <p>Get the repository version information.</p> <p>This function uses the <code>GITHUB_REPO</code>, <code>GIT_REF</code>, and <code>GIT_SHA</code> environment variables to get the repository information. If these variables are not defined, it raises a <code>ValueError</code>.</p> <p>It also uses the <code>BRANCHES</code> and <code>TAGS</code> environment variables to get the branches and tags of the repository. If they are not defined, the GitHub <code>gh</code> CLI tool is used to get them. This means the tool needs to be properly configured and have at least read access over <code>repository</code>.</p> RETURNS DESCRIPTION <code>RepoVersionInfo</code> <p>The repository version information.</p> Source code in <code>frequenz/repo/config/github.py</code> <pre><code>def get_repo_version_info() -&gt; version.RepoVersionInfo:\n\"\"\"Get the repository version information.\n    This function uses the `GITHUB_REPO`, `GIT_REF`, and `GIT_SHA` environment\n    variables to get the repository information. If these variables are not\n    defined, it raises a `ValueError`.\n    It also uses the `BRANCHES` and `TAGS` environment variables to get the\n    branches and tags of the repository. If they are not defined, the GitHub `gh`\n    CLI tool is used to get them. This means the tool needs to be properly\n    configured and have at least read access over `repository`.\n    Returns:\n        The repository version information.\n    \"\"\"\nrepository = require_env(\"GITHUB_REPO\")\nrepo_info = version.RepoVersionInfo(\nref=require_env(\"GIT_REF\"),\nsha=require_env(\"GIT_SHA\"),\ntags=get_tags(repository),\nbranches=get_branches(repository),\n)\nreturn repo_info\n</code></pre>"},{"location":"reference/frequenz/repo/config/github/#frequenz.repo.config.github.get_tags","title":"frequenz.repo.config.github.get_tags","text":"<pre><code>get_tags(repository: str) -&gt; list[str]\n</code></pre> <p>Get the tags of the repository.</p> <p>This function uses the <code>TAGS</code> environment variable if it is defined. If it is not defined, it uses the GitHub <code>gh</code> CLI tool to get them. This means the tool needs to be properly configured and have at least read access over <code>repository</code>.</p> PARAMETER  DESCRIPTION <code>repository</code> <p>The repository to get the tags of.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>The tags of the repository.</p> Source code in <code>frequenz/repo/config/github.py</code> <pre><code>def get_tags(repository: str) -&gt; list[str]:\n\"\"\"Get the tags of the repository.\n    This function uses the `TAGS` environment variable if it is defined. If it is\n    not defined, it uses the GitHub `gh` CLI tool to get them. This means the tool\n    needs to be properly configured and have at least read access over\n    `repository`.\n    Args:\n        repository: The repository to get the tags of.\n    Returns:\n        The tags of the repository.\n    \"\"\"\ntags_str: list[str]\nif env_tags := os.environ.get(\"TAGS\", None):\ntags_str = env_tags.split()\nelse:\ntags_str = (\nsubprocess.check_output(\n[\n\"gh\",\n\"api\",\n\"-q\",\n\".[].name\",\n\"-H\",\n\"Accept: application/vnd.github+json\",\n\"-H\",\n\"X-GitHub-Api-Version: 2022-11-28\",\nf\"/repos/{repository}/tags\",\n]\n)\n.decode(\"utf-8\")\n.splitlines()\n)\n_logger.debug(\"Got tags: %r\", tags_str)\nreturn tags_str\n</code></pre>"},{"location":"reference/frequenz/repo/config/github/#frequenz.repo.config.github.require_env","title":"frequenz.repo.config.github.require_env","text":"<pre><code>require_env(name: str) -&gt; str\n</code></pre> <p>Get the environment variable.</p> PARAMETER  DESCRIPTION <code>name</code> <p>The name of the environment variable.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The environment variable.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the environment variable is not defined.</p> Source code in <code>frequenz/repo/config/github.py</code> <pre><code>def require_env(name: str) -&gt; str:\n\"\"\"Get the environment variable.\n    Args:\n        name: The name of the environment variable.\n    Returns:\n        The environment variable.\n    Raises:\n        ValueError: If the environment variable is not defined.\n    \"\"\"\nvalue = os.environ.get(name)\nif value is None:\nraise ValueError(f\"Environment variable {name!r} is not defined\")\nreturn value\n</code></pre>"},{"location":"reference/frequenz/repo/config/protobuf/","title":"protobuf","text":""},{"location":"reference/frequenz/repo/config/protobuf/#frequenz.repo.config.protobuf","title":"frequenz.repo.config.protobuf","text":"<p>Manages the configuration to generate files from the protobuf files.</p>"},{"location":"reference/frequenz/repo/config/protobuf/#frequenz.repo.config.protobuf-classes","title":"Classes","text":""},{"location":"reference/frequenz/repo/config/protobuf/#frequenz.repo.config.protobuf.ProtobufConfig","title":"frequenz.repo.config.protobuf.ProtobufConfig  <code>dataclass</code>","text":"<p>A configuration for the protobuf files.</p> <p>The configuration can be loaded from the <code>pyproject.toml</code> file using the class method <code>from_pyproject_toml()</code>.</p> Source code in <code>frequenz/repo/config/protobuf.py</code> <pre><code>@dataclasses.dataclass(frozen=True, kw_only=True)\nclass ProtobufConfig:\n\"\"\"A configuration for the protobuf files.\n    The configuration can be loaded from the `pyproject.toml` file using the class\n    method `from_pyproject_toml()`.\n    \"\"\"\nproto_path: str = \"proto\"\n\"\"\"The path of the root directory containing the protobuf files.\"\"\"\nproto_glob: str = \"*.proto\"\n\"\"\"The glob pattern to use to find the protobuf files.\"\"\"\ninclude_paths: Sequence[str] = (\n\"submodules/api-common-protos\",\n\"submodules/frequenz-api-common/proto\",\n)\n\"\"\"The paths to add to the include path when compiling the protobuf files.\"\"\"\npy_path: str = \"py\"\n\"\"\"The path of the root directory where the Python files will be generated.\"\"\"\ndocs_path: str = \"protobuf-reference\"\n\"\"\"The path of the root directory where the documentation files will be generated.\"\"\"\n@classmethod\ndef from_pyproject_toml(\ncls, path: str = \"pyproject.toml\", /, **defaults: Any\n) -&gt; Self:\n\"\"\"Create a new configuration by loading the options from a `pyproject.toml` file.\n        The options are read from the `[tool.frequenz-repo-config.protobuf]`\n        section of the `pyproject.toml` file.\n        Args:\n            path: The path to the `pyproject.toml` file.\n            **defaults: The default values for the options missing in the file.  If\n                a default is missing too, then the default in this class will be used.\n        Returns:\n            The configuration.\n        \"\"\"\ntry:\nwith pathlib.Path(path).open(\"rb\") as toml_file:\npyproject_toml = tomllib.load(toml_file)\nexcept FileNotFoundError:\nreturn cls(**defaults)\nexcept (IOError, OSError) as err:\n_logger.warning(\"WARNING: Failed to load pyproject.toml: %s\", err)\nreturn cls(**defaults)\ntry:\nconfig = pyproject_toml[\"tool\"][\"frequenz-repo-config\"][\"protobuf\"]\nexcept KeyError:\nreturn cls(**defaults)\ndefault = cls(**defaults)\nknown_keys = frozenset(dataclasses.asdict(default).keys())\nconfig_keys = frozenset(config.keys())\nif unknown_keys := config_keys - known_keys:\n_logger.warning(\n\"WARNING: There are some configuration keys in pyproject.toml we don't \"\n\"know about and will be ignored: %s\",\n\", \".join(f\"'{k}'\" for k in unknown_keys),\n)\nattrs = dict(defaults, **{k: config[k] for k in (known_keys &amp; config_keys)})\nreturn dataclasses.replace(default, **attrs)\n</code></pre>"},{"location":"reference/frequenz/repo/config/protobuf/#frequenz.repo.config.protobuf.ProtobufConfig-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/repo/config/protobuf/#frequenz.repo.config.protobuf.ProtobufConfig.docs_path","title":"docs_path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>docs_path: str = 'protobuf-reference'\n</code></pre> <p>The path of the root directory where the documentation files will be generated.</p>"},{"location":"reference/frequenz/repo/config/protobuf/#frequenz.repo.config.protobuf.ProtobufConfig.include_paths","title":"include_paths  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>include_paths: Sequence[str] = (\n\"submodules/api-common-protos\",\n\"submodules/frequenz-api-common/proto\",\n)\n</code></pre> <p>The paths to add to the include path when compiling the protobuf files.</p>"},{"location":"reference/frequenz/repo/config/protobuf/#frequenz.repo.config.protobuf.ProtobufConfig.proto_glob","title":"proto_glob  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>proto_glob: str = '*.proto'\n</code></pre> <p>The glob pattern to use to find the protobuf files.</p>"},{"location":"reference/frequenz/repo/config/protobuf/#frequenz.repo.config.protobuf.ProtobufConfig.proto_path","title":"proto_path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>proto_path: str = 'proto'\n</code></pre> <p>The path of the root directory containing the protobuf files.</p>"},{"location":"reference/frequenz/repo/config/protobuf/#frequenz.repo.config.protobuf.ProtobufConfig.py_path","title":"py_path  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>py_path: str = 'py'\n</code></pre> <p>The path of the root directory where the Python files will be generated.</p>"},{"location":"reference/frequenz/repo/config/protobuf/#frequenz.repo.config.protobuf.ProtobufConfig-functions","title":"Functions","text":""},{"location":"reference/frequenz/repo/config/protobuf/#frequenz.repo.config.protobuf.ProtobufConfig.from_pyproject_toml","title":"from_pyproject_toml  <code>classmethod</code>","text":"<pre><code>from_pyproject_toml(\npath: str = \"pyproject.toml\", /, **defaults: Any\n) -&gt; Self\n</code></pre> <p>Create a new configuration by loading the options from a <code>pyproject.toml</code> file.</p> <p>The options are read from the <code>[tool.frequenz-repo-config.protobuf]</code> section of the <code>pyproject.toml</code> file.</p> PARAMETER  DESCRIPTION <code>path</code> <p>The path to the <code>pyproject.toml</code> file.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'pyproject.toml'</code> </p> <code>**defaults</code> <p>The default values for the options missing in the file.  If a default is missing too, then the default in this class will be used.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The configuration.</p> Source code in <code>frequenz/repo/config/protobuf.py</code> <pre><code>@classmethod\ndef from_pyproject_toml(\ncls, path: str = \"pyproject.toml\", /, **defaults: Any\n) -&gt; Self:\n\"\"\"Create a new configuration by loading the options from a `pyproject.toml` file.\n    The options are read from the `[tool.frequenz-repo-config.protobuf]`\n    section of the `pyproject.toml` file.\n    Args:\n        path: The path to the `pyproject.toml` file.\n        **defaults: The default values for the options missing in the file.  If\n            a default is missing too, then the default in this class will be used.\n    Returns:\n        The configuration.\n    \"\"\"\ntry:\nwith pathlib.Path(path).open(\"rb\") as toml_file:\npyproject_toml = tomllib.load(toml_file)\nexcept FileNotFoundError:\nreturn cls(**defaults)\nexcept (IOError, OSError) as err:\n_logger.warning(\"WARNING: Failed to load pyproject.toml: %s\", err)\nreturn cls(**defaults)\ntry:\nconfig = pyproject_toml[\"tool\"][\"frequenz-repo-config\"][\"protobuf\"]\nexcept KeyError:\nreturn cls(**defaults)\ndefault = cls(**defaults)\nknown_keys = frozenset(dataclasses.asdict(default).keys())\nconfig_keys = frozenset(config.keys())\nif unknown_keys := config_keys - known_keys:\n_logger.warning(\n\"WARNING: There are some configuration keys in pyproject.toml we don't \"\n\"know about and will be ignored: %s\",\n\", \".join(f\"'{k}'\" for k in unknown_keys),\n)\nattrs = dict(defaults, **{k: config[k] for k in (known_keys &amp; config_keys)})\nreturn dataclasses.replace(default, **attrs)\n</code></pre>"},{"location":"reference/frequenz/repo/config/version/","title":"version","text":""},{"location":"reference/frequenz/repo/config/version/#frequenz.repo.config.version","title":"frequenz.repo.config.version","text":"<p>Version information for a repository.</p> <p>This module provides the <code>RepoVersionInfo</code> class to get information about the repository version.</p> <p>It handles many scenarios and queries, like:</p> <ul> <li>Is the current commit a tag or a branch?</li> <li>Is the current tag the latest tag?</li> <li>Is the current branch the latest branch?</li> <li>Is the current tag the last minor version for the major version?</li> <li>What is the next minor version for the current major branch?</li> <li>etc.</li> </ul> <p>Repository tag names are expected to follow the semantic versioning specification, but usually with a leading <code>v</code> (e.g. <code>v1.0.0</code>). <code>to_semver()</code> can be used to convert a version string to a semantic version, even if it has a leading <code>v</code>.</p> <p>Repository branch names can be parsed with <code>BranchVersion.parse()</code> and are expected follow the format:</p> <ul> <li><code>vX.x.x</code> for major branches, where <code>X</code> is the major version number. For example,   <code>v1.x.x</code> is the major branch for the major version 1.</li> </ul> <p>It represents an in-development major version, from which new minor branches   including new features are created (including the first minor branch for the major   version).</p> <ul> <li><code>vX.Y.x</code> for minor branches, where <code>X</code> is the major version number and <code>Y</code> is the   minor version number. For example, <code>v1.0.x</code> is the minor branch for the major version   1 and minor version 0.</li> </ul> <p>It represents a maintained minor version, from which new patch releases (with bug   fixes) are created. For example, <code>v1.1.x</code> is the minor branch for the major version 1   and minor version 1.</p>"},{"location":"reference/frequenz/repo/config/version/#frequenz.repo.config.version-classes","title":"Classes","text":""},{"location":"reference/frequenz/repo/config/version/#frequenz.repo.config.version.BranchVersion","title":"frequenz.repo.config.version.BranchVersion  <code>dataclass</code>","text":"<p>A branch version.</p> <p>Versions can be compared with each other. If <code>minor</code> is <code>None</code>, it is considered to be greater than any other <code>minor</code>.</p> Source code in <code>frequenz/repo/config/version.py</code> <pre><code>@dataclasses.dataclass(frozen=True, kw_only=True)\nclass BranchVersion:\n\"\"\"A branch version.\n    Versions can be compared with each other. If `minor` is `None`, it is considered to\n    be greater than any other `minor`.\n    \"\"\"\nmajor: int\n\"\"\"The major version number.\"\"\"\nminor: int | None = None\n\"\"\"The minor version number.\"\"\"\nname: str\n\"\"\"The branch name.\"\"\"\ndef __post_init__(self) -&gt; None:\n\"\"\"Post init.\"\"\"\nif self.major &lt; 0:\nraise ValueError(\"major cannot be negative\")\nif self.minor is not None and self.minor &lt; 0:\nraise ValueError(\"minor cannot be negative\")\n@classmethod\ndef parse(cls, branch: str) -&gt; Self | None:\n\"\"\"Parse a branch name.\n        See the [module documentation][frequenz.repo.config.version] for the expected\n        format of the branch name.\n        Args:\n            branch: The branch name.\n        Returns:\n            The parsed branch version information or None if the branch name is not\n                a valid branch name.\n        \"\"\"\nif match := _major_branch_re.match(branch):\nreturn cls(major=int(match.group(1)), name=branch)\nif match := _minor_branch_re.match(branch):\nreturn cls(\nmajor=int(match.group(1)), minor=int(match.group(2)), name=branch\n)\n_logger.debug(\"Invalid branch name: %s\", branch)\nreturn None\ndef __str__(self) -&gt; str:\n\"\"\"Return the branch name.\"\"\"\nreturn self.name\ndef __lt__(self, other: BranchVersion) -&gt; bool:\n\"\"\"Compare two branch version information.\n        If `minor` is `None`, it is considered to be greater than any other `minor`.\n        Args:\n            other: The other branch version information.\n        Returns:\n            Whether the current branch version information is less than the other.\n        \"\"\"\nif not isinstance(other, BranchVersion):\nreturn NotImplemented\nif self.minor is None and other.minor is None:\nself_minor = 0\nother_minor = 0\nelif self.minor is None and other.minor is not None:\nself_minor = other.minor + 1\nother_minor = other.minor\nelif other.minor is None and self.minor is not None:\nself_minor = self.minor\nother_minor = self.minor + 1\nelif self.minor is not None and other.minor is not None:\nself_minor = self.minor\nother_minor = other.minor\nelse:\n# We need this because mypy is not smart enough to figure it out\nassert False, \"unreachable\"\nreturn (self.major, self_minor, self.name) &lt; (\nother.major,\nother_minor,\nother.name,\n)\n</code></pre>"},{"location":"reference/frequenz/repo/config/version/#frequenz.repo.config.version.BranchVersion-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/repo/config/version/#frequenz.repo.config.version.BranchVersion.major","title":"major  <code>instance-attribute</code>","text":"<pre><code>major: int\n</code></pre> <p>The major version number.</p>"},{"location":"reference/frequenz/repo/config/version/#frequenz.repo.config.version.BranchVersion.minor","title":"minor  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>minor: int | None = None\n</code></pre> <p>The minor version number.</p>"},{"location":"reference/frequenz/repo/config/version/#frequenz.repo.config.version.BranchVersion.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>The branch name.</p>"},{"location":"reference/frequenz/repo/config/version/#frequenz.repo.config.version.BranchVersion-functions","title":"Functions","text":""},{"location":"reference/frequenz/repo/config/version/#frequenz.repo.config.version.BranchVersion.__lt__","title":"__lt__","text":"<pre><code>__lt__(other: BranchVersion) -&gt; bool\n</code></pre> <p>Compare two branch version information.</p> <p>If <code>minor</code> is <code>None</code>, it is considered to be greater than any other <code>minor</code>.</p> PARAMETER  DESCRIPTION <code>other</code> <p>The other branch version information.</p> <p> TYPE: <code>BranchVersion</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Whether the current branch version information is less than the other.</p> Source code in <code>frequenz/repo/config/version.py</code> <pre><code>def __lt__(self, other: BranchVersion) -&gt; bool:\n\"\"\"Compare two branch version information.\n    If `minor` is `None`, it is considered to be greater than any other `minor`.\n    Args:\n        other: The other branch version information.\n    Returns:\n        Whether the current branch version information is less than the other.\n    \"\"\"\nif not isinstance(other, BranchVersion):\nreturn NotImplemented\nif self.minor is None and other.minor is None:\nself_minor = 0\nother_minor = 0\nelif self.minor is None and other.minor is not None:\nself_minor = other.minor + 1\nother_minor = other.minor\nelif other.minor is None and self.minor is not None:\nself_minor = self.minor\nother_minor = self.minor + 1\nelif self.minor is not None and other.minor is not None:\nself_minor = self.minor\nother_minor = other.minor\nelse:\n# We need this because mypy is not smart enough to figure it out\nassert False, \"unreachable\"\nreturn (self.major, self_minor, self.name) &lt; (\nother.major,\nother_minor,\nother.name,\n)\n</code></pre>"},{"location":"reference/frequenz/repo/config/version/#frequenz.repo.config.version.BranchVersion.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Post init.</p> Source code in <code>frequenz/repo/config/version.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Post init.\"\"\"\nif self.major &lt; 0:\nraise ValueError(\"major cannot be negative\")\nif self.minor is not None and self.minor &lt; 0:\nraise ValueError(\"minor cannot be negative\")\n</code></pre>"},{"location":"reference/frequenz/repo/config/version/#frequenz.repo.config.version.BranchVersion.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Return the branch name.</p> Source code in <code>frequenz/repo/config/version.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"Return the branch name.\"\"\"\nreturn self.name\n</code></pre>"},{"location":"reference/frequenz/repo/config/version/#frequenz.repo.config.version.BranchVersion.parse","title":"parse  <code>classmethod</code>","text":"<pre><code>parse(branch: str) -&gt; Self | None\n</code></pre> <p>Parse a branch name.</p> <p>See the module documentation for the expected format of the branch name.</p> PARAMETER  DESCRIPTION <code>branch</code> <p>The branch name.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Self | None</code> <p>The parsed branch version information or None if the branch name is not a valid branch name.</p> Source code in <code>frequenz/repo/config/version.py</code> <pre><code>@classmethod\ndef parse(cls, branch: str) -&gt; Self | None:\n\"\"\"Parse a branch name.\n    See the [module documentation][frequenz.repo.config.version] for the expected\n    format of the branch name.\n    Args:\n        branch: The branch name.\n    Returns:\n        The parsed branch version information or None if the branch name is not\n            a valid branch name.\n    \"\"\"\nif match := _major_branch_re.match(branch):\nreturn cls(major=int(match.group(1)), name=branch)\nif match := _minor_branch_re.match(branch):\nreturn cls(\nmajor=int(match.group(1)), minor=int(match.group(2)), name=branch\n)\n_logger.debug(\"Invalid branch name: %s\", branch)\nreturn None\n</code></pre>"},{"location":"reference/frequenz/repo/config/version/#frequenz.repo.config.version.RepoVersionInfo","title":"frequenz.repo.config.version.RepoVersionInfo","text":"<p>The information about a repository version.</p> <p>The information includes if it is a tag, a branch, if tags and branches are well formed, the next minor version, etc.</p> <p>This assumes tags follow semantic versioning and branches are in the form \"v.x.x\" or \"v..x\", where  and  are integers and represent the major and minor for the version being developed in that branch. <p>New minor releases are branched from a major branch, also creating a minor branch for patch releases for that minor. For example, if the current major version is 1, the current major branch is \"v1.x.x\" and the current minor branch is \"v1.0.x\". If the next minor version is 1.1, the new minor branch will be \"v1.1.x\".</p> Source code in <code>frequenz/repo/config/version.py</code> <pre><code>class RepoVersionInfo:  # pylint: disable=too-many-instance-attributes\n\"\"\"The information about a repository version.\n    The information includes if it is a tag, a branch, if tags and branches are well\n    formed, the next minor version, etc.\n    This assumes tags follow semantic versioning and branches are in the form\n    \"v&lt;major&gt;.x.x\" or \"v&lt;major&gt;.&lt;minor&gt;.x\", where &lt;major&gt; and &lt;minor&gt; are integers and\n    represent the major and minor for the version being developed in that branch.\n    New minor releases are branched from a major branch, also creating a minor branch\n    for patch releases for that minor. For example, if the current major version is 1,\n    the current major branch is \"v1.x.x\" and the current minor branch is \"v1.0.x\". If\n    the next minor version is 1.1, the new minor branch will be \"v1.1.x\".\n    \"\"\"\ndef __init__(  # pylint: disable=too-many-arguments\nself,\nsha: str,\nref: str,\ntags: list[str] | None = None,\nbranches: list[str] | None = None,\n) -&gt; None:\n\"\"\"Initialize the environment variables.\n        Args:\n            sha: The current commit hash.\n            ref: The current reference full path (e.g. `refs/tags/v1.0.0`).\n            tags: The tags of the repository.\n            branches: The branches of the repository.\n        \"\"\"\nself._sha: str = sha\n_logger.debug(\"sha: %s\", self._sha)\nself._ref: str = ref\n_logger.debug(\"ref: %s\", self._ref)\nself._ref_name: str = pathlib.Path(ref).name\n_logger.debug(\"ref_name: %s\", self._ref_name)\nself._current_branch: BranchVersion | None = BranchVersion.parse(self._ref_name)\n_logger.debug(\"current_branch: %s\", self._current_branch)\nself._current_tag: semver.Version | None = to_semver(self._ref_name)\n_logger.debug(\"current_tag: %s\", self._current_tag)\nself._tags: dict[str, semver.Version] = _build_tags(tags or [])\n_logger.debug(\"tags: %s\", self._tags)\nself._branches: dict[str, BranchVersion] = _build_branches(branches or [])\n_logger.debug(\"branches: %s\", self._branches)\n@property\ndef sha(self) -&gt; str:\n\"\"\"The current commit hash.\"\"\"\nreturn self._sha\n@property\ndef ref(self) -&gt; str:\n\"\"\"The current reference full path (e.g. `refs/tags/v1.0.0`).\"\"\"\nreturn self._ref\n@property\ndef ref_name(self) -&gt; str:\n\"\"\"The current reference name (e.g. `v1.0.0`).\"\"\"\nreturn self._ref_name\n@property\ndef current_branch(self) -&gt; BranchVersion | None:\n\"\"\"The branch pointing to the current commit.\n        `None` if there is no current branch or the name is invalid.\n        \"\"\"\nreturn self._current_branch\n@property\ndef current_tag(self) -&gt; semver.Version | None:\n\"\"\"The tag pointing to the current commit.\n        `None` if there is no tag or the name is invalid.\n        \"\"\"\nreturn self._current_tag\n@property\ndef tags(self) -&gt; dict[str, semver.Version]:\n\"\"\"The tags of the repository.\n        The key is the tag name and the value is the parsed tag (semantic) version.\n        \"\"\"\nreturn self._tags\n@property\ndef branches(self) -&gt; dict[str, BranchVersion]:\n\"\"\"The branches of the repository.\n        The key is the branch name and the value is the parsed branch name.\n        \"\"\"\nreturn self._branches\ndef find_last_tag(self) -&gt; semver.Version | None:\n\"\"\"Find the last tag.\n        Returns:\n            If we are at a tag, return the [current\n                tag][frequenz.repo.config.version.RepoVersionInfo.current_tag]. If we\n                are at a branch, return the last tag matching the branch major and minor\n                (if any). If there are no matching tags, return `None`.\n        \"\"\"\nif self._current_tag:\nreturn self._current_tag\nbranch = self.current_branch\nif branch is None:\nreturn None\ntags = [t for t in self._tags.values() if t.major == branch.major]\nif branch.minor is not None:\ntags = [t for t in tags if t.minor == branch.minor]\nif not tags:\nreturn None\nreturn max(tags)\ndef find_next_breaking_branch(self) -&gt; BranchVersion | None:\n\"\"\"Find the next branch potentially introducing breaking changes.\n        Returns:\n            If there is a last tag, use that as a base, otherwise use the current branch\n                as a base. If none is available, return `None`. If there is a base, the\n                major is incremented by one and the minor is set to `None`, unless the\n                major is 0 (an \"initial development version\" for semver), in which case\n                the major is set to 0 and the minor is incremented by one, as the next\n                minor could be a breaking change. Technically semver allows breaking\n                changes in patches for major version 0, but we assume patches maintain\n                backwards compatibility.\n        \"\"\"\nv_prefix = \"v\" if self._ref_name.startswith(\"v\") else \"\"\nlast_tag = self.find_last_tag()\nif last_tag is None:\nbranch = self.current_branch\nif branch is None:\n_logger.warning(\n\"Trying to get the next breaking branch but there is no (valid) \"\n\"last tag nor current branch for %r\",\nself._ref,\n)\nreturn None\nmajor = branch.major + 1\nminor = branch.minor or 1\nelse:\nmajor = last_tag.major + 1\nminor = last_tag.minor + 1\n# If the next major is 1, then the current is 0, so the next minor could be\n# a breaking change.\nif major == 1:\nreturn BranchVersion(major=0, minor=minor, name=f\"{v_prefix}0.{minor}.x\")\nreturn BranchVersion(major=major, name=f\"{v_prefix}{major}.x.x\")\ndef find_next_minor_for_major_branch(self) -&gt; int | None:\n\"\"\"Find the next minor version for the current major branch.\n        Returns:\n            The next minor version or `None` if there is no current branch, the\n                current branch is invalid or is not a major branch.\n        \"\"\"\nbranch = self.current_branch\nif branch is None:\n_logger.warning(\n\"Trying to get the next minor for the current branch but \"\n\"the current branch is invalid: %r\",\nbranch,\n)\nreturn None\nif branch.minor is not None:\n_logger.warning(\n\"Trying to get the next minor for the current branch but \"\n\"the current branch is not a major branch: %r\",\nbranch,\n)\nreturn None\nminor_tags = [\ntag\nfor tag in self._tags.values()\nif tag.major == branch.major and tag.prerelease is None\n]\nif not minor_tags:\nreturn 0\nbigger_tag = max(minor_tags, key=lambda tag: tag.minor)\nreturn bigger_tag.minor + 1\ndef is_tag(self) -&gt; bool:\n\"\"\"Tell whether we are at a stable release.\"\"\"\nreturn self._ref.startswith(\"refs/tags/\")\ndef is_branch(self) -&gt; bool:\n\"\"\"Tell whether we are at a major branch.\"\"\"\nreturn self._ref.startswith(\"refs/heads/\")\ndef is_tag_last_minor_for_major(self) -&gt; bool:\n\"\"\"Tell whether the current tag is the last minor version for the major version.\n        If we are not at a tag or there are not tags in the repo, return `False`.\n        If the `current_tag` is a pre-release, only pre-release tags are considered and\n        if is not a pre-release, only stable tags are considered.\n        \"\"\"\ntag = self.current_tag\nif tag is None:\n_logger.warning(\n\"Can't determine if %r is the last minor tag for the major version \"\n\"because we are not at a tag or the tag is invalid\",\nself._ref_name,\n)\nreturn False\nminor_tags = [tag_ for tag_ in self._tags.values() if tag_.major == tag.major]\nif tag.prerelease is None:\nminor_tags = [tag_ for tag_ in minor_tags if tag_.prerelease is None]\nelse:\nminor_tags = [tag_ for tag_ in minor_tags if tag_.prerelease is not None]\nif not minor_tags:\n_logger.debug(\n\"No minor tags found for major version %s, considering the \"\n\"tag %r the last minor for this major\",\ntag.major,\ntag,\n)\nreturn True\nreturn tag &gt;= max(minor_tags, key=lambda tag_: tag_.minor)\ndef is_tag_latest(self) -&gt; bool:\n\"\"\"Tell whether the current tag is the latest tag.\n        The latest tag is the tag with the biggest major, minor and patch\n        version. If the current tag is a prerelease, then only prereleases are used to\n        determine the biggest.\n        Sorting is always according to semver.\n        \"\"\"\ntag = self.current_tag\nif tag is None:\n_logger.warning(\n\"Can't determine if %r is the latest tag because we are not at a tag \"\n\"or the tag is invalid\",\nself._ref_name,\n)\nreturn False\nif tag.prerelease is None:\ntags_it = (tag_ for tag_ in self._tags.values() if tag_.prerelease is None)\nelse:\ntags_it = (\ntag_ for tag_ in self._tags.values() if tag_.prerelease is not None\n)\nlatest = sorted(tags_it, reverse=True)\nif not latest:\n_logger.warning(\n\"No other tags found, at least the current tag %r should be in the list \"\n\"of tags (%r)\",\ntag,\nself._tags,\n)\nreturn False\nreturn tag == latest[0]\ndef is_branch_latest(self) -&gt; bool:\n\"\"\"Tell whether the current branch is the latest.\n        The latest branch is the branch with the biggest major and minor, but if minor\n        is `None`, then it is considered the biggest minor.\n        \"\"\"\nbranch = self.current_branch\nif branch is None:\n_logger.warning(\n\"Can't determine if %r is the latest branch because we are not at \"\n\"a branch or the branch is invalid\",\nself._ref_name,\n)\nreturn False\nlatest = sorted(self._branches.values(), reverse=True)\nif not latest:\n_logger.warning(\n\"No other branches found, at least the current branch %r should be in the list \"\n\"of branches (%r)\",\nbranch,\nself._branches,\n)\nreturn False\nreturn branch == latest[0]\n</code></pre>"},{"location":"reference/frequenz/repo/config/version/#frequenz.repo.config.version.RepoVersionInfo-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/repo/config/version/#frequenz.repo.config.version.RepoVersionInfo.branches","title":"branches  <code>property</code>","text":"<pre><code>branches: dict[str, BranchVersion]\n</code></pre> <p>The branches of the repository.</p> <p>The key is the branch name and the value is the parsed branch name.</p>"},{"location":"reference/frequenz/repo/config/version/#frequenz.repo.config.version.RepoVersionInfo.current_branch","title":"current_branch  <code>property</code>","text":"<pre><code>current_branch: BranchVersion | None\n</code></pre> <p>The branch pointing to the current commit.</p> <p><code>None</code> if there is no current branch or the name is invalid.</p>"},{"location":"reference/frequenz/repo/config/version/#frequenz.repo.config.version.RepoVersionInfo.current_tag","title":"current_tag  <code>property</code>","text":"<pre><code>current_tag: Version | None\n</code></pre> <p>The tag pointing to the current commit.</p> <p><code>None</code> if there is no tag or the name is invalid.</p>"},{"location":"reference/frequenz/repo/config/version/#frequenz.repo.config.version.RepoVersionInfo.ref","title":"ref  <code>property</code>","text":"<pre><code>ref: str\n</code></pre> <p>The current reference full path (e.g. <code>refs/tags/v1.0.0</code>).</p>"},{"location":"reference/frequenz/repo/config/version/#frequenz.repo.config.version.RepoVersionInfo.ref_name","title":"ref_name  <code>property</code>","text":"<pre><code>ref_name: str\n</code></pre> <p>The current reference name (e.g. <code>v1.0.0</code>).</p>"},{"location":"reference/frequenz/repo/config/version/#frequenz.repo.config.version.RepoVersionInfo.sha","title":"sha  <code>property</code>","text":"<pre><code>sha: str\n</code></pre> <p>The current commit hash.</p>"},{"location":"reference/frequenz/repo/config/version/#frequenz.repo.config.version.RepoVersionInfo.tags","title":"tags  <code>property</code>","text":"<pre><code>tags: dict[str, Version]\n</code></pre> <p>The tags of the repository.</p> <p>The key is the tag name and the value is the parsed tag (semantic) version.</p>"},{"location":"reference/frequenz/repo/config/version/#frequenz.repo.config.version.RepoVersionInfo-functions","title":"Functions","text":""},{"location":"reference/frequenz/repo/config/version/#frequenz.repo.config.version.RepoVersionInfo.__init__","title":"__init__","text":"<pre><code>__init__(\nsha: str,\nref: str,\ntags: list[str] | None = None,\nbranches: list[str] | None = None,\n) -&gt; None\n</code></pre> <p>Initialize the environment variables.</p> PARAMETER  DESCRIPTION <code>sha</code> <p>The current commit hash.</p> <p> TYPE: <code>str</code> </p> <code>ref</code> <p>The current reference full path (e.g. <code>refs/tags/v1.0.0</code>).</p> <p> TYPE: <code>str</code> </p> <code>tags</code> <p>The tags of the repository.</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> <code>branches</code> <p>The branches of the repository.</p> <p> TYPE: <code>list[str] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>frequenz/repo/config/version.py</code> <pre><code>def __init__(  # pylint: disable=too-many-arguments\nself,\nsha: str,\nref: str,\ntags: list[str] | None = None,\nbranches: list[str] | None = None,\n) -&gt; None:\n\"\"\"Initialize the environment variables.\n    Args:\n        sha: The current commit hash.\n        ref: The current reference full path (e.g. `refs/tags/v1.0.0`).\n        tags: The tags of the repository.\n        branches: The branches of the repository.\n    \"\"\"\nself._sha: str = sha\n_logger.debug(\"sha: %s\", self._sha)\nself._ref: str = ref\n_logger.debug(\"ref: %s\", self._ref)\nself._ref_name: str = pathlib.Path(ref).name\n_logger.debug(\"ref_name: %s\", self._ref_name)\nself._current_branch: BranchVersion | None = BranchVersion.parse(self._ref_name)\n_logger.debug(\"current_branch: %s\", self._current_branch)\nself._current_tag: semver.Version | None = to_semver(self._ref_name)\n_logger.debug(\"current_tag: %s\", self._current_tag)\nself._tags: dict[str, semver.Version] = _build_tags(tags or [])\n_logger.debug(\"tags: %s\", self._tags)\nself._branches: dict[str, BranchVersion] = _build_branches(branches or [])\n_logger.debug(\"branches: %s\", self._branches)\n</code></pre>"},{"location":"reference/frequenz/repo/config/version/#frequenz.repo.config.version.RepoVersionInfo.find_last_tag","title":"find_last_tag","text":"<pre><code>find_last_tag() -&gt; Version | None\n</code></pre> <p>Find the last tag.</p> RETURNS DESCRIPTION <code>Version | None</code> <p>If we are at a tag, return the current tag. If we are at a branch, return the last tag matching the branch major and minor (if any). If there are no matching tags, return <code>None</code>.</p> Source code in <code>frequenz/repo/config/version.py</code> <pre><code>def find_last_tag(self) -&gt; semver.Version | None:\n\"\"\"Find the last tag.\n    Returns:\n        If we are at a tag, return the [current\n            tag][frequenz.repo.config.version.RepoVersionInfo.current_tag]. If we\n            are at a branch, return the last tag matching the branch major and minor\n            (if any). If there are no matching tags, return `None`.\n    \"\"\"\nif self._current_tag:\nreturn self._current_tag\nbranch = self.current_branch\nif branch is None:\nreturn None\ntags = [t for t in self._tags.values() if t.major == branch.major]\nif branch.minor is not None:\ntags = [t for t in tags if t.minor == branch.minor]\nif not tags:\nreturn None\nreturn max(tags)\n</code></pre>"},{"location":"reference/frequenz/repo/config/version/#frequenz.repo.config.version.RepoVersionInfo.find_next_breaking_branch","title":"find_next_breaking_branch","text":"<pre><code>find_next_breaking_branch() -&gt; BranchVersion | None\n</code></pre> <p>Find the next branch potentially introducing breaking changes.</p> RETURNS DESCRIPTION <code>BranchVersion | None</code> <p>If there is a last tag, use that as a base, otherwise use the current branch as a base. If none is available, return <code>None</code>. If there is a base, the major is incremented by one and the minor is set to <code>None</code>, unless the major is 0 (an \"initial development version\" for semver), in which case the major is set to 0 and the minor is incremented by one, as the next minor could be a breaking change. Technically semver allows breaking changes in patches for major version 0, but we assume patches maintain backwards compatibility.</p> Source code in <code>frequenz/repo/config/version.py</code> <pre><code>def find_next_breaking_branch(self) -&gt; BranchVersion | None:\n\"\"\"Find the next branch potentially introducing breaking changes.\n    Returns:\n        If there is a last tag, use that as a base, otherwise use the current branch\n            as a base. If none is available, return `None`. If there is a base, the\n            major is incremented by one and the minor is set to `None`, unless the\n            major is 0 (an \"initial development version\" for semver), in which case\n            the major is set to 0 and the minor is incremented by one, as the next\n            minor could be a breaking change. Technically semver allows breaking\n            changes in patches for major version 0, but we assume patches maintain\n            backwards compatibility.\n    \"\"\"\nv_prefix = \"v\" if self._ref_name.startswith(\"v\") else \"\"\nlast_tag = self.find_last_tag()\nif last_tag is None:\nbranch = self.current_branch\nif branch is None:\n_logger.warning(\n\"Trying to get the next breaking branch but there is no (valid) \"\n\"last tag nor current branch for %r\",\nself._ref,\n)\nreturn None\nmajor = branch.major + 1\nminor = branch.minor or 1\nelse:\nmajor = last_tag.major + 1\nminor = last_tag.minor + 1\n# If the next major is 1, then the current is 0, so the next minor could be\n# a breaking change.\nif major == 1:\nreturn BranchVersion(major=0, minor=minor, name=f\"{v_prefix}0.{minor}.x\")\nreturn BranchVersion(major=major, name=f\"{v_prefix}{major}.x.x\")\n</code></pre>"},{"location":"reference/frequenz/repo/config/version/#frequenz.repo.config.version.RepoVersionInfo.find_next_minor_for_major_branch","title":"find_next_minor_for_major_branch","text":"<pre><code>find_next_minor_for_major_branch() -&gt; int | None\n</code></pre> <p>Find the next minor version for the current major branch.</p> RETURNS DESCRIPTION <code>int | None</code> <p>The next minor version or <code>None</code> if there is no current branch, the current branch is invalid or is not a major branch.</p> Source code in <code>frequenz/repo/config/version.py</code> <pre><code>def find_next_minor_for_major_branch(self) -&gt; int | None:\n\"\"\"Find the next minor version for the current major branch.\n    Returns:\n        The next minor version or `None` if there is no current branch, the\n            current branch is invalid or is not a major branch.\n    \"\"\"\nbranch = self.current_branch\nif branch is None:\n_logger.warning(\n\"Trying to get the next minor for the current branch but \"\n\"the current branch is invalid: %r\",\nbranch,\n)\nreturn None\nif branch.minor is not None:\n_logger.warning(\n\"Trying to get the next minor for the current branch but \"\n\"the current branch is not a major branch: %r\",\nbranch,\n)\nreturn None\nminor_tags = [\ntag\nfor tag in self._tags.values()\nif tag.major == branch.major and tag.prerelease is None\n]\nif not minor_tags:\nreturn 0\nbigger_tag = max(minor_tags, key=lambda tag: tag.minor)\nreturn bigger_tag.minor + 1\n</code></pre>"},{"location":"reference/frequenz/repo/config/version/#frequenz.repo.config.version.RepoVersionInfo.is_branch","title":"is_branch","text":"<pre><code>is_branch() -&gt; bool\n</code></pre> <p>Tell whether we are at a major branch.</p> Source code in <code>frequenz/repo/config/version.py</code> <pre><code>def is_branch(self) -&gt; bool:\n\"\"\"Tell whether we are at a major branch.\"\"\"\nreturn self._ref.startswith(\"refs/heads/\")\n</code></pre>"},{"location":"reference/frequenz/repo/config/version/#frequenz.repo.config.version.RepoVersionInfo.is_branch_latest","title":"is_branch_latest","text":"<pre><code>is_branch_latest() -&gt; bool\n</code></pre> <p>Tell whether the current branch is the latest.</p> <p>The latest branch is the branch with the biggest major and minor, but if minor is <code>None</code>, then it is considered the biggest minor.</p> Source code in <code>frequenz/repo/config/version.py</code> <pre><code>def is_branch_latest(self) -&gt; bool:\n\"\"\"Tell whether the current branch is the latest.\n    The latest branch is the branch with the biggest major and minor, but if minor\n    is `None`, then it is considered the biggest minor.\n    \"\"\"\nbranch = self.current_branch\nif branch is None:\n_logger.warning(\n\"Can't determine if %r is the latest branch because we are not at \"\n\"a branch or the branch is invalid\",\nself._ref_name,\n)\nreturn False\nlatest = sorted(self._branches.values(), reverse=True)\nif not latest:\n_logger.warning(\n\"No other branches found, at least the current branch %r should be in the list \"\n\"of branches (%r)\",\nbranch,\nself._branches,\n)\nreturn False\nreturn branch == latest[0]\n</code></pre>"},{"location":"reference/frequenz/repo/config/version/#frequenz.repo.config.version.RepoVersionInfo.is_tag","title":"is_tag","text":"<pre><code>is_tag() -&gt; bool\n</code></pre> <p>Tell whether we are at a stable release.</p> Source code in <code>frequenz/repo/config/version.py</code> <pre><code>def is_tag(self) -&gt; bool:\n\"\"\"Tell whether we are at a stable release.\"\"\"\nreturn self._ref.startswith(\"refs/tags/\")\n</code></pre>"},{"location":"reference/frequenz/repo/config/version/#frequenz.repo.config.version.RepoVersionInfo.is_tag_last_minor_for_major","title":"is_tag_last_minor_for_major","text":"<pre><code>is_tag_last_minor_for_major() -&gt; bool\n</code></pre> <p>Tell whether the current tag is the last minor version for the major version.</p> <p>If we are not at a tag or there are not tags in the repo, return <code>False</code>.</p> <p>If the <code>current_tag</code> is a pre-release, only pre-release tags are considered and if is not a pre-release, only stable tags are considered.</p> Source code in <code>frequenz/repo/config/version.py</code> <pre><code>def is_tag_last_minor_for_major(self) -&gt; bool:\n\"\"\"Tell whether the current tag is the last minor version for the major version.\n    If we are not at a tag or there are not tags in the repo, return `False`.\n    If the `current_tag` is a pre-release, only pre-release tags are considered and\n    if is not a pre-release, only stable tags are considered.\n    \"\"\"\ntag = self.current_tag\nif tag is None:\n_logger.warning(\n\"Can't determine if %r is the last minor tag for the major version \"\n\"because we are not at a tag or the tag is invalid\",\nself._ref_name,\n)\nreturn False\nminor_tags = [tag_ for tag_ in self._tags.values() if tag_.major == tag.major]\nif tag.prerelease is None:\nminor_tags = [tag_ for tag_ in minor_tags if tag_.prerelease is None]\nelse:\nminor_tags = [tag_ for tag_ in minor_tags if tag_.prerelease is not None]\nif not minor_tags:\n_logger.debug(\n\"No minor tags found for major version %s, considering the \"\n\"tag %r the last minor for this major\",\ntag.major,\ntag,\n)\nreturn True\nreturn tag &gt;= max(minor_tags, key=lambda tag_: tag_.minor)\n</code></pre>"},{"location":"reference/frequenz/repo/config/version/#frequenz.repo.config.version.RepoVersionInfo.is_tag_latest","title":"is_tag_latest","text":"<pre><code>is_tag_latest() -&gt; bool\n</code></pre> <p>Tell whether the current tag is the latest tag.</p> <p>The latest tag is the tag with the biggest major, minor and patch version. If the current tag is a prerelease, then only prereleases are used to determine the biggest.</p> <p>Sorting is always according to semver.</p> Source code in <code>frequenz/repo/config/version.py</code> <pre><code>def is_tag_latest(self) -&gt; bool:\n\"\"\"Tell whether the current tag is the latest tag.\n    The latest tag is the tag with the biggest major, minor and patch\n    version. If the current tag is a prerelease, then only prereleases are used to\n    determine the biggest.\n    Sorting is always according to semver.\n    \"\"\"\ntag = self.current_tag\nif tag is None:\n_logger.warning(\n\"Can't determine if %r is the latest tag because we are not at a tag \"\n\"or the tag is invalid\",\nself._ref_name,\n)\nreturn False\nif tag.prerelease is None:\ntags_it = (tag_ for tag_ in self._tags.values() if tag_.prerelease is None)\nelse:\ntags_it = (\ntag_ for tag_ in self._tags.values() if tag_.prerelease is not None\n)\nlatest = sorted(tags_it, reverse=True)\nif not latest:\n_logger.warning(\n\"No other tags found, at least the current tag %r should be in the list \"\n\"of tags (%r)\",\ntag,\nself._tags,\n)\nreturn False\nreturn tag == latest[0]\n</code></pre>"},{"location":"reference/frequenz/repo/config/version/#frequenz.repo.config.version-functions","title":"Functions","text":""},{"location":"reference/frequenz/repo/config/version/#frequenz.repo.config.version.strip_v","title":"frequenz.repo.config.version.strip_v","text":"<pre><code>strip_v(version: str) -&gt; str\n</code></pre> <p>Strip the leading 'v' from a version string.</p> PARAMETER  DESCRIPTION <code>version</code> <p>The version string.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The version string without the leading 'v'.</p> Source code in <code>frequenz/repo/config/version.py</code> <pre><code>def strip_v(version: str) -&gt; str:\n\"\"\"Strip the leading 'v' from a version string.\n    Args:\n        version: The version string.\n    Returns:\n        The version string without the leading 'v'.\n    \"\"\"\nreturn version[1:] if version.startswith(\"v\") else version\n</code></pre>"},{"location":"reference/frequenz/repo/config/version/#frequenz.repo.config.version.to_semver","title":"frequenz.repo.config.version.to_semver","text":"<pre><code>to_semver(version: str) -&gt; Version | None\n</code></pre> <p>Convert a version string to a semantic version.</p> PARAMETER  DESCRIPTION <code>version</code> <p>The version string.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Version | None</code> <p>The semantic version or <code>None</code> if the version string is not a valid semantic version.</p> Source code in <code>frequenz/repo/config/version.py</code> <pre><code>def to_semver(version: str) -&gt; semver.Version | None:\n\"\"\"Convert a version string to a semantic version.\n    Args:\n        version: The version string.\n    Returns:\n        The semantic version or `None` if the version string is not a valid semantic\n            version.\n    \"\"\"\ntry:\nreturn semver.Version.parse(strip_v(version))\nexcept ValueError:\nlogging.debug(\"Version is not a semantic version: %s\", version)\nreturn None\n</code></pre>"},{"location":"reference/frequenz/repo/config/cli/","title":"Index","text":""},{"location":"reference/frequenz/repo/config/cli/#frequenz.repo.config.cli","title":"frequenz.repo.config.cli","text":"<p>Command line interface.</p>"},{"location":"reference/frequenz/repo/config/cli/version/","title":"Index","text":""},{"location":"reference/frequenz/repo/config/cli/version/#frequenz.repo.config.cli.version","title":"frequenz.repo.config.cli.version","text":"<p>Command line interface for versioning.</p>"},{"location":"reference/frequenz/repo/config/cli/version/mike/","title":"Index","text":""},{"location":"reference/frequenz/repo/config/cli/version/mike/#frequenz.repo.config.cli.version.mike","title":"frequenz.repo.config.cli.version.mike","text":"<p>Command line interface for <code>mike</code>-related versioning.</p>"},{"location":"reference/frequenz/repo/config/cli/version/mike/info/","title":"info","text":""},{"location":"reference/frequenz/repo/config/cli/version/mike/info/#frequenz.repo.config.cli.version.mike.info","title":"frequenz.repo.config.cli.version.mike.info","text":"<p>Command-line tool to get the current <code>mike</code> version information of a repository.</p> <p>For now this tool is designed to be used in GitHub Actions workflows, but is is possible to use it in other environments as well. To do so the <code>gh</code> tool should be properly configured and have at least read-access to the repository, and the following environment variables should be set:</p> <ul> <li><code>GITHUB_REPO</code>: The repository to get the version information of (e.g.   <code>frequenz-floss/frequenz-sdk-python</code>).</li> <li><code>GIT_REF</code>: The git reference to get the version information of (e.g.   <code>refs/heads/v1.x.x</code>).</li> <li><code>GIT_SHA</code>: The git sha to get the version information of (e.g.   <code>84df6ad1d9990d7afd47a9f8e8a386702b09eba0</code>).</li> <li><code>TAGS</code>: The tags of the repository (e.g. <code>v1.0.0 v1.0.1</code>).</li> <li><code>BRANCHES</code>: The branches of the repository (e.g. <code>v1.x.x v2.x.x</code>).</li> <li><code>GITHUB_OUTPUT</code>: The output variable to set the version information to (e.g.   <code>/dev/stdout</code>).</li> </ul>"},{"location":"reference/frequenz/repo/config/cli/version/mike/info/#frequenz.repo.config.cli.version.mike.info-functions","title":"Functions","text":""},{"location":"reference/frequenz/repo/config/cli/version/mike/info/#frequenz.repo.config.cli.version.mike.info.main","title":"frequenz.repo.config.cli.version.mike.info.main","text":"<pre><code>main() -&gt; None\n</code></pre> <p>Output mike version variables for GitHub Actions.</p> Source code in <code>frequenz/repo/config/cli/version/mike/info.py</code> <pre><code>def main() -&gt; None:\n\"\"\"Output mike version variables for GitHub Actions.\"\"\"\ngithub.configure_logging()\ntry:\nmike_version = mike.build_mike_version(github.get_repo_version_info())\nexcept ValueError as error:\ngha.warning(\nf\"{error}.\", title=\"Could not determine the version information for `mike`\"\n)\nreturn\n_output_gha_vars(mike_version)\n</code></pre>"},{"location":"reference/frequenz/repo/config/cli/version/mike/sort/","title":"sort","text":""},{"location":"reference/frequenz/repo/config/cli/version/mike/sort/#frequenz.repo.config.cli.version.mike.sort","title":"frequenz.repo.config.cli.version.mike.sort","text":"<p>Sort <code>mike</code>'s <code>version.json</code> file with a custom order.</p>"},{"location":"reference/frequenz/repo/config/cli/version/mike/sort/#frequenz.repo.config.cli.version.mike.sort-functions","title":"Functions","text":""},{"location":"reference/frequenz/repo/config/cli/version/mike/sort/#frequenz.repo.config.cli.version.mike.sort.main","title":"frequenz.repo.config.cli.version.mike.sort.main","text":"<pre><code>main() -&gt; None\n</code></pre> <p>Sort <code>mike</code>'s <code>version.json</code> file with a custom order.</p> <p>The versions are sorted using <code>sort_versions()</code>.</p> <p>If no arguments are given, then the contents are read from stdin and the sorted versions are printed to stdout.</p> <p>If one argument is given, then the contents of the file are replaced with the sorted versions.</p> <p>If more than one argument is given, then an error is printed to stderr and the program exits with a non-zero exit code.</p> Source code in <code>frequenz/repo/config/cli/version/mike/sort.py</code> <pre><code>def main() -&gt; None:\n\"\"\"Sort `mike`'s `version.json` file with a custom order.\n    The versions are sorted using `sort_versions()`.\n    If no arguments are given, then the contents are read from stdin and the sorted\n    versions are printed to stdout.\n    If one argument is given, then the contents of the file are replaced with the sorted\n    versions.\n    If more than one argument is given, then an error is printed to stderr and the\n    program exits with a non-zero exit code.\n    \"\"\"\ngithub.configure_logging()\nmatch len(sys.argv):\ncase 1:\n_dump_versions_to(_load_and_sort_versions_from(sys.stdin), sys.stdout)\ncase 2:\nwith open(sys.argv[1], \"r\", encoding=\"utf8\") as stream_in:\nversions = _load_and_sort_versions_from(stream_in)\nwith open(sys.argv[1], \"w\", encoding=\"utf8\") as stream_out:\n_dump_versions_to(versions, stream_out)\ncase _:\nprint(\nf\"\"\"\\\nUsage: {sys.argv[0]} [&lt;versions.json&gt;]\nIf &lt;versions.json&gt; is given, the contents will be replaced with the sorted versions.\nOtherwise, the contents are read from stdin and the sorted versions are printed to stdout.\n\"\"\",\nfile=sys.stderr,\n)\nsys.exit(2)\n</code></pre>"},{"location":"reference/frequenz/repo/config/mkdocs/","title":"Index","text":""},{"location":"reference/frequenz/repo/config/mkdocs/#frequenz.repo.config.mkdocs","title":"frequenz.repo.config.mkdocs","text":"<p>Tools to manage and generate documentation using <code>mkdocs</code>.</p>"},{"location":"reference/frequenz/repo/config/mkdocs/#frequenz.repo.config.mkdocs-functions","title":"Functions","text":""},{"location":"reference/frequenz/repo/config/mkdocs/#frequenz.repo.config.mkdocs.generate_protobuf_api_pages","title":"frequenz.repo.config.mkdocs.generate_protobuf_api_pages","text":"<pre><code>generate_protobuf_api_pages(\nsrc_path: str = \"proto\",\ndst_path: str = \"protobuf-reference\",\n) -&gt; None\n</code></pre> <p>Generate API documentation pages for the code.</p> <p>Internal modules (those starting with an underscore except from <code>__init__</code>) are not included.</p> <p>A summary page is generated as <code>SUMMARY.md</code> which is compatible with the <code>mkdocs-literary-nav</code> plugin.</p> PARAMETER  DESCRIPTION <code>src_path</code> <p>Path where the code is located.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'proto'</code> </p> <code>dst_path</code> <p>Path where the documentation should be generated.  This is relative to the output directory of mkdocs.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'protobuf-reference'</code> </p> Source code in <code>frequenz/repo/config/mkdocs/api_pages.py</code> <pre><code>def generate_protobuf_api_pages(\nsrc_path: str = \"proto\", dst_path: str = \"protobuf-reference\"\n) -&gt; None:\n\"\"\"Generate API documentation pages for the code.\n    Internal modules (those starting with an underscore except from `__init__`) are\n    not included.\n    A summary page is generated as `SUMMARY.md` which is compatible with the\n    `mkdocs-literary-nav` plugin.\n    Args:\n        src_path: Path where the code is located.\n        dst_path: Path where the documentation should be generated.  This is relative\n            to the output directory of mkdocs.\n    \"\"\"\n# type ignore because mkdocs_gen_files uses a very weird module-level\n# __getattr__() which messes up the type system\nnav = mkdocs_gen_files.Nav()  # type: ignore\nconfig = _protobuf.ProtobufConfig.from_pyproject_toml(\nproto_path=src_path, docs_path=dst_path\n)\ncwd = Path.cwd()\nwith tempfile.TemporaryDirectory(prefix=\"mkdocs-protobuf-reference-\") as tmp_path:\nfor path in sorted(Path(config.proto_path).rglob(\"*.proto\")):\ndoc_path = path.relative_to(config.proto_path).with_suffix(\".md\")\nfull_doc_path = Path(config.docs_path, doc_path)\nparts = tuple(path.relative_to(config.proto_path).parts)\nnav[parts] = doc_path.as_posix()\ndoc_tmp_path = tmp_path / doc_path\ndoc_tmp_path.parent.mkdir(parents=True, exist_ok=True)\ntry:\nsubprocess.run(\n[\n\"docker\",\n\"run\",\n\"--rm\",\nf\"-v{cwd}:{cwd}\",\nf\"-v{tmp_path}:{tmp_path}\",\n\"pseudomuto/protoc-gen-doc\",\nf\"-I{cwd / config.proto_path}\",\n*(f\"-I{cwd / p}\" for p in config.include_paths),\nf\"--doc_opt=markdown,{doc_path.name}\",\nf\"--doc_out={tmp_path / doc_path.parent}\",\nstr(cwd / path),\n],\ncheck=True,\n)\nexcept subprocess.CalledProcessError as error:\nprint(f\"Error generating protobuf reference page: {error}\")\nwith doc_tmp_path.open() as input_file, mkdocs_gen_files.open(\nfull_doc_path, \"w\"\n) as output_file:\noutput_file.write(input_file.read())\nmkdocs_gen_files.set_edit_path(full_doc_path, Path(\"..\") / path)\nwith mkdocs_gen_files.open(Path(config.docs_path) / \"SUMMARY.md\", \"w\") as nav_file:\nnav_file.writelines(nav.build_literate_nav())\n</code></pre>"},{"location":"reference/frequenz/repo/config/mkdocs/#frequenz.repo.config.mkdocs.generate_python_api_pages","title":"frequenz.repo.config.mkdocs.generate_python_api_pages","text":"<pre><code>generate_python_api_pages(\nsrc_path: str = \"src\",\ndst_path: str = \"python-reference\",\n) -&gt; None\n</code></pre> <p>Generate API documentation pages for the code.</p> <p>Internal modules (those starting with an underscore except from <code>__init__</code>) are not included.</p> <p>A summary page is generated as <code>SUMMARY.md</code> which is compatible with the <code>mkdocs-literary-nav</code> plugin.</p> PARAMETER  DESCRIPTION <code>src_path</code> <p>Path where the code is located.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'src'</code> </p> <code>dst_path</code> <p>Path where the documentation should be generated.  This is relative to the output directory of mkdocs.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'python-reference'</code> </p> Source code in <code>frequenz/repo/config/mkdocs/api_pages.py</code> <pre><code>def generate_python_api_pages(\nsrc_path: str = \"src\", dst_path: str = \"python-reference\"\n) -&gt; None:\n\"\"\"Generate API documentation pages for the code.\n    Internal modules (those starting with an underscore except from `__init__`) are\n    not included.\n    A summary page is generated as `SUMMARY.md` which is compatible with the\n    `mkdocs-literary-nav` plugin.\n    Args:\n        src_path: Path where the code is located.\n        dst_path: Path where the documentation should be generated.  This is relative\n            to the output directory of mkdocs.\n    \"\"\"\n# type ignore because mkdocs_gen_files uses a very weird module-level\n# __getattr__() which messes up the type system\nnav = mkdocs_gen_files.Nav()  # type: ignore\nfor path in sorted(Path(src_path).rglob(\"*.py\")):\nmodule_path = path.relative_to(src_path).with_suffix(\"\")\ndoc_path = path.relative_to(src_path).with_suffix(\".md\")\nfull_doc_path = Path(dst_path, doc_path)\nparts = tuple(module_path.parts)\nif _is_internal(parts):\ncontinue\nif parts[-1] == \"__init__\":\ndoc_path = doc_path.with_name(\"index.md\")\nfull_doc_path = full_doc_path.with_name(\"index.md\")\nparts = parts[:-1]\nnav[parts] = doc_path.as_posix()\nwith mkdocs_gen_files.open(full_doc_path, \"w\") as output_file:\noutput_file.write(f\"::: {'.'.join(parts)}\\n\")\nmkdocs_gen_files.set_edit_path(full_doc_path, Path(\"..\") / path)\nwith mkdocs_gen_files.open(Path(dst_path) / \"SUMMARY.md\", \"w\") as nav_file:\nnav_file.writelines(nav.build_literate_nav())\n</code></pre>"},{"location":"reference/frequenz/repo/config/mkdocs/api_pages/","title":"api_pages","text":""},{"location":"reference/frequenz/repo/config/mkdocs/api_pages/#frequenz.repo.config.mkdocs.api_pages","title":"frequenz.repo.config.mkdocs.api_pages","text":"<p>Generate the code reference pages.</p> <p>It uses the following <code>mkdocs</code> plugins:</p> <ul> <li><code>mkdocs-gen-files</code> to generate the API documentation pages.</li> <li><code>mkdocs-literate-nav</code> to make use of the generate <code>SUMMARY.md</code> file.</li> </ul> <p>Based on the recipe at: https://mkdocstrings.github.io/recipes/#automatic-code-reference-pages</p>"},{"location":"reference/frequenz/repo/config/mkdocs/api_pages/#frequenz.repo.config.mkdocs.api_pages-functions","title":"Functions","text":""},{"location":"reference/frequenz/repo/config/mkdocs/api_pages/#frequenz.repo.config.mkdocs.api_pages.generate_protobuf_api_pages","title":"frequenz.repo.config.mkdocs.api_pages.generate_protobuf_api_pages","text":"<pre><code>generate_protobuf_api_pages(\nsrc_path: str = \"proto\",\ndst_path: str = \"protobuf-reference\",\n) -&gt; None\n</code></pre> <p>Generate API documentation pages for the code.</p> <p>Internal modules (those starting with an underscore except from <code>__init__</code>) are not included.</p> <p>A summary page is generated as <code>SUMMARY.md</code> which is compatible with the <code>mkdocs-literary-nav</code> plugin.</p> PARAMETER  DESCRIPTION <code>src_path</code> <p>Path where the code is located.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'proto'</code> </p> <code>dst_path</code> <p>Path where the documentation should be generated.  This is relative to the output directory of mkdocs.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'protobuf-reference'</code> </p> Source code in <code>frequenz/repo/config/mkdocs/api_pages.py</code> <pre><code>def generate_protobuf_api_pages(\nsrc_path: str = \"proto\", dst_path: str = \"protobuf-reference\"\n) -&gt; None:\n\"\"\"Generate API documentation pages for the code.\n    Internal modules (those starting with an underscore except from `__init__`) are\n    not included.\n    A summary page is generated as `SUMMARY.md` which is compatible with the\n    `mkdocs-literary-nav` plugin.\n    Args:\n        src_path: Path where the code is located.\n        dst_path: Path where the documentation should be generated.  This is relative\n            to the output directory of mkdocs.\n    \"\"\"\n# type ignore because mkdocs_gen_files uses a very weird module-level\n# __getattr__() which messes up the type system\nnav = mkdocs_gen_files.Nav()  # type: ignore\nconfig = _protobuf.ProtobufConfig.from_pyproject_toml(\nproto_path=src_path, docs_path=dst_path\n)\ncwd = Path.cwd()\nwith tempfile.TemporaryDirectory(prefix=\"mkdocs-protobuf-reference-\") as tmp_path:\nfor path in sorted(Path(config.proto_path).rglob(\"*.proto\")):\ndoc_path = path.relative_to(config.proto_path).with_suffix(\".md\")\nfull_doc_path = Path(config.docs_path, doc_path)\nparts = tuple(path.relative_to(config.proto_path).parts)\nnav[parts] = doc_path.as_posix()\ndoc_tmp_path = tmp_path / doc_path\ndoc_tmp_path.parent.mkdir(parents=True, exist_ok=True)\ntry:\nsubprocess.run(\n[\n\"docker\",\n\"run\",\n\"--rm\",\nf\"-v{cwd}:{cwd}\",\nf\"-v{tmp_path}:{tmp_path}\",\n\"pseudomuto/protoc-gen-doc\",\nf\"-I{cwd / config.proto_path}\",\n*(f\"-I{cwd / p}\" for p in config.include_paths),\nf\"--doc_opt=markdown,{doc_path.name}\",\nf\"--doc_out={tmp_path / doc_path.parent}\",\nstr(cwd / path),\n],\ncheck=True,\n)\nexcept subprocess.CalledProcessError as error:\nprint(f\"Error generating protobuf reference page: {error}\")\nwith doc_tmp_path.open() as input_file, mkdocs_gen_files.open(\nfull_doc_path, \"w\"\n) as output_file:\noutput_file.write(input_file.read())\nmkdocs_gen_files.set_edit_path(full_doc_path, Path(\"..\") / path)\nwith mkdocs_gen_files.open(Path(config.docs_path) / \"SUMMARY.md\", \"w\") as nav_file:\nnav_file.writelines(nav.build_literate_nav())\n</code></pre>"},{"location":"reference/frequenz/repo/config/mkdocs/api_pages/#frequenz.repo.config.mkdocs.api_pages.generate_python_api_pages","title":"frequenz.repo.config.mkdocs.api_pages.generate_python_api_pages","text":"<pre><code>generate_python_api_pages(\nsrc_path: str = \"src\",\ndst_path: str = \"python-reference\",\n) -&gt; None\n</code></pre> <p>Generate API documentation pages for the code.</p> <p>Internal modules (those starting with an underscore except from <code>__init__</code>) are not included.</p> <p>A summary page is generated as <code>SUMMARY.md</code> which is compatible with the <code>mkdocs-literary-nav</code> plugin.</p> PARAMETER  DESCRIPTION <code>src_path</code> <p>Path where the code is located.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'src'</code> </p> <code>dst_path</code> <p>Path where the documentation should be generated.  This is relative to the output directory of mkdocs.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'python-reference'</code> </p> Source code in <code>frequenz/repo/config/mkdocs/api_pages.py</code> <pre><code>def generate_python_api_pages(\nsrc_path: str = \"src\", dst_path: str = \"python-reference\"\n) -&gt; None:\n\"\"\"Generate API documentation pages for the code.\n    Internal modules (those starting with an underscore except from `__init__`) are\n    not included.\n    A summary page is generated as `SUMMARY.md` which is compatible with the\n    `mkdocs-literary-nav` plugin.\n    Args:\n        src_path: Path where the code is located.\n        dst_path: Path where the documentation should be generated.  This is relative\n            to the output directory of mkdocs.\n    \"\"\"\n# type ignore because mkdocs_gen_files uses a very weird module-level\n# __getattr__() which messes up the type system\nnav = mkdocs_gen_files.Nav()  # type: ignore\nfor path in sorted(Path(src_path).rglob(\"*.py\")):\nmodule_path = path.relative_to(src_path).with_suffix(\"\")\ndoc_path = path.relative_to(src_path).with_suffix(\".md\")\nfull_doc_path = Path(dst_path, doc_path)\nparts = tuple(module_path.parts)\nif _is_internal(parts):\ncontinue\nif parts[-1] == \"__init__\":\ndoc_path = doc_path.with_name(\"index.md\")\nfull_doc_path = full_doc_path.with_name(\"index.md\")\nparts = parts[:-1]\nnav[parts] = doc_path.as_posix()\nwith mkdocs_gen_files.open(full_doc_path, \"w\") as output_file:\noutput_file.write(f\"::: {'.'.join(parts)}\\n\")\nmkdocs_gen_files.set_edit_path(full_doc_path, Path(\"..\") / path)\nwith mkdocs_gen_files.open(Path(dst_path) / \"SUMMARY.md\", \"w\") as nav_file:\nnav_file.writelines(nav.build_literate_nav())\n</code></pre>"},{"location":"reference/frequenz/repo/config/mkdocs/mike/","title":"mike","text":""},{"location":"reference/frequenz/repo/config/mkdocs/mike/#frequenz.repo.config.mkdocs.mike","title":"frequenz.repo.config.mkdocs.mike","text":"<p>Tools to work with mike.</p> <p>This module provides these tools:</p> <ul> <li>Building the mike version information from the repository information   (<code>build_mike_version()</code>).</li> <li>Sorting the mike version information <code>version.json</code> file   (<code>sort_mike_versions()</code>).</li> <li>Comparing mike versions   (<code>compare_mike_version()</code>).</li> </ul> <p>Mike versions have the format <code>vX.Y(-pre|-dev)?</code>, where <code>X</code> is the major version, <code>Y</code> is the minor version, and the optional suffix is either <code>-pre</code> for pre-release versions or <code>-dev</code> for development versions.</p> <p>Stable (tagged) versions have the format <code>vX.Y</code>, unless they are pre-release versions, then they have the format <code>vX.Y-pre</code>. Develoment branches have the format <code>vX.Y-dev</code>.</p> <ul> <li>Tag <code>v1.0.0</code> -&gt; <code>v1.0</code></li> <li>Tag <code>v2.1.0-alpha.1</code> -&gt; <code>v2.1-pre</code></li> <li>Branch <code>v1.x.x</code> (with no releases) -&gt; <code>v1.0-dev</code></li> <li>Branch <code>v1.x.x (with releases an existing release, for example</code>v1.0.0<code>) -&gt;</code>v1.1-dev`</li> <li>Branch <code>v1.1.x</code> -&gt; <code>v1.1-dev</code></li> </ul> <p>Aliases have the format <code>vX(-pre|-dev)?</code>, where <code>X</code> is the major version and the optional suffix is either <code>-pre</code> for pre-release versions or <code>-dev</code> for development versions. An alias is also provided to point to the latest version, which is <code>latest</code> for stable versions, <code>latest-pre</code> for pre-release versions, and <code>latest-dev</code> for development versions.</p>"},{"location":"reference/frequenz/repo/config/mkdocs/mike/#frequenz.repo.config.mkdocs.mike-classes","title":"Classes","text":""},{"location":"reference/frequenz/repo/config/mkdocs/mike/#frequenz.repo.config.mkdocs.mike.MikeVersionInfo","title":"frequenz.repo.config.mkdocs.mike.MikeVersionInfo  <code>dataclass</code>","text":"<p>The information needed to publish a mike version.</p> <p>This is what mike needs when publishing documentation for a particular version.</p> Source code in <code>frequenz/repo/config/mkdocs/mike.py</code> <pre><code>@dataclasses.dataclass(frozen=True, kw_only=True)\nclass MikeVersionInfo:\n\"\"\"The information needed to publish a mike version.\n    This is what mike needs when publishing documentation for a particular version.\n    \"\"\"\nversion: str\n\"\"\"The version identifier of this version.\"\"\"\ntitle: str = \"\"\n\"\"\"The title of this version.\"\"\"\naliases: list[str] = dataclasses.field(default_factory=list)\n\"\"\"The aliases of this version.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/repo/config/mkdocs/mike/#frequenz.repo.config.mkdocs.mike.MikeVersionInfo-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/repo/config/mkdocs/mike/#frequenz.repo.config.mkdocs.mike.MikeVersionInfo.aliases","title":"aliases  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>aliases: list[str] = field(default_factory=list)\n</code></pre> <p>The aliases of this version.</p>"},{"location":"reference/frequenz/repo/config/mkdocs/mike/#frequenz.repo.config.mkdocs.mike.MikeVersionInfo.title","title":"title  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>title: str = ''\n</code></pre> <p>The title of this version.</p>"},{"location":"reference/frequenz/repo/config/mkdocs/mike/#frequenz.repo.config.mkdocs.mike.MikeVersionInfo.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: str\n</code></pre> <p>The version identifier of this version.</p>"},{"location":"reference/frequenz/repo/config/mkdocs/mike/#frequenz.repo.config.mkdocs.mike-functions","title":"Functions","text":""},{"location":"reference/frequenz/repo/config/mkdocs/mike/#frequenz.repo.config.mkdocs.mike.build_mike_version","title":"frequenz.repo.config.mkdocs.mike.build_mike_version","text":"<pre><code>build_mike_version(\nrepo_info: RepoVersionInfo,\n) -&gt; MikeVersionInfo\n</code></pre> <p>Build the mike version information from the given repository information.</p> <p>The version is build based on if a tag or a branch is checked out.</p> <p>For tags, the title is the tag name, the version is \"vX.Y\", where X is the major version and Y is the minor version of the tag. If the tag is the last minor version for the major version, the alias \"vX\" is added. If the tag is the latest tag, the alias \"latest\" is added.</p> <p>For pre-release tags it's the same but the \"-pre\" suffix is added to the version and the aliases.</p> <p>For branches, the title is \"vX.Y-dev (SHA)\", where X is the major version and Y is the minor version of the branch. The version is \"vX.Y-dev\". If the branch is the latest branch, the alias \"latest-dev\" is added.</p> PARAMETER  DESCRIPTION <code>repo_info</code> <p>The repository information.</p> <p> TYPE: <code>RepoVersionInfo</code> </p> RETURNS DESCRIPTION <code>MikeVersionInfo</code> <p>The mike version.</p> RAISES DESCRIPTION <code>ValueError</code> <p>If the given repository information is invalid or versions can't be determined for some other reason.</p> Source code in <code>frequenz/repo/config/mkdocs/mike.py</code> <pre><code>def build_mike_version(repo_info: RepoVersionInfo) -&gt; MikeVersionInfo:\n\"\"\"Build the mike version information from the given repository information.\n    The version is build based on if a tag or a branch is checked out.\n    For tags, the title is the tag name, the version is \"vX.Y\", where X is the major\n    version and Y is the minor version of the tag. If the tag is the last minor version\n    for the major version, the alias \"vX\" is added. If the tag is the latest tag, the\n    alias \"latest\" is added.\n    For pre-release tags it's the same but the \"-pre\" suffix is added to the version and\n    the aliases.\n    For branches, the title is \"vX.Y-dev (SHA)\", where X is the major version and Y is\n    the minor version of the branch. The version is \"vX.Y-dev\". If the branch is the\n    latest branch, the alias \"latest-dev\" is added.\n    Args:\n        repo_info: The repository information.\n    Returns:\n        The mike version.\n    Raises:\n        ValueError: If the given repository information is invalid or versions can't be\n            determined for some other reason.\n    \"\"\"\ntitle: str = \"\"\nversion: str = \"\"\naliases: list[str] = []\nif repo_info.is_tag():\ncurrent_tag = repo_info.current_tag\nif current_tag is None:\nraise ValueError(\nf\"The tag {repo_info.ref_name!r} is not a valid semver version\",\n)\nsuffix = \"\"\nif current_tag.prerelease is not None:\nsuffix = \"-pre\"\ntitle = repo_info.ref_name  # vX.Y.Z\nversion = f\"v{current_tag.major}.{current_tag.minor}{suffix}\"  # vX.Y(-pre)?\nif repo_info.is_tag_last_minor_for_major():\naliases.append(f\"v{current_tag.major}{suffix}\")  # vX(-pre)?\nif repo_info.is_tag_latest():\naliases.append(f\"latest{suffix}\")  # latest(-pre)?\nreturn MikeVersionInfo(title=title, version=version, aliases=aliases)\nif repo_info.is_branch():\ncurrent_branch = repo_info.current_branch\nif current_branch is None:\nraise ValueError(\nf\"The branch {repo_info.ref_name!r} is not a valid branch name\",\n)\nminor: int\nif current_branch.minor is None:\nnext_minor = repo_info.find_next_minor_for_major_branch()\nif next_minor is None:\nraise ValueError(\nf\"Could not determine the next minor version for {current_branch.name!r}\",\n)\nminor = next_minor\naliases.append(f\"v{current_branch.major}-dev\")  # vX-dev\nelse:\nminor = current_branch.minor\nmajor = current_branch.major\ntitle = f\"v{major}.{minor}-dev ({repo_info.sha[:7]})\"\nversion = f\"v{major}.{minor}-dev\"  # vX.Y-dev\nif repo_info.is_branch_latest():\naliases.append(\"latest-dev\")\nreturn MikeVersionInfo(title=title, version=version, aliases=aliases)\nraise ValueError(\nf\"Don't know how to handle '{repo_info.ref}' to make 'mike' version\",\n)\n</code></pre>"},{"location":"reference/frequenz/repo/config/mkdocs/mike/#frequenz.repo.config.mkdocs.mike.compare_mike_version","title":"frequenz.repo.config.mkdocs.mike.compare_mike_version","text":"<pre><code>compare_mike_version(version1: str, version2: str) -&gt; int\n</code></pre> <p>Compare two versions.</p> <p>The versions are compared as follows:</p> <ul> <li>Versions are first compared by major version (<code>X</code>).</li> <li>If they have the same major, then they are compared by minor version (<code>Y</code>).</li> <li>If they have the same major and minor, then stable versions (<code>vX.Y</code>) are   considered bigger than pre-releases (<code>vX.Y-pre</code>) and development versions   (<code>vX.Y-dev</code>) are considered bigger than pre-releases.</li> <li>Any other version not matching <code>vX.Y(-pre|-dev)?</code> is considered to be bigger than   the matching versions.</li> <li>Not matching versions are compared alphabetically.</li> </ul> <p>Example:</p> <pre><code>`v1.0-pre` &lt; `v1.0` &lt; `v1.0-dev` &lt; `v1.1` &lt; `v2.0-pre` &lt; `v2.0` &lt; `v2.0-dev`\n&lt; `whatever` &lt; `x`.\n</code></pre> PARAMETER  DESCRIPTION <code>version1</code> <p>The first version to compare.</p> <p> TYPE: <code>str</code> </p> <code>version2</code> <p>The second version to compare.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>int</code> <p>A negative number if <code>version1</code> is older than <code>version2</code>, a positive number if <code>version1</code> is newer than <code>version2</code>, or zero if they are equal.</p> Source code in <code>frequenz/repo/config/mkdocs/mike.py</code> <pre><code>def compare_mike_version(version1: str, version2: str) -&gt; int:\n\"\"\"Compare two versions.\n    The versions are compared as follows:\n    - Versions are first compared by major version (`X`).\n    - If they have the same major, then they are compared by minor version (`Y`).\n    - If they have the same major and minor, then stable versions (`vX.Y`) are\n      considered bigger than pre-releases (`vX.Y-pre`) and development versions\n      (`vX.Y-dev`) are considered bigger than pre-releases.\n    - Any other version not matching `vX.Y(-pre|-dev)?` is considered to be bigger than\n      the matching versions.\n    - Not matching versions are compared alphabetically.\n    Example:\n        `v1.0-pre` &lt; `v1.0` &lt; `v1.0-dev` &lt; `v1.1` &lt; `v2.0-pre` &lt; `v2.0` &lt; `v2.0-dev`\n        &lt; `whatever` &lt; `x`.\n    Args:\n        version1: The first version to compare.\n        version2: The second version to compare.\n    Returns:\n        A negative number if `version1` is older than `version2`, a positive number if\n            `version1` is newer than `version2`, or zero if they are equal.\n    \"\"\"\nis_version_v1 = _is_version_re.match(version1)\nis_version_v2 = _is_version_re.match(version2)\nif is_version_v1 and is_version_v2:\nreturn semver.Version.parse(_to_fake_sortable_semver(version1)).compare(\n_to_fake_sortable_semver(version2)\n)\nif is_version_v1:  # version2 is not a version\nreturn -1\nif is_version_v2:  # version1 is not a version\nreturn 1\nreturn -1 if version1 &lt; version2 else 1\n</code></pre>"},{"location":"reference/frequenz/repo/config/mkdocs/mike/#frequenz.repo.config.mkdocs.mike.sort_mike_versions","title":"frequenz.repo.config.mkdocs.mike.sort_mike_versions","text":"<pre><code>sort_mike_versions(\nversions: list[str], *, reverse: bool = True\n) -&gt; list[str]\n</code></pre> <p>Sort <code>mike</code>'s <code>version.json</code> file with a custom order.</p> <p>The <code>version</code> keys are expected as follows:</p> <ul> <li><code>vX.Y</code> for stable release versions</li> <li><code>vX.Y-pre</code> for pre-release versions</li> <li><code>vX.Y-dev</code> for development versions</li> <li>Any other arbitrary string for other versions</li> </ul> <p>The sorting order is as follows:</p> <ul> <li>Versions are first sorted by major version (<code>X</code>).</li> <li>Inside a major version group, versions are sorted by minor version (<code>Y</code>).</li> <li>For the same major and minor version, development versions (<code>-dev</code>) considered   the latest for that major version group, then stable versions, and finally   pre-release versions (<code>-pre</code>).</li> <li>Other versions appear first and are sorted alphabetically.</li> </ul> <p>The versions are sorted in-place using <code>compare_mike_version()</code>.</p> <p>Example:</p> <pre><code>`z`, `whatever`, `v2.1-dev`, `v2.1`, `v2.1-pre`, `v2.0`, `v1.1-dev`, `v1.0-dev`,\n`v1.0`\n</code></pre> PARAMETER  DESCRIPTION <code>versions</code> <p>The list of versions to sort.</p> <p> TYPE: <code>list[str]</code> </p> <code>reverse</code> <p>Whether to sort in reverse order.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>The sorted list of versions.</p> Source code in <code>frequenz/repo/config/mkdocs/mike.py</code> <pre><code>def sort_mike_versions(versions: list[str], *, reverse: bool = True) -&gt; list[str]:\n\"\"\"Sort `mike`'s `version.json` file with a custom order.\n    The `version` keys are expected as follows:\n    - `vX.Y` for stable release versions\n    - `vX.Y-pre` for pre-release versions\n    - `vX.Y-dev` for development versions\n    - Any other arbitrary string for other versions\n    The sorting order is as follows:\n    - Versions are first sorted by major version (`X`).\n    - Inside a major version group, versions are sorted by minor version (`Y`).\n    - For the same major and minor version, development versions (`-dev`) considered\n      the latest for that major version group, then stable versions, and finally\n      pre-release versions (`-pre`).\n    - Other versions appear first and are sorted alphabetically.\n    The versions are sorted in-place using\n    [`compare_mike_version()`][frequenz.repo.config.mkdocs.mike.compare_mike_version].\n    Example:\n        `z`, `whatever`, `v2.1-dev`, `v2.1`, `v2.1-pre`, `v2.0`, `v1.1-dev`, `v1.0-dev`,\n        `v1.0`\n    Args:\n        versions: The list of versions to sort.\n        reverse: Whether to sort in reverse order.\n    Returns:\n        The sorted list of versions.\n    \"\"\"\nversions.sort(key=functools.cmp_to_key(compare_mike_version), reverse=reverse)\nreturn versions\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/","title":"Index","text":""},{"location":"reference/frequenz/repo/config/nox/#frequenz.repo.config.nox","title":"frequenz.repo.config.nox","text":"<p>Utilities to build noxfiles.</p> <p>The main entry point is the <code>configure()</code> function, which will configure all nox sessions according to some configuration.</p> <p>To use the default options, you should call <code>configure()</code> using one of the repository types.  For example:</p> <pre><code>from frequenz.repo.config import RepositoryType, nox\nnox.configure(RepositoryType.LIB)\n</code></pre> <p>Again, make sure to pick the correct project typedefault configuration based on the type of your project (<code>actor_config</code>, <code>api_config</code>, <code>app_config</code>, <code>lib_config</code>, <code>model_config</code>).</p> <p>If you need to use some custom configuration, you can start from the default settings in the <code>frequenz.repo.config.nox.default</code> module, copying it and changing whatever you need to customize.  For example:</p> <pre><code>from frequenz.repo.config import nox\nfrom frequenz.repo.config.nox import default\nconfig = default.lib_config.copy()\nconfig.opts.black.append(\"--diff\")\nnox.configure(config)\n</code></pre> <p>If you need further customization or to define new sessions, you can use the following modules:</p> <ul> <li> <p><code>frequenz.repo.config.nox.config</code>: Low-level utilities to configure nox sessions.   It defines the <code>Config</code> and CommandsOptions<code>classes and the actual implementation of   the</code>configure()<code>function. It also defines the</code>get()` function, which can be used to   get the currently used configuration object.</p> </li> <li> <p><code>frequenz.repo.config.nox.session</code>: Predefined nox sessions. These are the   sessions that are used by default.</p> </li> <li> <p><code>frequenz.repo.config.nox.util</code>: General purpose utility functions.</p> </li> </ul>"},{"location":"reference/frequenz/repo/config/nox/#frequenz.repo.config.nox-functions","title":"Functions","text":""},{"location":"reference/frequenz/repo/config/nox/#frequenz.repo.config.nox.configure","title":"frequenz.repo.config.nox.configure","text":"<pre><code>configure(\nconf: Config | RepositoryType,\n/,\n*,\nimport_default_sessions: bool = True,\n) -&gt; None\n</code></pre> <p>Configure nox using the provided configuration or repository type.</p> PARAMETER  DESCRIPTION <code>conf</code> <p>The configuration to use to configure nox, or the repository type to use to configure nox.  The later will use the default configuration in <code>frequenz.repo.config.nox.default</code> for that type of repository.</p> <p> TYPE: <code>Config | RepositoryType</code> </p> <code>import_default_sessions</code> <p>Whether to import the default sessions or not. This is only necessary if you want to avoid using the default provided sessions and use your own.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>frequenz/repo/config/nox/config.py</code> <pre><code>def configure(\nconf: Config | RepositoryType, /, *, import_default_sessions: bool = True\n) -&gt; None:\n\"\"\"Configure nox using the provided configuration or repository type.\n    Args:\n        conf: The configuration to use to configure nox, or the repository type to use\n            to configure nox.  The later will use the default configuration in\n            [`frequenz.repo.config.nox.default`][] for that type of repository.\n        import_default_sessions: Whether to import the default sessions or not.\n            This is only necessary if you want to avoid using the default provided\n            sessions and use your own.\n    \"\"\"\nglobal _config  # pylint: disable=global-statement\n# We need to make sure sessions are imported, otherwise they won't be visible to nox.\nif import_default_sessions:\n# pylint: disable=import-outside-toplevel,cyclic-import\nfrom . import session as _  # noqa: F401\nmatch conf:\ncase Config():\n_config = conf\ncase RepositoryType() as repo_type:\n# pylint: disable=import-outside-toplevel,cyclic-import\nfrom . import default\nmatch repo_type:\ncase RepositoryType.ACTOR:\n_config = default.actor_config\ncase RepositoryType.API:\n_config = default.api_config\ncase RepositoryType.APP:\n_config = default.app_config\ncase RepositoryType.LIB:\n_config = default.lib_config\ncase RepositoryType.MODEL:\n_config = default.model_config\ncase _ as unhandled:\nassert_never(unhandled)\n_nox.options.sessions = _config.sessions\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/config/","title":"config","text":""},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config","title":"frequenz.repo.config.nox.config","text":"<p>Configuration utilities for nox.</p> <p>This module provides utilities to configure the nox sessions. It provides a <code>Config</code> and a <code>CommandsOptions</code> class, which are used to configure the nox sessions.</p> <p>The <code>get()</code> function can be used to retrieve the current configuration object so it can be used when implementing custom nox sessions.</p> <p>The <code>configure()</code> function must be called before <code>get()</code> is used.</p>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config-classes","title":"Classes","text":""},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.CommandsOptions","title":"frequenz.repo.config.nox.config.CommandsOptions  <code>dataclass</code>","text":"<p>Command-line options for each command.</p> Source code in <code>frequenz/repo/config/nox/config.py</code> <pre><code>@_dataclasses.dataclass(kw_only=True, slots=True)\nclass CommandsOptions:\n\"\"\"Command-line options for each command.\"\"\"\nblack: list[str] = _dataclasses.field(default_factory=lambda: [])\n\"\"\"Command-line options for the `black` command.\"\"\"\nflake8: list[str] = _dataclasses.field(default_factory=lambda: [])\n\"\"\"Command-line options for the `flake8` command.\"\"\"\nisort: list[str] = _dataclasses.field(default_factory=lambda: [])\n\"\"\"Command-line options for the `isort` command.\"\"\"\nmypy: list[str] = _dataclasses.field(default_factory=lambda: [])\n\"\"\"Command-line options for the `mypy` command.\"\"\"\npylint: list[str] = _dataclasses.field(default_factory=lambda: [])\n\"\"\"Command-line options for the `pylint` command.\"\"\"\npytest: list[str] = _dataclasses.field(default_factory=lambda: [])\n\"\"\"Command-line options for the `pytest` command.\"\"\"\ndef copy(self) -&gt; Self:\n\"\"\"Create a new object as a copy of self.\n        Returns:\n            The copy of self.\n        \"\"\"\nreturn _dataclasses.replace(\nself,\nblack=self.black.copy(),\nflake8=self.flake8.copy(),\nisort=self.isort.copy(),\nmypy=self.mypy.copy(),\npylint=self.pylint.copy(),\npytest=self.pytest.copy(),\n)\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.CommandsOptions-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.CommandsOptions.black","title":"black  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>black: list[str] = field(default_factory=lambda : [])\n</code></pre> <p>Command-line options for the <code>black</code> command.</p>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.CommandsOptions.flake8","title":"flake8  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>flake8: list[str] = field(default_factory=lambda : [])\n</code></pre> <p>Command-line options for the <code>flake8</code> command.</p>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.CommandsOptions.isort","title":"isort  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>isort: list[str] = field(default_factory=lambda : [])\n</code></pre> <p>Command-line options for the <code>isort</code> command.</p>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.CommandsOptions.mypy","title":"mypy  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mypy: list[str] = field(default_factory=lambda : [])\n</code></pre> <p>Command-line options for the <code>mypy</code> command.</p>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.CommandsOptions.pylint","title":"pylint  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pylint: list[str] = field(default_factory=lambda : [])\n</code></pre> <p>Command-line options for the <code>pylint</code> command.</p>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.CommandsOptions.pytest","title":"pytest  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pytest: list[str] = field(default_factory=lambda : [])\n</code></pre> <p>Command-line options for the <code>pytest</code> command.</p>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.CommandsOptions-functions","title":"Functions","text":""},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.CommandsOptions.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> <p>Create a new object as a copy of self.</p> RETURNS DESCRIPTION <code>Self</code> <p>The copy of self.</p> Source code in <code>frequenz/repo/config/nox/config.py</code> <pre><code>def copy(self) -&gt; Self:\n\"\"\"Create a new object as a copy of self.\n    Returns:\n        The copy of self.\n    \"\"\"\nreturn _dataclasses.replace(\nself,\nblack=self.black.copy(),\nflake8=self.flake8.copy(),\nisort=self.isort.copy(),\nmypy=self.mypy.copy(),\npylint=self.pylint.copy(),\npytest=self.pytest.copy(),\n)\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.Config","title":"frequenz.repo.config.nox.config.Config  <code>dataclass</code>","text":"<p>Configuration for nox sessions.</p> Source code in <code>frequenz/repo/config/nox/config.py</code> <pre><code>@_dataclasses.dataclass(kw_only=True, slots=True)\nclass Config:\n\"\"\"Configuration for nox sessions.\"\"\"\nopts: CommandsOptions = _dataclasses.field(default_factory=CommandsOptions)\n\"\"\"Command-line options for each command used by sessions.\"\"\"\nsessions: list[str] = _dataclasses.field(default_factory=lambda: [])\n\"\"\"List of sessions to run.\"\"\"\nsource_paths: list[str] = _dataclasses.field(default_factory=lambda: [])\n\"\"\"List of paths containing source files that should be analyzed by the sessions.\n    Source paths are inspected for `__init__.py` files to look for packages.\n    The path should be the top-level directory containing packages that will be\n    actually part of the distribution, not development paths, like tests,\n    benchmarks, etc.\n    This path will be removed when calculating the package name for the found\n    packages. `mypy` needs the package name to be able to do full import\n    checking.\n    \"\"\"\nextra_paths: list[str] = _dataclasses.field(default_factory=lambda: [])\n\"\"\"List of extra paths to be analyzed by the sessions.\n    These are not inspected for packages, as they are passed verbatim to the\n    tools invoked by the sessions.\n    \"\"\"\ndef __post_init__(self) -&gt; None:\n\"\"\"Initialize the configuration object.\n        This will add extra paths discovered in config files and other sources.\n        \"\"\"\nfor path in _util.discover_paths():\nif path not in self.extra_paths and path not in self.source_paths:\nself.extra_paths.append(path)\ndef copy(self, /) -&gt; Self:\n\"\"\"Create a new object as a copy of self.\n        Returns:\n            The copy of self.\n        \"\"\"\nreturn _dataclasses.replace(\nself,\nopts=self.opts.copy(),\nsessions=self.sessions.copy(),\nsource_paths=self.source_paths.copy(),\nextra_paths=self.extra_paths.copy(),\n)\ndef path_args(\nself,\nsession: _nox.Session,\n/,\n*,\ninclude_sources: bool = True,\ninclude_extra: bool = True,\n) -&gt; list[str]:\n\"\"\"Return the file paths to run the checks on.\n        If positional arguments are present in the nox session, those are used\n        as the file paths verbatim, and if not, all **existing** `source_paths`\n        and `extra_paths` are used.\n        Args:\n            session: The nox session to use to look for command-line arguments.\n            include_sources: Whether to include the source paths or not.\n            include_extra: Whether to include the extra paths or not.\n        Returns:\n            The file paths to run the checks on.\n        \"\"\"\nif session.posargs:\nreturn session.posargs\npaths: list[str] = []\nif include_sources:\npaths.extend(self.source_paths)\nif include_extra:\npaths.extend(self.extra_paths)\nreturn list(str(p) for p in _util.existing_paths(paths))\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.Config-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.Config.extra_paths","title":"extra_paths  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>extra_paths: list[str] = field(default_factory=lambda : [])\n</code></pre> <p>List of extra paths to be analyzed by the sessions.</p> <p>These are not inspected for packages, as they are passed verbatim to the tools invoked by the sessions.</p>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.Config.opts","title":"opts  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>opts: CommandsOptions = field(\ndefault_factory=CommandsOptions\n)\n</code></pre> <p>Command-line options for each command used by sessions.</p>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.Config.sessions","title":"sessions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sessions: list[str] = field(default_factory=lambda : [])\n</code></pre> <p>List of sessions to run.</p>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.Config.source_paths","title":"source_paths  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>source_paths: list[str] = field(default_factory=lambda: [])\n</code></pre> <p>List of paths containing source files that should be analyzed by the sessions.</p> <p>Source paths are inspected for <code>__init__.py</code> files to look for packages. The path should be the top-level directory containing packages that will be actually part of the distribution, not development paths, like tests, benchmarks, etc.</p> <p>This path will be removed when calculating the package name for the found packages. <code>mypy</code> needs the package name to be able to do full import checking.</p>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.Config-functions","title":"Functions","text":""},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.Config.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__() -&gt; None\n</code></pre> <p>Initialize the configuration object.</p> <p>This will add extra paths discovered in config files and other sources.</p> Source code in <code>frequenz/repo/config/nox/config.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Initialize the configuration object.\n    This will add extra paths discovered in config files and other sources.\n    \"\"\"\nfor path in _util.discover_paths():\nif path not in self.extra_paths and path not in self.source_paths:\nself.extra_paths.append(path)\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.Config.copy","title":"copy","text":"<pre><code>copy() -&gt; Self\n</code></pre> <p>Create a new object as a copy of self.</p> RETURNS DESCRIPTION <code>Self</code> <p>The copy of self.</p> Source code in <code>frequenz/repo/config/nox/config.py</code> <pre><code>def copy(self, /) -&gt; Self:\n\"\"\"Create a new object as a copy of self.\n    Returns:\n        The copy of self.\n    \"\"\"\nreturn _dataclasses.replace(\nself,\nopts=self.opts.copy(),\nsessions=self.sessions.copy(),\nsource_paths=self.source_paths.copy(),\nextra_paths=self.extra_paths.copy(),\n)\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.Config.path_args","title":"path_args","text":"<pre><code>path_args(\nsession: Session,\n/,\n*,\ninclude_sources: bool = True,\ninclude_extra: bool = True,\n) -&gt; list[str]\n</code></pre> <p>Return the file paths to run the checks on.</p> <p>If positional arguments are present in the nox session, those are used as the file paths verbatim, and if not, all existing <code>source_paths</code> and <code>extra_paths</code> are used.</p> PARAMETER  DESCRIPTION <code>session</code> <p>The nox session to use to look for command-line arguments.</p> <p> TYPE: <code>Session</code> </p> <code>include_sources</code> <p>Whether to include the source paths or not.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>include_extra</code> <p>Whether to include the extra paths or not.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>The file paths to run the checks on.</p> Source code in <code>frequenz/repo/config/nox/config.py</code> <pre><code>def path_args(\nself,\nsession: _nox.Session,\n/,\n*,\ninclude_sources: bool = True,\ninclude_extra: bool = True,\n) -&gt; list[str]:\n\"\"\"Return the file paths to run the checks on.\n    If positional arguments are present in the nox session, those are used\n    as the file paths verbatim, and if not, all **existing** `source_paths`\n    and `extra_paths` are used.\n    Args:\n        session: The nox session to use to look for command-line arguments.\n        include_sources: Whether to include the source paths or not.\n        include_extra: Whether to include the extra paths or not.\n    Returns:\n        The file paths to run the checks on.\n    \"\"\"\nif session.posargs:\nreturn session.posargs\npaths: list[str] = []\nif include_sources:\npaths.extend(self.source_paths)\nif include_extra:\npaths.extend(self.extra_paths)\nreturn list(str(p) for p in _util.existing_paths(paths))\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config-functions","title":"Functions","text":""},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.configure","title":"frequenz.repo.config.nox.config.configure","text":"<pre><code>configure(\nconf: Config | RepositoryType,\n/,\n*,\nimport_default_sessions: bool = True,\n) -&gt; None\n</code></pre> <p>Configure nox using the provided configuration or repository type.</p> PARAMETER  DESCRIPTION <code>conf</code> <p>The configuration to use to configure nox, or the repository type to use to configure nox.  The later will use the default configuration in <code>frequenz.repo.config.nox.default</code> for that type of repository.</p> <p> TYPE: <code>Config | RepositoryType</code> </p> <code>import_default_sessions</code> <p>Whether to import the default sessions or not. This is only necessary if you want to avoid using the default provided sessions and use your own.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>frequenz/repo/config/nox/config.py</code> <pre><code>def configure(\nconf: Config | RepositoryType, /, *, import_default_sessions: bool = True\n) -&gt; None:\n\"\"\"Configure nox using the provided configuration or repository type.\n    Args:\n        conf: The configuration to use to configure nox, or the repository type to use\n            to configure nox.  The later will use the default configuration in\n            [`frequenz.repo.config.nox.default`][] for that type of repository.\n        import_default_sessions: Whether to import the default sessions or not.\n            This is only necessary if you want to avoid using the default provided\n            sessions and use your own.\n    \"\"\"\nglobal _config  # pylint: disable=global-statement\n# We need to make sure sessions are imported, otherwise they won't be visible to nox.\nif import_default_sessions:\n# pylint: disable=import-outside-toplevel,cyclic-import\nfrom . import session as _  # noqa: F401\nmatch conf:\ncase Config():\n_config = conf\ncase RepositoryType() as repo_type:\n# pylint: disable=import-outside-toplevel,cyclic-import\nfrom . import default\nmatch repo_type:\ncase RepositoryType.ACTOR:\n_config = default.actor_config\ncase RepositoryType.API:\n_config = default.api_config\ncase RepositoryType.APP:\n_config = default.app_config\ncase RepositoryType.LIB:\n_config = default.lib_config\ncase RepositoryType.MODEL:\n_config = default.model_config\ncase _ as unhandled:\nassert_never(unhandled)\n_nox.options.sessions = _config.sessions\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.get","title":"frequenz.repo.config.nox.config.get","text":"<pre><code>get() -&gt; Config\n</code></pre> <p>Get the global configuration object.</p> <p>This will assert if <code>configure()</code> wasn't called before.</p> RETURNS DESCRIPTION <code>Config</code> <p>The global configuration object.</p> Source code in <code>frequenz/repo/config/nox/config.py</code> <pre><code>def get() -&gt; Config:\n\"\"\"Get the global configuration object.\n    This will assert if `configure()` wasn't called before.\n    Returns:\n        The global configuration object.\n    \"\"\"\nassert _config is not None, \"You must call configure() before using this function\"\nreturn _config\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/default/","title":"default","text":""},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default","title":"frequenz.repo.config.nox.default","text":"<p>Default nox configuration for different types of repositories.</p> <p>This module provides the default configuration for the different types of repositories defined by <code>frequenz.repo.config.RepositoryType</code>.</p> <p>The <code>actor_config</code>, <code>api_config</code>, <code>app_config</code>, <code>lib_config</code>, and <code>model_config</code> variables are the default configurations for libraries, APIs, actors and applications, respectively. The <code>common_config</code> variable is the default configuration for all types of repositories.</p> <p>The <code>actor_command_options</code>, <code>api_command_options</code>, <code>app_command_options</code>, <code>lib_command_options</code>, and <code>model_command_options</code> variables are the default command-line options for the same types of repositories, and the <code>common_command_options</code> variable is the default command-line options for all types of repositories.</p> <p>They can be modified before being passed to <code>nox.configure()</code> by using the <code>CommandsOptions.copy()</code> method.</p>"},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default.actor_command_options","title":"frequenz.repo.config.nox.default.actor_command_options  <code>module-attribute</code>","text":"<pre><code>actor_command_options: CommandsOptions = copy()\n</code></pre> <p>Default command-line options for actors.</p>"},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default.actor_config","title":"frequenz.repo.config.nox.default.actor_config  <code>module-attribute</code>","text":"<pre><code>actor_config: Config = copy()\n</code></pre> <p>Default configuration for actors.</p>"},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default.api_command_options","title":"frequenz.repo.config.nox.default.api_command_options  <code>module-attribute</code>","text":"<pre><code>api_command_options: CommandsOptions = copy()\n</code></pre> <p>Default command-line options for APIs.</p>"},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default.api_config","title":"frequenz.repo.config.nox.default.api_config  <code>module-attribute</code>","text":"<pre><code>api_config: Config = copy()\n</code></pre> <p>Default configuration for APIs.</p> <p>Same as <code>common_config</code>, but with an empty <code>source_paths</code> (as the sources are automatically generated, we don't want to test anything in there).</p>"},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default.app_command_options","title":"frequenz.repo.config.nox.default.app_command_options  <code>module-attribute</code>","text":"<pre><code>app_command_options: CommandsOptions = copy()\n</code></pre> <p>Default command-line options for applications.</p>"},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default.app_config","title":"frequenz.repo.config.nox.default.app_config  <code>module-attribute</code>","text":"<pre><code>app_config: Config = copy()\n</code></pre> <p>Default configuration for applications.</p>"},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default.common_command_options","title":"frequenz.repo.config.nox.default.common_command_options  <code>module-attribute</code>","text":"<pre><code>common_command_options: CommandsOptions = CommandsOptions(\nblack=[\"--check\"],\nflake8=[],\nisort=[\"--diff\", \"--check\"],\nmypy=[],\npytest=[\"-W=all\", \"-vv\"],\n)\n</code></pre> <p>Default command-line options for all types of repositories.</p>"},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default.common_config","title":"frequenz.repo.config.nox.default.common_config  <code>module-attribute</code>","text":"<pre><code>common_config = Config(\nopts=copy(),\nsessions=[\n\"formatting\",\n\"flake8\",\n\"mypy\",\n\"pylint\",\n\"pytest_min\",\n\"pytest_max\",\n],\nsource_paths=[\"src\"],\nextra_paths=[\n\"benchmarks\",\n\"docs\",\n\"examples\",\n\"noxfile.py\",\n\"tests\",\n],\n)\n</code></pre> <p>Default configuration for all types of repositories.</p>"},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default.lib_command_options","title":"frequenz.repo.config.nox.default.lib_command_options  <code>module-attribute</code>","text":"<pre><code>lib_command_options: CommandsOptions = copy()\n</code></pre> <p>Default command-line options for libraries.</p>"},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default.lib_config","title":"frequenz.repo.config.nox.default.lib_config  <code>module-attribute</code>","text":"<pre><code>lib_config: Config = copy()\n</code></pre> <p>Default configuration for libraries.</p>"},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default.model_command_options","title":"frequenz.repo.config.nox.default.model_command_options  <code>module-attribute</code>","text":"<pre><code>model_command_options: CommandsOptions = copy()\n</code></pre> <p>Default command-line options for models.</p>"},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default.model_config","title":"frequenz.repo.config.nox.default.model_config  <code>module-attribute</code>","text":"<pre><code>model_config: Config = copy()\n</code></pre> <p>Default configuration for models.</p>"},{"location":"reference/frequenz/repo/config/nox/session/","title":"session","text":""},{"location":"reference/frequenz/repo/config/nox/session/#frequenz.repo.config.nox.session","title":"frequenz.repo.config.nox.session","text":"<p>Predefined nox sessions.</p> <p>This module defines the predefined nox sessions that are used by the default.</p>"},{"location":"reference/frequenz/repo/config/nox/session/#frequenz.repo.config.nox.session-functions","title":"Functions","text":""},{"location":"reference/frequenz/repo/config/nox/session/#frequenz.repo.config.nox.session.ci_checks_max","title":"frequenz.repo.config.nox.session.ci_checks_max","text":"<pre><code>ci_checks_max(session: Session) -&gt; None\n</code></pre> <p>Run all checks with max dependencies in a single session.</p> <p>This is faster than running the checks separately, so it is suitable for CI.</p> <p>This does NOT run pytest_min, so that needs to be run separately as well.</p> PARAMETER  DESCRIPTION <code>session</code> <p>the nox session.</p> <p> TYPE: <code>Session</code> </p> Source code in <code>frequenz/repo/config/nox/session.py</code> <pre><code>@nox.session\ndef ci_checks_max(session: nox.Session) -&gt; None:\n\"\"\"Run all checks with max dependencies in a single session.\n    This is faster than running the checks separately, so it is suitable for CI.\n    This does NOT run pytest_min, so that needs to be run separately as well.\n    Args:\n        session: the nox session.\n    \"\"\"\nsession.install(\"-e\", \".[dev]\")\nformatting(session, False)\nflake8(session, False)\nmypy(session, False)\npylint(session, False)\npytest_max(session, False)\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/session/#frequenz.repo.config.nox.session.flake8","title":"frequenz.repo.config.nox.session.flake8","text":"<pre><code>flake8(session: Session, install_deps: bool = True) -&gt; None\n</code></pre> <p>Check for common errors and in particular documentation format and style.</p> PARAMETER  DESCRIPTION <code>session</code> <p>the nox session.</p> <p> TYPE: <code>Session</code> </p> <code>install_deps</code> <p>True if dependencies should be installed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>frequenz/repo/config/nox/session.py</code> <pre><code>@nox.session\ndef flake8(session: nox.Session, install_deps: bool = True) -&gt; None:\n\"\"\"Check for common errors and in particular documentation format and style.\n    Args:\n        session: the nox session.\n        install_deps: True if dependencies should be installed.\n    \"\"\"\nif install_deps:\nsession.install(\"-e\", \".[dev-flake8]\")\nconf = _config.get()\nsession.run(\"flake8\", *conf.opts.flake8, *conf.path_args(session))\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/session/#frequenz.repo.config.nox.session.formatting","title":"frequenz.repo.config.nox.session.formatting","text":"<pre><code>formatting(\nsession: Session, install_deps: bool = True\n) -&gt; None\n</code></pre> <p>Check code formatting with black and isort.</p> PARAMETER  DESCRIPTION <code>session</code> <p>the nox session.</p> <p> TYPE: <code>Session</code> </p> <code>install_deps</code> <p>True if dependencies should be installed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>frequenz/repo/config/nox/session.py</code> <pre><code>@nox.session\ndef formatting(session: nox.Session, install_deps: bool = True) -&gt; None:\n\"\"\"Check code formatting with black and isort.\n    Args:\n        session: the nox session.\n        install_deps: True if dependencies should be installed.\n    \"\"\"\nif install_deps:\nsession.install(\"-e\", \".[dev-formatting]\")\nconf = _config.get()\nsession.run(\"black\", *conf.opts.black, *conf.path_args(session))\nsession.run(\"isort\", *conf.opts.isort, *conf.path_args(session))\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/session/#frequenz.repo.config.nox.session.mypy","title":"frequenz.repo.config.nox.session.mypy","text":"<pre><code>mypy(session: Session, install_deps: bool = True) -&gt; None\n</code></pre> <p>Check type hints with mypy.</p> PARAMETER  DESCRIPTION <code>session</code> <p>the nox session.</p> <p> TYPE: <code>Session</code> </p> <code>install_deps</code> <p>True if dependencies should be installed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>frequenz/repo/config/nox/session.py</code> <pre><code>@nox.session\ndef mypy(session: nox.Session, install_deps: bool = True) -&gt; None:\n\"\"\"Check type hints with mypy.\n    Args:\n        session: the nox session.\n        install_deps: True if dependencies should be installed.\n    \"\"\"\nif install_deps:\n# install the package itself as editable, so that it is possible to do\n# fast local tests with `nox -R -e mypy`.\nsession.install(\"-e\", \".[dev-mypy]\")\nconf = _config.get()\n# If we get CLI options, we run mypy on those, but still passing the\n# configured options (they can be overridden by the CLI options).\nif session.posargs:\nsession.run(\"mypy\", *conf.opts.mypy, *session.posargs)\nreturn\n# We separate running the mypy checks into two runs, one is the default, as\n# configured in `pyproject.toml`, which should run against the sources.\nsession.run(\"mypy\", *conf.opts.mypy)\n# The second run checks development files, like tests, benchmarks, etc.\n# This is an attempt to minimize mypy internal errors.\nsession.run(\n\"mypy\", *conf.opts.mypy, *conf.path_args(session, include_sources=False)\n)\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/session/#frequenz.repo.config.nox.session.pylint","title":"frequenz.repo.config.nox.session.pylint","text":"<pre><code>pylint(session: Session, install_deps: bool = True) -&gt; None\n</code></pre> <p>Check for code smells with pylint.</p> PARAMETER  DESCRIPTION <code>session</code> <p>the nox session.</p> <p> TYPE: <code>Session</code> </p> <code>install_deps</code> <p>True if dependencies should be installed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>frequenz/repo/config/nox/session.py</code> <pre><code>@nox.session\ndef pylint(session: nox.Session, install_deps: bool = True) -&gt; None:\n\"\"\"Check for code smells with pylint.\n    Args:\n        session: the nox session.\n        install_deps: True if dependencies should be installed.\n    \"\"\"\nif install_deps:\n# install the package itself as editable, so that it is possible to do\n# fast local tests with `nox -R -e pylint`.\nsession.install(\"-e\", \".[dev-pylint]\")\nconf = _config.get()\nsession.run(\"pylint\", *conf.opts.pylint, *conf.path_args(session))\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/session/#frequenz.repo.config.nox.session.pytest_max","title":"frequenz.repo.config.nox.session.pytest_max","text":"<pre><code>pytest_max(\nsession: Session, install_deps: bool = True\n) -&gt; None\n</code></pre> <p>Test the code against max dependency versions with pytest.</p> PARAMETER  DESCRIPTION <code>session</code> <p>the nox session.</p> <p> TYPE: <code>Session</code> </p> <code>install_deps</code> <p>True if dependencies should be installed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>frequenz/repo/config/nox/session.py</code> <pre><code>@nox.session\ndef pytest_max(session: nox.Session, install_deps: bool = True) -&gt; None:\n\"\"\"Test the code against max dependency versions with pytest.\n    Args:\n        session: the nox session.\n        install_deps: True if dependencies should be installed.\n    \"\"\"\nif install_deps:\n# install the package itself as editable, so that it is possible to do\n# fast local tests with `nox -R -e pytest_max`.\nsession.install(\"-e\", \".[dev-pytest]\")\n_pytest_impl(session, \"max\")\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/session/#frequenz.repo.config.nox.session.pytest_min","title":"frequenz.repo.config.nox.session.pytest_min","text":"<pre><code>pytest_min(\nsession: Session, install_deps: bool = True\n) -&gt; None\n</code></pre> <p>Test the code against min dependency versions with pytest.</p> PARAMETER  DESCRIPTION <code>session</code> <p>the nox session.</p> <p> TYPE: <code>Session</code> </p> <code>install_deps</code> <p>True if dependencies should be installed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>frequenz/repo/config/nox/session.py</code> <pre><code>@nox.session\ndef pytest_min(session: nox.Session, install_deps: bool = True) -&gt; None:\n\"\"\"Test the code against min dependency versions with pytest.\n    Args:\n        session: the nox session.\n        install_deps: True if dependencies should be installed.\n    \"\"\"\nif install_deps:\n# install the package itself as editable, so that it is possible to do\n# fast local tests with `nox -R -e pytest_min`.\nsession.install(\"-e\", \".[dev-pytest]\", *_util.min_dependencies())\n_pytest_impl(session, \"min\")\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/util/","title":"util","text":""},{"location":"reference/frequenz/repo/config/nox/util/#frequenz.repo.config.nox.util","title":"frequenz.repo.config.nox.util","text":"<p>General purpose utilities.</p> <p>This module contains general purpose utilities that are used by the other modules in this package.</p>"},{"location":"reference/frequenz/repo/config/nox/util/#frequenz.repo.config.nox.util-functions","title":"Functions","text":""},{"location":"reference/frequenz/repo/config/nox/util/#frequenz.repo.config.nox.util.deduplicate","title":"frequenz.repo.config.nox.util.deduplicate","text":"<pre><code>deduplicate(iterable: Iterable[_T]) -&gt; Iterable[_T]\n</code></pre> <p>Filter out duplicates from an iterable preserving the original iterable order.</p> PARAMETER  DESCRIPTION <code>iterable</code> <p>The iterable to remove duplicates from.</p> <p> TYPE: <code>Iterable[_T]</code> </p> RETURNS DESCRIPTION <code>Iterable[_T]</code> <p>The elements of <code>iterable</code>, without duplicates but preserving order.</p> Source code in <code>frequenz/repo/config/nox/util.py</code> <pre><code>def deduplicate(iterable: Iterable[_T], /) -&gt; Iterable[_T]:\n\"\"\"Filter out duplicates from an iterable preserving the original iterable order.\n    Args:\n        iterable: The iterable to remove duplicates from.\n    Returns:\n        The elements of `iterable`, without duplicates but preserving order.\n    \"\"\"\n# We can't use a set() here because sets don't preserve order.  We use this hack\n# with dict.fromkeys() because dicts do preserve order in Python 3.7+.\nreturn dict.fromkeys(iterable).keys()\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/util/#frequenz.repo.config.nox.util.discover_paths","title":"frequenz.repo.config.nox.util.discover_paths","text":"<pre><code>discover_paths() -&gt; list[str]\n</code></pre> <p>Discover paths to check.</p> <p>Discover the paths to check by looking into different sources, like the <code>pyproject.toml</code> file.</p> <p>Currently the following paths are discovered:</p> <ul> <li>The <code>testpaths</code> option in the <code>tools.pytest.ini_options</code> section of   <code>pyproject.toml</code>.</li> </ul> RETURNS DESCRIPTION <code>list[str]</code> <p>The discovered paths to check.</p> Source code in <code>frequenz/repo/config/nox/util.py</code> <pre><code>def discover_paths() -&gt; list[str]:\n\"\"\"Discover paths to check.\n    Discover the paths to check by looking into different sources, like the\n    `pyproject.toml` file.\n    Currently the following paths are discovered:\n    - The `testpaths` option in the `tools.pytest.ini_options` section of\n      `pyproject.toml`.\n    Returns:\n        The discovered paths to check.\n    \"\"\"\nwith open(\"pyproject.toml\", \"rb\") as toml_file:\ndata = _tomllib.load(toml_file)\ntestpaths: list[str] = (\ndata.get(\"tool\", {})\n.get(\"pytest\", {})\n.get(\"ini_options\", {})\n.get(\"testpaths\", [])\n)\nreturn list(deduplicate(testpaths))\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/util/#frequenz.repo.config.nox.util.existing_paths","title":"frequenz.repo.config.nox.util.existing_paths","text":"<pre><code>existing_paths(paths: Iterable[str]) -&gt; Iterable[Path]\n</code></pre> <p>Filter paths to only leave valid paths that exist and are unique.</p> PARAMETER  DESCRIPTION <code>paths</code> <p>The paths to check and filter.</p> <p> TYPE: <code>Iterable[str]</code> </p> RETURNS DESCRIPTION <code>Iterable[Path]</code> <p>An iterable with the valid paths as <code>pathlib.Path</code> objects.</p> Example <p>assert list(existing_paths([\".\", \"/fake\"])) == [pathlib.Path(\".\")]</p> Source code in <code>frequenz/repo/config/nox/util.py</code> <pre><code>def existing_paths(paths: Iterable[str], /) -&gt; Iterable[_pathlib.Path]:\n\"\"\"Filter paths to only leave valid paths that exist and are unique.\n    Args:\n        paths: The paths to check and filter.\n    Returns:\n        An iterable with the valid paths as `pathlib.Path` objects.\n    Example:\n        &gt;&gt;&gt; assert list(existing_paths([\".\", \"/fake\"])) == [pathlib.Path(\".\")]\n    \"\"\"\nreturn deduplicate(p for p in map(_pathlib.Path, paths) if p.exists())\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/util/#frequenz.repo.config.nox.util.find_toplevel_package_dirs","title":"frequenz.repo.config.nox.util.find_toplevel_package_dirs","text":"<pre><code>find_toplevel_package_dirs(\npath: Path, /, *, root: Path | None = None\n) -&gt; Iterable[Path]\n</code></pre> <p>Find top-level packages directories in a <code>path</code>.</p> <p>Searches recursively for the top-level packages in <code>path</code>, relative to <code>root</code>.</p> PARAMETER  DESCRIPTION <code>path</code> <p>The path to look for python packages.</p> <p> TYPE: <code>Path</code> </p> <code>root</code> <p>The part of the path that is considered the root and will be removed from the resulting path. If <code>None</code> then <code>path</code> is used as <code>root</code>.</p> <p> TYPE: <code>Path | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Iterable[Path]</code> <p>The top-level paths that contains a <code>__init__.py</code> file, with <code>root</code></p> <code>Iterable[Path]</code> <p>removed.</p> <p>Examples:</p> <p>If we have a directory like the following:</p> <pre><code>.\n\u251c\u2500\u2500 noxfile.py\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 frequenz\n        \u2514\u2500\u2500 repo\n            \u2514\u2500\u2500 config\n                \u251c\u2500\u2500 __init__.py\n                \u251c\u2500\u2500 nox\n                \u2502\u00a0\u00a0 \u251c\u2500\u2500 config.py\n                \u2502\u00a0\u00a0 \u251c\u2500\u2500 default.py\n                \u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n                \u2502\u00a0\u00a0 \u251c\u2500\u2500 session.py\n                \u2502\u00a0\u00a0 \u2514\u2500\u2500 util.py\n                \u2514\u2500\u2500 setuptools.py\n</code></pre> <p>Then calling <code>find_toplevel_package_dirs(pathlib.Path(\"src\"))</code> will return an iterator producing: <code>[\"frequenz/repo/config\"]</code>.</p> Source code in <code>frequenz/repo/config/nox/util.py</code> <pre><code>def find_toplevel_package_dirs(\npath: _pathlib.Path, /, *, root: _pathlib.Path | None = None\n) -&gt; Iterable[_pathlib.Path]:\n\"\"\"Find top-level packages directories in a `path`.\n    Searches recursively for the top-level packages in `path`, relative to\n    `root`.\n    Args:\n        path: The path to look for python packages.\n        root: The part of the path that is considered the root and will be\n            removed from the resulting path. If `None` then `path` is used as\n            `root`.\n    Returns:\n        The top-level paths that contains a `__init__.py` file, with `root`\n        removed.\n    Examples:\n        If we have a directory like the following:\n        ```\n        .\n        \u251c\u2500\u2500 noxfile.py\n        \u2514\u2500\u2500 src\n            \u2514\u2500\u2500 frequenz\n                \u2514\u2500\u2500 repo\n                    \u2514\u2500\u2500 config\n                        \u251c\u2500\u2500 __init__.py\n                        \u251c\u2500\u2500 nox\n                        \u2502\u00a0\u00a0 \u251c\u2500\u2500 config.py\n                        \u2502\u00a0\u00a0 \u251c\u2500\u2500 default.py\n                        \u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n                        \u2502\u00a0\u00a0 \u251c\u2500\u2500 session.py\n                        \u2502\u00a0\u00a0 \u2514\u2500\u2500 util.py\n                        \u2514\u2500\u2500 setuptools.py\n        ```\n        Then calling `find_toplevel_package_dirs(pathlib.Path(\"src\"))` will\n        return an iterator producing: `[\"frequenz/repo/config\"]`.\n    \"\"\"\nif root is None:\nroot = path\n# Bail out early if it is a directory with a __init__.py to avoid getting\n# sub-packages\nif (path / \"__init__.py\").exists():\nreturn [path.relative_to(root)]\nif path.is_dir():\nreturn flatten(\n[find_toplevel_package_dirs(p, root=root) for p in path.iterdir()]\n)\nreturn ()\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/util/#frequenz.repo.config.nox.util.flatten","title":"frequenz.repo.config.nox.util.flatten","text":"<pre><code>flatten(iterables: Iterable[Iterable[_T\"&gt;_T]]) -&gt; Iterable[_T]\n</code></pre> <p>Flatten an iterable of iterables into one iterable with all the elements.</p> PARAMETER  DESCRIPTION <code>iterables</code> <p>The iterables to flatten.</p> <p> TYPE: <code>Iterable[Iterable[_T]]</code> </p> RETURNS DESCRIPTION <code>Iterable[_T]</code> <p>The flattened iterable.</p> Example <p>assert list(flatten([(1, 2), (3, 4)]) == [1, 2, 3, 4]</p> Source code in <code>frequenz/repo/config/nox/util.py</code> <pre><code>def flatten(iterables: Iterable[Iterable[_T]], /) -&gt; Iterable[_T]:\n\"\"\"Flatten an iterable of iterables into one iterable with all the elements.\n    Args:\n        iterables: The iterables to flatten.\n    Returns:\n        The flattened iterable.\n    Example:\n        &gt;&gt;&gt; assert list(flatten([(1, 2), (3, 4)]) == [1, 2, 3, 4]\n    \"\"\"\nreturn (item for sublist in iterables for item in sublist)\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/util/#frequenz.repo.config.nox.util.is_python_file","title":"frequenz.repo.config.nox.util.is_python_file","text":"<pre><code>is_python_file(path: Path) -&gt; bool\n</code></pre> <p>Check if a path is a Python file.</p> PARAMETER  DESCRIPTION <code>path</code> <p>The path to check.</p> <p> TYPE: <code>Path</code> </p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the path is a Python file, <code>False</code> otherwise.</p> Source code in <code>frequenz/repo/config/nox/util.py</code> <pre><code>def is_python_file(path: _pathlib.Path, /) -&gt; bool:\n\"\"\"Check if a path is a Python file.\n    Args:\n        path: The path to check.\n    Returns:\n        `True` if the path is a Python file, `False` otherwise.\n    \"\"\"\nreturn path.suffix in (\".py\", \".pyi\")\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/util/#frequenz.repo.config.nox.util.min_dependencies","title":"frequenz.repo.config.nox.util.min_dependencies","text":"<pre><code>min_dependencies() -&gt; list[str]\n</code></pre> <p>Extract the minimum dependencies from pyproject.toml.</p> RETURNS DESCRIPTION <code>list[str]</code> <p>The minimun dependencies defined in pyproject.toml.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If minimun dependencies are not properly set in pyproject.toml.</p> Source code in <code>frequenz/repo/config/nox/util.py</code> <pre><code>def min_dependencies() -&gt; list[str]:\n\"\"\"Extract the minimum dependencies from pyproject.toml.\n    Returns:\n        The minimun dependencies defined in pyproject.toml.\n    Raises:\n        RuntimeError: If minimun dependencies are not properly set in pyproject.toml.\n    \"\"\"\nwith open(\"pyproject.toml\", \"rb\") as toml_file:\ndata = _tomllib.load(toml_file)\nmin_deps: list[str] = []\ndependencies = data.get(\"project\", {}).get(\"dependencies\", {})\nif not dependencies:\nreturn min_deps\nfor dep in dependencies:\nmin_dep = dep.split(\",\")[0]\nif any(op in min_dep for op in (\"&gt;=\", \"==\", \"@\")):\nmin_deps.append(min_dep.replace(\"&gt;=\", \"==\"))\nelse:\nraise RuntimeError(f\"Minimum requirement is not set: {dep}\")\nreturn min_deps\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/util/#frequenz.repo.config.nox.util.path_to_package","title":"frequenz.repo.config.nox.util.path_to_package","text":"<pre><code>path_to_package(\npath: Path, root: Path | None = None\n) -&gt; str\n</code></pre> <p>Convert paths to Python package names.</p> <p>Paths should exist and be either a directory or a file ending with <code>.pyi?</code> (otherwise this function will assert). The <code>root</code> and <code>path</code> are concatenated when performing the check.</p> <p>Directory separators in <code>path</code> are replaced with <code>.</code> and the <code>.pyi?</code> suffix is removed (if present).</p> PARAMETER  DESCRIPTION <code>path</code> <p>The path to convert.</p> <p> TYPE: <code>Path</code> </p> <code>root</code> <p>The root where the path is located. If <code>None</code>, then it is considered present in the current working directory.</p> <p> TYPE: <code>Path | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The package name based on <code>path</code>.</p> <p>Examples:</p> <ul> <li><code>src/frequenz/pkg</code> (<code>root=\"src\"</code>) will be converted to <code>frequenz.pkg</code>.</li> <li><code>noxfile.py</code> (without <code>root</code>) will be converted to <code>noxfile</code>.</li> </ul> Source code in <code>frequenz/repo/config/nox/util.py</code> <pre><code>def path_to_package(path: _pathlib.Path, root: _pathlib.Path | None = None) -&gt; str:\n\"\"\"Convert paths to Python package names.\n    Paths should exist and be either a directory or a file ending with `.pyi?`\n    (otherwise this function will assert). The `root` and `path` are\n    concatenated when performing the check.\n    Directory separators in `path` are replaced with `.` and the `.pyi?` suffix\n    is removed (if present).\n    Args:\n        path: The path to convert.\n        root: The root where the path is located. If `None`, then it is\n            considered present in the current working directory.\n    Returns:\n        The package name based on `path`.\n    Examples:\n        * `src/frequenz/pkg` (`root=\"src\"`) will be converted to `frequenz.pkg`.\n        * `noxfile.py` (without `root`) will be converted to `noxfile`.\n    \"\"\"\nreal_path = path\nif root is not None:\nreal_path = root / path\nassert real_path.is_dir() or is_python_file(real_path)\nif is_python_file(real_path):\npath = path.with_suffix(\"\")\nreturn path.as_posix().replace(\"/\", \".\")\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/util/#frequenz.repo.config.nox.util.replace","title":"frequenz.repo.config.nox.util.replace","text":"<pre><code>replace(\niterable: Iterable[_T\"&gt;_T], replacements: Mapping[_T\"&gt;_T, _T]\n) -&gt; Iterable[_T]\n</code></pre> <p>Replace elements in an iterable.</p> PARAMETER  DESCRIPTION <code>iterable</code> <p>The iterable to replace elements in.</p> <p> TYPE: <code>Iterable[_T]</code> </p> <code>replacements</code> <p>A mapping of elements to replace with other elements.</p> <p> TYPE: <code>Mapping[_T, _T]</code> </p> YIELDS DESCRIPTION <code>Iterable[_T]</code> <p>The next element in the iterable, with the replacements applied.</p> Example <p>assert list(replace([1, 2, 3], {1: 4, 2: 5})) == [4, 5, 3]</p> Source code in <code>frequenz/repo/config/nox/util.py</code> <pre><code>def replace(iterable: Iterable[_T], replacements: Mapping[_T, _T], /) -&gt; Iterable[_T]:\n\"\"\"Replace elements in an iterable.\n    Args:\n        iterable: The iterable to replace elements in.\n        replacements: A mapping of elements to replace with other elements.\n    Yields:\n        The next element in the iterable, with the replacements applied.\n    Example:\n        &gt;&gt;&gt; assert list(replace([1, 2, 3], {1: 4, 2: 5})) == [4, 5, 3]\n    \"\"\"\nfor item in iterable:\nif item in replacements:\nyield replacements[item]\nelse:\nyield item\n</code></pre>"},{"location":"reference/frequenz/repo/config/pytest/","title":"Index","text":""},{"location":"reference/frequenz/repo/config/pytest/#frequenz.repo.config.pytest","title":"frequenz.repo.config.pytest","text":"<p>Pytest utilities.</p> <p>This package contains utilities for testing with <code>pytest</code>.</p> <p>The following modules are available:</p> <ul> <li><code>examples</code>: Utilities to enable linting of   code examples in docstrings.</li> </ul>"},{"location":"reference/frequenz/repo/config/pytest/examples/","title":"examples","text":""},{"location":"reference/frequenz/repo/config/pytest/examples/#frequenz.repo.config.pytest.examples","title":"frequenz.repo.config.pytest.examples","text":"<p>Utility to enable linting of code examples in docstrings.</p> <p>Code examples are often wrapped in triple backticks (<code>```python</code>) within our docstrings. This plugin extracts these code examples and validates them using pylint.</p> <p>The main utility function is <code>get_sybil_arguments()</code>, which returns a dictionary that can be used to pass to the <code>Sybil()</code> constructor.</p> <p>You still need to create a <code>conftest.py</code> file in the root of your project's sources, typically <code>src/conftest.py</code>, with the following contents:</p> <pre><code>from frequenz.repo.config.pytest import examples\nfrom sybil import Sybil\npytest_collect_file = Sybil(**examples.get_sybil_arguments()).pytest()\n</code></pre>"},{"location":"reference/frequenz/repo/config/pytest/examples/#frequenz.repo.config.pytest.examples-functions","title":"Functions","text":""},{"location":"reference/frequenz/repo/config/pytest/examples/#frequenz.repo.config.pytest.examples.get_sybil_arguments","title":"frequenz.repo.config.pytest.examples.get_sybil_arguments","text":"<pre><code>get_sybil_arguments() -&gt; dict[str, Any]\n</code></pre> <p>Get the arguments to pass when instantiating the Sybil object to lint docs examples.</p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>The arguments to pass when instantiating the Sybil object.</p> Source code in <code>frequenz/repo/config/pytest/examples.py</code> <pre><code>def get_sybil_arguments() -&gt; dict[str, Any]:\n\"\"\"Get the arguments to pass when instantiating the Sybil object to lint docs examples.\n    Returns:\n        The arguments to pass when instantiating the Sybil object.\n    \"\"\"\nreturn {\n\"parsers\": [_CustomPythonCodeBlockParser()],\n\"patterns\": [\"*.py\"],\n# This is a hack because Sybil seems to have issues with `__init__.py` files.\n# See https://github.com/frequenz-floss/frequenz-repo-config-python/issues/113\n# for details\n\"excludes\": [\"__init__.py\"],\n}\n</code></pre>"},{"location":"reference/frequenz/repo/config/setuptools/","title":"Index","text":""},{"location":"reference/frequenz/repo/config/setuptools/#frequenz.repo.config.setuptools","title":"frequenz.repo.config.setuptools","text":"<p>Setuptools utilities.</p>"},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/","title":"grpc_tools","text":""},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools","title":"frequenz.repo.config.setuptools.grpc_tools","text":"<p>Setuptool hooks to build protobuf files.</p> <p>This module contains a setuptools command that can be used to compile protocol buffer files in a project.</p> <p>It also runs the command as the first sub-command for the build command, so protocol buffer files are compiled automatically before the project is built.</p>"},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools-classes","title":"Classes","text":""},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools.CompileProto","title":"frequenz.repo.config.setuptools.grpc_tools.CompileProto","text":"<p>             Bases: <code>Command</code></p> <p>Build the Python protobuf files.</p> Source code in <code>frequenz/repo/config/setuptools/grpc_tools.py</code> <pre><code>class CompileProto(_setuptools.Command):\n\"\"\"Build the Python protobuf files.\"\"\"\nproto_path: str\n\"\"\"The path of the root directory containing the protobuf files.\"\"\"\nproto_glob: str\n\"\"\"The glob pattern to use to find the protobuf files.\"\"\"\ninclude_paths: str\n\"\"\"Comma-separated list of paths to include when compiling the protobuf files.\"\"\"\npy_path: str\n\"\"\"The path of the root directory where the Python files will be generated.\"\"\"\ndescription: str = \"compile protobuf files\"\n\"\"\"Description of the command.\"\"\"\nuser_options: list[tuple[str, str | None, str]] = [\n(\n\"proto-path=\",\nNone,\n\"path of the root directory containing the protobuf files\",\n),\n(\"proto-glob=\", None, \"glob pattern to use to find the protobuf files\"),\n(\n\"include-paths=\",\nNone,\n\"comma-separated list of paths to include when compiling the protobuf files\",\n),\n(\n\"py-path=\",\nNone,\n\"path of the root directory where the Python files will be generated\",\n),\n]\n\"\"\"Options of the command.\"\"\"\ndef initialize_options(self) -&gt; None:\n\"\"\"Initialize options.\"\"\"\nconfig = _protobuf.ProtobufConfig.from_pyproject_toml()\nself.proto_path = config.proto_path\nself.proto_glob = config.proto_glob\nself.include_paths = \",\".join(config.include_paths)\nself.py_path = config.py_path\ndef finalize_options(self) -&gt; None:\n\"\"\"Finalize options.\"\"\"\ndef run(self) -&gt; None:\n\"\"\"Compile the Python protobuf files.\"\"\"\ninclude_paths = self.include_paths.split(\",\")\nproto_files = [\nstr(p) for p in _pathlib.Path(self.proto_path).rglob(self.proto_glob)\n]\nif not proto_files:\nprint(\nf\"No proto files found in {self.proto_path}/**/{self.proto_glob}/, \"\n\"skipping compilation of proto files.\"\n)\nreturn\nprotoc_cmd = (\n[_sys.executable, \"-m\", \"grpc_tools.protoc\"]\n+ [f\"-I{p}\" for p in [*include_paths, self.proto_path]]\n+ [\nf\"--{opt}={self.py_path}\"\nfor opt in \"python_out grpc_python_out mypy_out mypy_grpc_out\".split()\n]\n+ proto_files\n)\nprint(f\"Compiling proto files via: {' '.join(protoc_cmd)}\")\n_subprocess.run(protoc_cmd, check=True)\n</code></pre>"},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools.CompileProto-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools.CompileProto.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str = 'compile protobuf files'\n</code></pre> <p>Description of the command.</p>"},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools.CompileProto.include_paths","title":"include_paths  <code>instance-attribute</code>","text":"<pre><code>include_paths: str\n</code></pre> <p>Comma-separated list of paths to include when compiling the protobuf files.</p>"},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools.CompileProto.proto_glob","title":"proto_glob  <code>instance-attribute</code>","text":"<pre><code>proto_glob: str\n</code></pre> <p>The glob pattern to use to find the protobuf files.</p>"},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools.CompileProto.proto_path","title":"proto_path  <code>instance-attribute</code>","text":"<pre><code>proto_path: str\n</code></pre> <p>The path of the root directory containing the protobuf files.</p>"},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools.CompileProto.py_path","title":"py_path  <code>instance-attribute</code>","text":"<pre><code>py_path: str\n</code></pre> <p>The path of the root directory where the Python files will be generated.</p>"},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools.CompileProto.user_options","title":"user_options  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>user_options: list[tuple[str, str | None, str]] = [\n(\n\"proto-path=\",\nNone,\n\"path of the root directory containing the protobuf files\",\n),\n(\n\"proto-glob=\",\nNone,\n\"glob pattern to use to find the protobuf files\",\n),\n(\n\"include-paths=\",\nNone,\n\"comma-separated list of paths to include when compiling the protobuf files\",\n),\n(\n\"py-path=\",\nNone,\n\"path of the root directory where the Python files will be generated\",\n),\n]\n</code></pre> <p>Options of the command.</p>"},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools.CompileProto-functions","title":"Functions","text":""},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools.CompileProto.finalize_options","title":"finalize_options","text":"<pre><code>finalize_options() -&gt; None\n</code></pre> <p>Finalize options.</p> Source code in <code>frequenz/repo/config/setuptools/grpc_tools.py</code> <pre><code>def finalize_options(self) -&gt; None:\n\"\"\"Finalize options.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools.CompileProto.initialize_options","title":"initialize_options","text":"<pre><code>initialize_options() -&gt; None\n</code></pre> <p>Initialize options.</p> Source code in <code>frequenz/repo/config/setuptools/grpc_tools.py</code> <pre><code>def initialize_options(self) -&gt; None:\n\"\"\"Initialize options.\"\"\"\nconfig = _protobuf.ProtobufConfig.from_pyproject_toml()\nself.proto_path = config.proto_path\nself.proto_glob = config.proto_glob\nself.include_paths = \",\".join(config.include_paths)\nself.py_path = config.py_path\n</code></pre>"},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools.CompileProto.run","title":"run","text":"<pre><code>run() -&gt; None\n</code></pre> <p>Compile the Python protobuf files.</p> Source code in <code>frequenz/repo/config/setuptools/grpc_tools.py</code> <pre><code>def run(self) -&gt; None:\n\"\"\"Compile the Python protobuf files.\"\"\"\ninclude_paths = self.include_paths.split(\",\")\nproto_files = [\nstr(p) for p in _pathlib.Path(self.proto_path).rglob(self.proto_glob)\n]\nif not proto_files:\nprint(\nf\"No proto files found in {self.proto_path}/**/{self.proto_glob}/, \"\n\"skipping compilation of proto files.\"\n)\nreturn\nprotoc_cmd = (\n[_sys.executable, \"-m\", \"grpc_tools.protoc\"]\n+ [f\"-I{p}\" for p in [*include_paths, self.proto_path]]\n+ [\nf\"--{opt}={self.py_path}\"\nfor opt in \"python_out grpc_python_out mypy_out mypy_grpc_out\".split()\n]\n+ proto_files\n)\nprint(f\"Compiling proto files via: {' '.join(protoc_cmd)}\")\n_subprocess.run(protoc_cmd, check=True)\n</code></pre>"},{"location":"user-guide/","title":"User Guide","text":"<p>This is a highly opinionated set of tools and configurations to set up a Python repository for Frequenz projects.</p> <p>It offers:</p> <ul> <li>Cookiecutter templates for scaffolding new projects.</li> <li>Trivial build of <code>noxfile.py</code> with some predefined sessions that include all   common checks.</li> <li>Tools to build protobuf/grpc files as Python, including type information.</li> </ul>"},{"location":"user-guide/SUMMARY/","title":"SUMMARY","text":"<ul> <li>Introduction</li> <li>Start a new project</li> <li>Migrate an existing project</li> <li>Update an existing project</li> <li>Advanced usage</li> </ul>"},{"location":"user-guide/advanced-usage/","title":"Advanced usage","text":"<p>The Cookiecutter template uses some tools provided as a library by this project.</p> <p>Usually, users don't need to deal with it directly, but if your project needs some extra customization (like disabling <code>nox</code> sessions or adding new ones, or using different CLI options for some tools), then you'll need to.</p> <p>You can find information about the extra features in the API reference.</p>"},{"location":"user-guide/migrate-an-existing-project/","title":"Migrate an existing project","text":"<p>The easiest way to migrate an existing project is to generate a new one based on the current project metadata and then overwrite the existing files.</p> <p>It is recommended to commit all changes before doing this, so you can then use <code>git</code> to look at the changes.</p> <p>If you generate the new repo in a temporary directory, you can easily overwrite the files in your existing project by using <code>rsync</code> or similar tools:</p> <pre><code>cd /tmp\ncookiecutter gh:frequenz-floss/frequenz-repo-config-python \\\n--directory=cookiecutter --checkout v0.9.0\nrsync -vr --exclude=.git/ new-project/ /path/to/existing/project\ncd /path/to/existing/project\ngit diff\n# Fix all the `TODO`s and clean up the generated files\ngit commit -a\n</code></pre> <p>Warning</p> <p>The trailing slash in <code>new-project/</code> and the lack of it in <code>/path/to/existing/project</code> are meaningful to <code>rsync</code>.</p> <p>Also, make sure to exclude the <code>.git/</code> directory to avoid messing up with your local Git repository.</p> <p>Tip</p> <p>Please have a look at the follow-up steps listed in the Start a new project section to finish the setup.</p>"},{"location":"user-guide/update-an-existing-project/","title":"Update an existing project","text":"<p>To update an existing project, you can use the Cookiecutter replay file that was saved during the project generation. The file is saved as <code>.cookiecutter-replay.json</code>. Using this file, you can re-run [Cookiecutter] without having to enter all the inputs again.</p> <p>Warning</p> <ul> <li>Don't forget to commit all changes in your repository before doing this!   Files will be overwritten!</li> <li>Don't forget to check all the release   notes   for all the versions you are going to update, in particular the   Upgrading section, as there might be steps necessary before even   running the <code>cookiecutter</code> command for the update.</li> </ul> <pre><code>git commit -a  # commit all changes\ncd ..\ncookiecutter gh:frequenz-floss/frequenz-repo-config-python \\\n--directory=cookiecutter \\\n--checkout v0.9.0 \\\n--overwrite-if-exists \\\n--replay \\\n--replay-file project-directory/.cookiecutter-replay.json\n</code></pre> <p>This will create a new commit with all the changes to the overwritten files. Bear in mind that all the <code>TODO</code>s will come back, so there will be quite a bit of cleanup to do. You can easily check what was changed using <code>git show</code>, and you can use <code>git commit --amend</code> to amend the previous commit with the template updates, or create a new commit with the fixes. You can also use <code>git citool</code> or <code>git gui</code> to easily add, remove, or even discard (revert) changes in the templates update commit.</p> <p>Note</p> <p>The <code>project-directory</code> is the directory of your previously generated project. If you renamed it, then the files will be generated in a new directory with the original name. You can update the target directory in the replay file.</p> <p>Note</p> <p>Please remember to keep your replay file up to date if you change any metadata in the project.</p> <p>Tip</p> <p>Please have a look at the follow-up steps listed in the Start a new project section to finish the setup.</p>"},{"location":"user-guide/start-a-new-project/","title":"Start a new project","text":""},{"location":"user-guide/start-a-new-project/#install-cookiecutter","title":"Install Cookiecutter","text":"<p>To start a new project, you should first install Cookiecutter. It is normally available in any Linux distribution, but some have a very old version (for example, Ubuntu/Debian). You can check which version your distro has on Repology. You need at least version 2.4.0. To ensure you get an up-to-date version, you can always use <code>pip</code> and install it in a <code>venv</code>:</p> <pre><code>$ python -m venv cookiecutter\n$ cd cookiecutter\n$ . bin/activate\n[cookiecutter] $ pip install cookiecutter\nCollecting cookiecutter\n...\n</code></pre> <p>Then simply run [Cookiecutter] where you want to create the new project:</p>"},{"location":"user-guide/start-a-new-project/#generate-the-project-files","title":"Generate the project files","text":"<pre><code>cookiecutter gh:frequenz-floss/frequenz-repo-config-python \\\n--directory=cookiecutter --checkout v0.9.0\n</code></pre> <p>This command will prompt you for the project type, name, and other configuration options, and it will generate the entire project for you in a new subdirectory.</p> <p>Warning</p> <p>This command needs to be typed literally!</p> <p><code>frequenz-floss/frequenz-repo-config-python</code> is the GitHub repository with the cookiecutter template that will be downloaded, and <code>--directory=cookiecutter</code> is needed because the cookiecutter template doesn't live at the top-level of that repository, but in a subdirectory called <code>cookiecutter</code>. The <code>--checkout</code> option is provided to use a template from a released version, otherwise the default (development) branch will be used.</p> <p>All information about your project will be prompted interactively by that command.</p> <p>After completing the project and fixing the <code>TODO</code>s, you can either amend the previous commit using <code>git commit --amend</code> or create a new commit for the changes using <code>git commit</code>.</p>"},{"location":"user-guide/start-a-new-project/#template-variables-reference","title":"Template variables reference","text":"<ul> <li> <p><code>type</code>: The type of repository. It must be chosen from the list.</p> </li> <li> <p><code>name</code>: The name of the project. This will be used to build defaults for   other inputs, such as <code>title</code>, <code>python_package</code>, etc. It should be one word,   using only alphanumeric characters (and starting with a letter). It can   include also <code>_</code> and <code>-</code> which will be handled differently when building   other variables from it (replaced by spaces in titles for example).</p> </li> <li> <p><code>description</code>: A short description of the project. It will be used as the   description in the <code>README.md</code>, <code>pyproject.toml</code>, <code>mkdocs.yml</code>, etc.</p> </li> <li> <p><code>title</code>: A human-readable name or title for the project. It will be used in   the <code>README.md</code>, <code>CONTRIBUTING.md</code>, and other files to refer to the project,   as well as the site title in <code>mkdocs.yml</code>.</p> </li> <li> <p><code>keywords</code>: A comma-separated list of keywords that will be used in the   <code>pyproject.toml</code> file. If left untouched, it will use only some predefined   keywords. If anything else is entered, it will be added to the default   keywords.</p> </li> <li> <p><code>github_org</code>: The GitHub handle of the organization where the project will   reside. This will be used to generate links to the project on GitHub.</p> </li> <li> <p><code>license</code>: Currently, only two options are provided: <code>MIT</code>, which should be   used for open-source projects, and <code>Proprietary</code>, which should be used for   closed-source projects. This will be added to file headers and used as the   license in <code>pyproject.toml</code>.</p> </li> <li> <p><code>author_name</code>, <code>author_email</code>: The name and email address of the author of   the project. They will be used in the copyright notice in file headers and   as the author in <code>pyproject.toml</code>.</p> </li> <li> <p><code>python_package</code>: The Python package in which this project will reside. All   files provided by this project should be located in this package. This needs   to be a list of valid Python identifiers separated by dots. The source file   structure will be derived from this. For example, <code>frequenz.actor.example</code>   will generate files in <code>src/frequenz/actor/example</code>.</p> </li> <li> <p><code>pypi_package_name</code>: The name of the PyPI/wheel/distribution package. This   should be consistent with the <code>python_package</code>, usually replacing <code>.</code> with   <code>-</code>. For example, <code>frequenz-actor-example</code>.</p> </li> <li> <p><code>github_repo_name</code>: The handle of the GitHub repository where the project   will reside. This will be used to generate links to the project on GitHub and   as the top-level directory name.</p> </li> <li> <p><code>default_codeowners</code>: A space-separated list of GitHub teams (<code>@org/team</code>) or   users (<code>@user</code>) that will be the default code owners for this project. This   will be used to build the <code>CODEOWNERS</code> file. Please refer to the code owners   documentation for more details on the valid syntax.</p> </li> </ul>"},{"location":"user-guide/start-a-new-project/#create-the-local-environment","title":"Create the local environment","text":"<p>To start development, you need to make sure your environment is correctly set up. One way to do this is by using a virtual environment and installing all the dependencies there:</p> <pre><code># requires at least Python version 3.11\npython3 -m venv .venv\n. .venv/bin/activate\npip install -e .[dev]\n</code></pre> <p>This will install your package in editable mode, so you can open a Python interpreter and import your package modules, picking up any local changes without the need to reinstall. Now you can run tools directly, like <code>pytest</code>.</p>"},{"location":"user-guide/start-a-new-project/#verify-using-nox","title":"Verify using <code>nox</code>","text":"<p>If you prefer to keep your virtual environment cleaner and avoid installing development dependencies, you can also use <code>nox</code> to create isolated environments:</p> <pre><code>pip install -e .[dev-noxfile]\nnox --install-only  # Set up virtual environments once\nnox -R  # Run linting and testing reusing the existing virtual environments\n</code></pre> <p>This will only install your package in editable mode and the minimum dependencies required to run <code>nox</code>. It will then run all <code>nox</code> default sessions, which include running linters and tests.</p> <p>Tip</p> <p>It's much faster to use <code>nox</code> with <code>--install-only</code> once (each time you change or update dependencies, you need to run it again) and then use <code>nox -R</code> to run the sessions without recreating the virtual environments.</p> <p>Otherwise, <code>nox</code> will create many virtual environments each time you run it, which is very slow.</p>"},{"location":"user-guide/start-a-new-project/#verify-the-documentation-works","title":"Verify the documentation works","text":"<p>To generate the documentation, you can use <code>mkdocs</code>:</p> <pre><code>pip install .[dev-mkdocs]  # Not necessary if you already installed .[dev]\nmkdocs serve\n</code></pre> <p>If the command fails, look at the log warnings and errors and fix them. If it worked, now there is a local web server serving the documentation. You can point your browser to http://127.0.0.1:8000 to have a look.</p> <p>Info</p> <p>For API projects, <code>docker</code> is needed to generate and serve documentation, as the easiest way to use the tool to generate the documentation from <code>.proto</code> files is using <code>docker</code>.</p>"},{"location":"user-guide/start-a-new-project/#initialize-github-pages","title":"Initialize GitHub Pages","text":"<p>The generated documentation can be easily published via GitHub Pages, and it will be automatically updated for new pushes and releases. However, some initial setup is needed for it to work correctly:</p> <pre><code>pip install -e .[dev-mkdocs]  # Not necessary if you already installed .[dev]\n# Creates the branch gh-pages locally\nmike deploy --update-aliases v0.1-dev v0-dev latest-dev latest\nmike set-default latest  # Makes the latest alias the default version\ngit push upstream gh-pages  # Pushes the new branch upstream to publish the website\n</code></pre> <p>This assumes your branch is called <code>v0.x.x</code> and your first release will be <code>v0.1.0</code>.</p> <p>Then make sure that GitHub Pages is enabled in <code>https://github.com/&lt;repo-owner&gt;/&lt;repo-name&gt;/settings/pages</code>.</p> <p>If all went well, your website should be available soon via <code>https://&lt;repo-owner&gt;.github.io/&lt;repo-name&gt;/</code>.</p>"},{"location":"user-guide/start-a-new-project/#versions-using-mike","title":"Versions using Mike","text":"<p>The above commands create a new documentation version using Mike, which is used to keep multiple versions of the website.</p> <p>The new documentation version is called <code>v0.1-dev</code>, which is used as the name for the currently in-development branch. The <code>v0.1-dev</code> branch has an alias called <code>v0-dev</code> that points to the latest v0.x branch development version, an alias <code>latest-dev</code> that points to the latest in-development version, and a <code>latest</code> alias, which is set as the default.</p> <p>If the website is visited without specifying an explicit version, the <code>latest</code> version will be displayed. It is recommended to point <code>latest</code> to the latest stable version instead of the currently in-devepoment version, so as soon as you make a release, you should update the alias.</p>"},{"location":"user-guide/start-a-new-project/#automatic-generation","title":"Automatic generation","text":"<p>New versions of the documentation will be automatically generated and published via GitHub Actions on any push.</p> <p>If a push is to a branch with semver-like format (vX.Y.Z), then the generated version will replace the current <code>vX.Y-dev</code> version (and <code>vX-dev</code> and <code>latest-dev</code> alias).</p> <p>If a tag is pushed instead, then the generated version will replace the current <code>vX.Y</code> version (if there was any), and the aliases <code>vX</code> and <code>latest</code> will be updated to point to the new version.</p> <p>To summarize, we don't create versions for patch releases, only for minor versions, and we have an alias to point to the latest version of a major version too.</p>"},{"location":"user-guide/start-a-new-project/configure-github/","title":"Configure GitHub","text":"<p>The generated templates make some assumptions about how the GitHub repository is configured. Here is a summary of changes you should do to the repository  to make sure everything works as expected.</p>"},{"location":"user-guide/start-a-new-project/configure-github/#issues","title":"Issues","text":""},{"location":"user-guide/start-a-new-project/configure-github/#labels","title":"Labels","text":"<p>Review the list of labels and add:</p> <ul> <li> <p><code>part:xxx</code> labels that make sense to the project</p> </li> <li> <p>Make sure there is a <code>cmd:skip-release-notes</code> label, and if there isn't,   create one with <code>930F79</code> as color and the following description:</p> <p>It is not necessary to update release notes for this PR</p> </li> <li> <p>All labels used by automation in the project, for example look for labels listed in:</p> <ul> <li><code>.github/keylabeler.yml</code></li> <li><code>.github/labeler.yml</code></li> <li><code>.github/dependabot.yml</code></li> <li><code>.github/workflows/release-notes-check.yml</code></li> </ul> </li> </ul>"},{"location":"user-guide/start-a-new-project/configure-github/#discussions","title":"Discussions","text":"<p>This depends on the repo, but in general we want this:</p> <ul> <li> <p>Remove the Show and tell and Poll categories</p> </li> <li> <p>Rename the Q&amp;A category to Support and change the emoji to :sos:</p> </li> </ul> <p>This one is important to match the link provided in <code>.github/ISSUE_TEMPLATE/config.yml</code>.</p>"},{"location":"user-guide/start-a-new-project/configure-github/#settings","title":"Settings","text":""},{"location":"user-guide/start-a-new-project/configure-github/#general","title":"General","text":""},{"location":"user-guide/start-a-new-project/configure-github/#default-branch","title":"Default branch","text":"<ul> <li>Rename to <code>v0.x.x</code> (this is required for the common CI to work properly when creating releases)</li> </ul>"},{"location":"user-guide/start-a-new-project/configure-github/#features","title":"Features","text":"<ul> <li> Wikis</li> <li> Issues</li> <li> Sponsorships</li> <li> Projects</li> <li> Preserve this repository</li> <li> Discussions</li> </ul>"},{"location":"user-guide/start-a-new-project/configure-github/#pull-requests","title":"Pull Requests","text":"<ul> <li> Allow merge commits: Default to pull request title and description</li> <li> Allow squash merging</li> <li> Allow rebase merging</li> <li> Always suggest updating pull request branches</li> <li> Allow auto-merge</li> <li> Automatically delete head branches</li> </ul>"},{"location":"user-guide/start-a-new-project/configure-github/#archives","title":"Archives","text":"<ul> <li> Include Git LFS objects in archives</li> </ul>"},{"location":"user-guide/start-a-new-project/configure-github/#pushes","title":"Pushes","text":"<ul> <li> Limit how many branches and tags can be updated in a single push: 5</li> </ul>"},{"location":"user-guide/start-a-new-project/configure-github/#collaborators-and-teams","title":"Collaborators and teams","text":"<ul> <li>Give the team owning the repository Role: Admin</li> <li>Give everybody team Role: Triage</li> </ul>"},{"location":"user-guide/start-a-new-project/configure-github/#branches","title":"Branches","text":"<p>After importing code to the repository, add the following Branch protection rules (as always this is a guideline, defaults that should be used unless there is a reason to diverge):</p>"},{"location":"user-guide/start-a-new-project/configure-github/#protect-matching-branches","title":"Protect matching branches","text":"<p>Note</p> <p>This is only to enable the merge queue, all the real protection rules will be added afterwards via rulesets. This is why all other protections are disabled here.</p> <p>Add a rule for the main branch (<code>v0.x.x</code>) without wildcards so merge queues can be enabled:</p> <ul> <li> Require a pull request before merging<ul> <li> Require approvals: 1</li> <li> Dismiss stale pull request approvals when new commits are pushed</li> <li> Require review from Code Owners</li> <li> Restrict who can dismiss pull request reviews</li> <li> Allow specified actors to bypass required pull requests</li> <li> Require approval of the most recent reviewable push</li> </ul> </li> <li> Require status checks to pass before merging<ul> <li> Require branches to be up to date before merging</li> <li>(add all the tests that should pass)</li> </ul> </li> <li> Require conversation resolution before merging</li> <li> Require signed commits</li> <li> Require linear history</li> <li> Require merge queue:<ul> <li>Maximum pull requests to build: 5</li> <li>Minimum pull requests to merge: 2 (this should be the only change   to defaults) or after 5 minutes</li> <li>Maximum pull requests to merge: 5</li> <li> Only merge non-failing pull requests</li> <li>Consider check failed after 60</li> </ul> </li> <li> Require deployments to succeed before merging</li> <li> Lock branch</li> <li> Do not allow bypassing the above settings</li> <li> Restrict who can push to matching branches (this might be disabled   while pushing the initial changes)</li> <li>Rules applied to everyone including administrators<ul> <li> Allow force pushes</li> <li> Allow deletions</li> </ul> </li> </ul>"},{"location":"user-guide/start-a-new-project/configure-github/#rules","title":"Rules","text":""},{"location":"user-guide/start-a-new-project/configure-github/#rulesets","title":"Rulesets","text":"<p>Import the following rulesets:</p> <p>Note</p> <p>You might need to adapt the status checks in the Protect version branches ruleset depending on your repository configuration.</p> <ul> <li>Disable creation of non-release   tags</li> <li>Disable creation of other   branches</li> <li>Disallow removal and force-pushes of   gh-pages</li> <li>Protect released   tags</li> <li>Protect version   branches</li> </ul>"},{"location":"user-guide/start-a-new-project/configure-github/#code-security-and-analysis","title":"Code security and analysis","text":"<ul> <li>Enable Dependabot version updates if relevant</li> </ul>"},{"location":"user-guide/start-a-new-project/configure-github/#code","title":"Code","text":"<p>The basic code configuration should be generate using repo-config.</p>"},{"location":"user-guide/start-a-new-project/configure-github/#github-pages","title":"GitHub Pages","text":"<p>No special configuration is needed for GitHub Pages, but you need to initialize the <code>gh-pages</code> branch. You can read how to do this in the Initialize GitHub Pages section.</p>"},{"location":"user-guide/start-a-new-project/configure-pypi/","title":"Configure PyPI","text":""},{"location":"user-guide/start-a-new-project/configure-pypi/#configure-a-trusted-publisher","title":"Configure a trusted publisher","text":"<p>Before a package can be published to PyPI after a release, a trusted publisher needs to be configured.</p> <p>Note</p> <p>You need a PyPI account to do this. You can register for free.</p> <ol> <li> <p>Log-in to PyPI.</p> </li> <li> <p>Go to the Publishing section    of your account.</p> </li> <li> <p>Scroll down to the section Add a new pending publisher, and fill in the fields.</p> <ul> <li> <p>PyPI Project Name: The name of the package you want to publish.   Usually is the same as the GitHub repository name, removing the <code>-python</code>   suffix if any.</p> </li> <li> <p>Owner: The GitHub username/organization of the owner of the package.   For Frequenz projects this is <code>frequenz-floss</code>.</p> </li> <li> <p>Repository name: The name of the GitHub repository of the package.</p> </li> <li> <p>Workflow name: <code>ci.yaml</code>.</p> </li> <li> <p>Environment name: Leave empty.</p> </li> </ul> </li> <li> <p>Click on <code>Add</code>.</p> </li> <li> <p>Now uploading the new package from GitHub should work.</p> </li> <li> <p>After the new package was uploaded / created.</p> <ol> <li> <p>Invite other maintainers to co-maintain the new package.</p> <ol> <li>Go to your account Projects.</li> <li>Click on Manage for the new package.</li> <li>Click on Collaborators.</li> <li>Scroll down to the section Invite collaborator.</li> <li>Fill in the Username and the appropriate Role for the new    collaborator.</li> <li>Click on Add.</li> <li>Repeat steps to add more collaborators.</li> </ol> </li> </ol> </li> </ol>"}]}