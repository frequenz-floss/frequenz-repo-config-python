{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Frequenz repository configuration for Python","text":""},{"location":"#introduction","title":"Introduction","text":"<p>This is very opinionated set of tools and configurations to setup a Python repository for Frequenz projects.</p> <p>If offers:</p> <ul> <li>Cookiecutter templates for scaffolding new projects</li> <li>Trivial build of <code>noxfile.py</code> with some predefined sessions with all common   checks.</li> <li>Tools to build protobuf/grpc files as Python, including type information.</li> </ul>"},{"location":"#start-a-new-project","title":"Start a new project","text":"<p>To start a new project you should first install Cookiecutter. It is normally available in any Linux distribution, but some have a very old version (for example, Ubuntu/Debian).  You can check which version your distro has in Repology. You need at least version 2.1.0.  To make sure to get an up to date version you can always uses <code>pip</code> and install in a <code>venv</code>:</p> <pre><code>$ python -m venv cookiecutter\n$ cd cookiecutter\n$ . bin/activate\n[cookiecutter] $ pip install cookiecutter\nCollecting cookiecutter\n...\n</code></pre> <p>Then just run cookiecutter where you want to create the new project. A new directory will be created with the generated project name. For example:</p> <pre><code>cd ~/devel\ncookiecutter gh:frequenz-floss/frequenz-repo-config-python --directory=cookiecutter\n</code></pre> <p>This will prompt for the project type, name and other configuration and generate the whole project for you.</p> <p>After completing it and fixing the <code>TODO</code>s you can amend the previous commit using <code>git commit --amend</code> or create a new commit for the changes using <code>git commit</code>.</p>"},{"location":"#create-the-local-development-environment","title":"Create the local development environment","text":"<p>To start the development, you need to make sure your environment is correctly setup. One way to do this is by using a virtual environment and installing all the dependencies there:</p> <pre><code># requires at least python version 3.11\npython3 -m venv .venv\n. .venv/bin/activate\npip install -e .[dev]\n</code></pre> <p>This will install you package in editable mode, so you can open a python interpreter and import your package modules and pick up any local changes without the need to reinstall.  You can now run tools directly, like <code>pytest</code>.</p>"},{"location":"#verify-the-new-repository-is-healthy-using-nox","title":"Verify the new repository is healthy using <code>nox</code>","text":"<p>If you prefer to keep your virtual enviroment cleaner and avoid installing development dependencies, you can also use <code>nox</code> to create isolated environments for you:</p> <pre><code>pip install -e .[dev-noxfile]\nnox --install-only  # Set up virtual environments once\nnox -R  # Run linting and testing reusing the already existing virtual environments\n</code></pre> <p>This will only install you package in editable mode and the minimum dependencies to be able to run <code>nox</code>, and then run all <code>nox</code> default sessions, which will run linters and tests.</p> <p>Note</p> <p>It's much faster to use <code>nox</code> with <code>--install-only</code> once (each time to change or update dependencies you need to run it again) and then using <code>nox -R</code> to run the sessions without re-creating the virtual environments.</p> <p>Otherwise <code>nox</code> will create many virtual environments each time you run it, which is very slow.</p>"},{"location":"#verify-the-generated-documentation-works","title":"Verify the generated documentation works","text":"<p>To generate the documentation you can use <code>mkdocs</code>:</p> <pre><code>pip install .[dev-mkdocs]  # Not necessary if you already installed .[dev]\nmkdocs serve\n</code></pre> <p>If the command fails, look at the log warnings and errors and fix them.  If it worked, now there is a local web server serving the documentation, you can point your browser to Now you can point your browser to http://127.0.0.1:8000 to have a look.</p> <p>Info</p> <p>For API projects <code>docker</code> is needed to generate and serve documentation, as the easiest way to use the tool to generate the documentation from <code>.proto</code> files is using <code>docker</code>.</p>"},{"location":"#initialize-the-github-pages-website","title":"Initialize the GitHub pages website","text":"<p>The generated documentation can be easily published via GitHub pages, and it will be automatically updated for new pushed and releases, but for that to work correctly, some initial setup is needed:</p> <pre><code>pip install -e .[dev-mkdocs]  # Not necessary if you already installed .[dev]\nmike deploy --update-aliases next latest  # Creates the branch gh-pages locally\nmike set-default latest  # Makes the latest alias the default version\ngit push upstream gh-pages  # Pushes the new branch upstream so the website is published\n</code></pre> <p>Then make sure that GitHub pages is enabled in <code>https://github.com/&lt;repo-owner&gt;/&lt;repo-name&gt;/settings/pages</code>.</p> <p>If all went well, your website should be available soon via <code>https://&lt;repo-owner&gt;.github.io//&lt;repo-name&gt;/</code>.</p>"},{"location":"#migrate-an-existing-project","title":"Migrate an existing project","text":"<p>The easiest way to migrate an existing project is to just generate a new one basing all the inputs in the current project metadata and then overwritting the existing files.</p> <p>It is recommended to commit all changes before doing this, so you can then use <code>git</code> to look at the changes.</p> <p>If you generate the new repo in a temporary directory, you can easily overwrite the files in your existing project by using <code>rsync</code> or similar tools:</p> <pre><code>cd /tmp\ncookiecutter gh:frequenz-floss/frequenz-repo-config-python --directory=cookiecutter\nrsync -vr --exclude=.git/ new-project/ /path/to/existing/project\ncd /path/to/existing/project\ngit diff\n# Fix all the `TODO`s and cleanup the generated files\ngit commit -a\n</code></pre> <p>Warning</p> <p>The trailing slash in <code>new-project/</code> and the lack of it in <code>/path/to/existing/project</code> are meaningful to <code>rsync</code>.</p> <p>Also make sure to exclude the <code>.git/</code> directory to avoid messing up with your local git repository.</p> <p>Tip</p> <p>Please have a look at the follow-up steps listed in the Start a new project section to finish the setup.</p>"},{"location":"#update-an-existing-project","title":"Update an existing project","text":"<p>To update an existing project you can use the Cookiecutter replay file that was saved during the project generation.  The file is saved in <code>.cookiecutter-replay.json</code>.  Using this file you can re-run Cookiecutter without having to enter all the inputs again.</p> <p>Warning</p> <p>Don't forget to commit all changes in your repository before doing this! Files will be overwritten!</p> <pre><code>git commit -a  # commit all changes\ncd ..\ncookiecutter gh:frequenz-floss/frequenz-repo-config-python \\\n--directory=cookiecutter \\\n--force \\\n--replay \\\n--replay-file project-directory/.cookiecutter-replay.json\n</code></pre> <p>This will create a new commit with all the changes to the overwritten files. Bear in mind that all the <code>TODO</code>s will come back, so there will be quite a bit of cleanup to do.  You can easily check what was changed using <code>git show</code>, and you can use <code>git commit --amend</code> to amend the previous commit with the template updates, or create a new commit with the fixes.  You can also use <code>git citool</code> or <code>git gui</code> to easily add, remove or even discard (revert) changes in the templates update commit.</p> <p>Note</p> <p>The <code>project-directory</code> is the directory of your previously generated project. If you renamed it, then the files will be generated in a new directory with the original name.  You can update the target directory in the replay file.</p> <p>Note</p> <p>Please remember to keep your replay file up to date if you change any metadata in the project.</p> <p>Tip</p> <p>Please have a look at the follow-up steps listed in the Start a new project section to finish the setup.</p>"},{"location":"#advanced-usage","title":"Advanced usage","text":"<p>The Cookiecutter template uses some tools provided as a library by this project.</p> <p>Usually users don't need deal with it directly, but if you project needs some extra customization (like disabling <code>nox</code> sessions or adding new ones, or using different CLI options for some tools), then you'll need to.</p> <p>You can find information about the extra features in the API refence.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to Frequenz Repository Configuration","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>API Reference</li> <li>Contributing</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>repo<ul> <li>config<ul> <li>mkdocs</li> <li>nox<ul> <li>config</li> <li>default</li> <li>session</li> <li>util</li> </ul> </li> <li>protobuf</li> <li>setuptools<ul> <li>grpc_tools</li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/frequenz/repo/config/","title":"config","text":""},{"location":"reference/frequenz/repo/config/#frequenz.repo.config","title":"<code>frequenz.repo.config</code>","text":"<p>Frequenz project setup tools and common configuration.</p> <p>The tools are provided to configure the main types of repositories most commonly used at Frequenz, defined in <code>frequenz.repo.config.RepositoryType</code>.</p> <ul> <li>actor: SDK actors</li> <li>api: gRPC APIs</li> <li>app: SDK applications</li> <li>lib: General purpose Python libraries</li> <li>model: SDK machine learning models</li> </ul>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config--common","title":"Common","text":""},{"location":"reference/frequenz/repo/config/#frequenz.repo.config--nox-running-tests-and-linters","title":"<code>nox</code> (running tests and linters)","text":""},{"location":"reference/frequenz/repo/config/#frequenz.repo.config--writing-the-noxfilepy","title":"Writing the <code>noxfile.py</code>","text":"<p>Projects wanting to use <code>nox</code> to run lint checkers and other utilities can use the <code>frequenz.repo.config.nox</code> package.</p> <p>When writing the <code>noxfile.py</code> you should import the <code>nox</code> module from this package and use the <code>frequenz.repo.config.nox.configure</code> function, which will configure all nox sessions.</p> <p>To use the default options, you should call <code>configure()</code> using one of the repository types.  For example:</p> <pre><code>from frequenz.repo.config import RepositoryType, nox\n\nnox.configure(RepositoryType.LIB)\n</code></pre> <p>Again, make sure to pick the correct project typedefault configuration based on the type of your project (<code>actor_config</code>, <code>api_config</code>, <code>app_config</code>, <code>lib_config</code>, <code>model_config</code>).</p> <p>If you need to use some custom configuration, you can start from the default settings in the <code>frequenz.repo.config.nox.default</code> module, copying it and changing whatever you need to customize.  For example:</p> <pre><code>from frequenz.repo.config import nox\nfrom frequenz.repo.config.nox import default\n\nconfig = default.lib_config.copy()\nconfig.opts.black.append(\"--diff\")\nnox.configure(config)\n</code></pre> <p>If you need further customization or to define new sessions, you can use the following modules:</p> <ul> <li> <p><code>frequenz.repo.config.nox.config</code>: Low-level utilities to configure nox   sessions. It defines the <code>Config</code> and CommandsOptions<code>classes and the actual   implementation of the</code>configure()<code>function. It also defines the</code>get()`   function, which can be used to get the currently used configuration object.</p> </li> <li> <p><code>frequenz.repo.config.nox.session</code>: Predefined nox sessions. These are   the sessions that are used by default.</p> </li> <li> <p><code>frequenz.repo.config.nox.util</code>: General purpose utility functions.</p> </li> </ul>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config--pyprojecttoml-configuration","title":"<code>pyproject.toml</code> configuration","text":"<p>All sessions configured by this package expect the <code>pyproject.toml</code> file to define specific dev dependencies that will be used by the different <code>nox</code> sessions.</p> <p>The following optional dependencies are used and must be defined:</p> <ul> <li><code>dev-docstrings</code>: Dependencies to lint the documentation.</li> </ul> <p>At least these packages should be included:</p> <ul> <li><code>pydocstyle</code>: To check the docstrings' format.</li> <li> <p><code>darglint</code>: To check the docstrings' content.</p> </li> <li> <p><code>dev-formatting</code>: Dependencies to check the code's formatting.</p> </li> </ul> <p>At least these packages should be included:</p> <ul> <li><code>black</code>: To check the code's formatting.</li> <li> <p><code>isort</code>: To check the imports' formatting.</p> </li> <li> <p><code>dev-mypy</code>: Dependencies to run <code>mypy</code> to check the code's type annotations.</p> </li> </ul> <p>At least these packages should be included:</p> <ul> <li> <p><code>mypy</code>: To check the code's type annotations.</p> </li> <li> <p><code>dev-pylint</code>: Dependencies to run <code>pylint</code> to lint the code.</p> </li> </ul> <p>At least these packages should be included:</p> <ul> <li> <p><code>pylint</code>: To lint the code.</p> </li> <li> <p><code>dev-pytest</code>: Dependencies to run the tests using <code>pytest</code>.</p> </li> </ul> <p>At least these packages should be included:</p> <ul> <li><code>pytest</code>: To run the tests.</li> </ul> <p>For some of these you should install too any other dependencies that are used by the project. For example, if the project uses <code>pytest-asyncio</code>, you should include it in the <code>dev-pytest</code> optional dependency.</p> <p>It is also recommended, but not required, to provide a global <code>dev</code> optional dependency that includes all the other optional dependencies, so users can install all the dependencies needed while developing the project without having to run <code>nox</code>, which might be a bit slow if you want to do quick iterations.</p> <pre><code>$ pip install -e .[dev]\n...\n$ pytest\n...\n</code></pre> <p>Here is a sample <code>pyproject.toml</code> file that defines all the optional dependencies:</p> <pre><code>[project]\nname = \"my-package\"\n# ...\n\n[project.optional-dependencies]\ndev-docstrings = [\"pydocstyle == 6.3.0\", \"darglint == 1.8.1\"]\ndev-formatting = [\"black == 23.3.0\", \"isort == 5.12.0\"]\ndev-mkdocs = [\n\"mike == 1.1.2\",\n\"mkdocs-gen-files == 0.5.0\",\n\"mkdocs-literate-nav == 0.6.0\",\n\"mkdocs-material == 9.1.16\",\n\"mkdocs-section-index == 0.3.5\",\n\"mkdocstrings[python] == 0.22.0\",\n]\ndev-mypy = [\n\"mypy == 1.1.1\",\n# For checking tests\n\"my-package[dev-mkdocs,dev-pytest]\",\n]\ndev-pylint = [\n\"pylint == 2.17.1\",\n\"pylint-google-style-guide-imports-enforcing == 1.3.0\",\n# For checking tests\n\"my-package[dev-mkdocs,dev-pytest]\",\n]\ndev-pytest = [\n\"pytest == 7.2.2\",\n\"pytest-asyncio == 0.21.0\",\n\"pytest-mock == 3.10.0\",\n]\ndev = [\n\"my-package[dev-mkdocs,dev-docstrings,dev-formatting,dev-mypy,dev-nox,dev-pylint,dev-pytest]\",\n]\n</code></pre>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config--mkdocs-generating-documentation","title":"<code>mkdocs</code> (generating documentation)","text":""},{"location":"reference/frequenz/repo/config/#frequenz.repo.config--api-reference-generation","title":"API reference generation","text":"<p>The API documnentation can be automatically generated from the source files using the <code>frequenz.repo.config.mkdocs</code> package as when run as a <code>mkdocs-gen-files</code> plugin script.</p> <p>To enable it you just need to make sure the <code>mkdocs-gen-files</code>, <code>mkdocs-literate-nav</code> and <code>mkdocstrings[python]</code> packages are installed (look at the <code>pyproject.toml</code> configuration in the <code>nox</code> section) and add the following configuration to the <code>mkdocs.yml</code> file:</p> <pre><code>plugins:\n- gen-files:\nscripts:\n- path/to/my/custom/script.py\n</code></pre> <p>By default this script will look for files in the <code>src/</code> directory and generate the documentation files in the <code>python-reference/</code> directory inside <code>mkdocs</code> output directory (<code>site</code> by defaul).</p> <p>If you need to customize the above paths, you can create a new script to use with the <code>mkdocs-gen-files</code> plugin as follows:</p> <pre><code>from frequenz.repo.config import mkdocs\n\nmkdocs.generate_python_api_pages(\"my_sources\", \"API\")\n</code></pre> <p>Where <code>my_sources</code> is the directory containing the source files and <code>API</code> is the directory where to generate the documentation files (relative to <code>mkdocs</code> output directory).</p> <p>And then replace this configuration in the <code>mkdocs.yml</code> file:</p> <pre><code>plugins:\n- gen-files:\nscripts:\n- path/to/my/custom/script.py\n</code></pre>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config--apis","title":"APIs","text":""},{"location":"reference/frequenz/repo/config/#frequenz.repo.config--protobuf-configuation","title":"Protobuf configuation","text":"<p>Support is provided to generate files from protobuf files.  To do this, it is possible to configure the options to use while generating the files for different purposes (language bindings, documentation, etc.).</p> <p>The configuration can be done in the <code>pyproject.toml</code> file as follows:</p> <pre><code>[tool.frequenz_repo_config.protobuf]\n# Location of the proto files relative to the root of the repository (default: \"proto\")\nproto_path = \"proto_files\"\n# Glob pattern to use to find the proto files in the proto_path (default: \"*.proto\")\nproto_glob = \"*.prt\"  # Default: \"*.proto\"\n# List of paths to pass to the protoc compiler as include paths (default:\n# [\"submodules/api-common-protos\", \"submodules/frequenz-api-common/proto\"])\ninclude_paths = [\"submodules/api-common-protos\"]\n# Path where to generate the Python files (default: \"py\")\npy_path = \"generated\"\n# Path where to generate the documentation files (default: \"protobuf-reference\")\ndocs_path = \"API\"\n</code></pre> <p>If the defaults are not suitable for you (for example you need to use more or less submodules or your proto files are located somewhere else), please adjust the configuration to match your project structure.</p>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config--mkdocs-api-reference-generation","title":"<code>mkdocs</code> API reference generation","text":"<p>If your project provides protobuf files, you can also generate the API documentation for them adding one more line to the script provided in the common section:</p> <pre><code>from frequenz.repo.config import mkdocs\n\nmkdocs.generate_python_api_pages(\"my_sources\", \"API-py\")\nmkdocs.generate_protobuf_api_pages()\n</code></pre> <p>This will use the configuration in the <code>pyproject.toml</code> file and requires <code>docker</code> to run (it uses the <code>pseudomuto/protoc-gen-doc</code> docker image.</p>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config--setuptools-grpc-support","title":"<code>setuptools</code> gRPC support","text":"<p>When configuring APIs it is assumed that they have a gRPC interface.</p> <p>The project structure is assumed to be as described in the Protobuf configuration section plus the following:</p> <ul> <li><code>pytests/</code>: Directory containing the tests for the Python code.</li> <li><code>submodules/api-common-protos</code>: Directory containing the Git submodule with the   <code>google/api-common-protos</code> repository.</li> <li><code>submodules/frequenz-api-common</code>: Directory containing the Git submodule with the   <code>frequenz-floss/frequenz-api-common</code> repository.</li> </ul> <p>Normally Frequenz APIs use basic types from <code>google/api-common-protos</code> and <code>frequenz-floss/frequenz-api-common</code>, so you need to make sure the proper submodules are added to your project:</p> <pre><code>mkdir submodules\ngit submodule add https://github.com/googleapis/api-common-protos.git \\\nsubmodules/api-common-protos\ngit submodule add https://github.com/frequenz-floss/frequenz-api-common.git \\\nsubmodules/frequenz-api-common\ngit commit -m \"Add api-common-protos and frequenz-api-common submodules\" submodules\n</code></pre> <p>Then you need to add this package as a build dependency and a few extra dependencies to your project, for example:</p> <pre><code>requires = [\n\"setuptools &gt;= 67.3.2, &lt; 68\",\n\"setuptools_scm[toml] &gt;= 7.1.0, &lt; 8\",\n\"frequenz-repo-config[api] &gt;= 0.1.0, &lt; 0.2.0\",\n]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\ndependencies = [\n\"frequenz-api-common &gt;= 0.2.0, &lt; 0.3.0\",\n\"googleapis-common-protos &gt;= 1.56.2, &lt; 2\",\n\"grpcio &gt;= 1.51.1, &lt; 2\",\n]\n</code></pre> <p>Note the <code>api</code> extra in <code>frequenz-repo-config[api]</code>, this will ensure all dependencies to build the protocol files will be installed when building the package. Of course you need to replace the version numbers with the correct ones too.</p> <p>You should also add the following configuration to your <code>pyproject.toml</code> file to make sure the generated files are included in the wheel:</p> <pre><code>[tool.setuptools.package-dir]\n\"\" = \"py\"\n\n[tool.setuptools.package-data]\n\"*\" = [\"*.pyi\"]\n\n[tools.pytest.ini_options]\ntestpaths = [\"pytests\"]\n</code></pre> <p>Finally you need to make sure to include the generated <code>*.pyi</code> files in the source distribution, as well as the Google api-common-protos files, as it is not handled automatically yet (#13). Make sure to include these lines in the <code>MANIFEST.in</code> file:</p> <pre><code>recursive-include submodules/api-common-protos/google *.proto\nrecursive-include submodules/frequenz-api-common/proto *.proto\n</code></pre> <p>Please adapt the instructions above to your project structure if you need to change the defaults.</p>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config-classes","title":"Classes","text":""},{"location":"reference/frequenz/repo/config/#frequenz.repo.config.RepositoryType","title":"<code>frequenz.repo.config.RepositoryType</code>","text":"<p>         Bases: <code>_enum.Enum</code></p> <p>Supported types of repository.</p> Source code in <code>src/frequenz/repo/config/_core.py</code> <pre><code>class RepositoryType(_enum.Enum):\n\"\"\"Supported types of repository.\"\"\"\n\n    ACTOR = \"actor\"\n\"\"\"SDK actor repository.\"\"\"\n\n    API = \"api\"\n\"\"\"gRPC API repository.\"\"\"\n\n    APP = \"app\"\n\"\"\"SDK application repository.\"\"\"\n\n    LIB = \"lib\"\n\"\"\"General purpose library repository.\"\"\"\n\n    MODEL = \"model\"\n\"\"\"SDK machine learning model repository.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config.RepositoryType-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/repo/config/#frequenz.repo.config._core.RepositoryType.ACTOR","title":"<code>ACTOR = 'actor'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>SDK actor repository.</p>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config._core.RepositoryType.API","title":"<code>API = 'api'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>gRPC API repository.</p>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config._core.RepositoryType.APP","title":"<code>APP = 'app'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>SDK application repository.</p>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config._core.RepositoryType.LIB","title":"<code>LIB = 'lib'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>General purpose library repository.</p>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config._core.RepositoryType.MODEL","title":"<code>MODEL = 'model'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>SDK machine learning model repository.</p>"},{"location":"reference/frequenz/repo/config/mkdocs/","title":"mkdocs","text":""},{"location":"reference/frequenz/repo/config/mkdocs/#frequenz.repo.config.mkdocs","title":"<code>frequenz.repo.config.mkdocs</code>","text":"<p>Generate the code reference pages.</p> <p>It uses the following <code>mkdocs</code> plugins:</p> <ul> <li><code>mkdocs-gen-files</code> to generate the API documentation pages.</li> <li><code>mkdocs-literate-nav</code> to make use of the generate <code>SUMMARY.md</code> file.</li> </ul> <p>Based on the recipe at: https://mkdocstrings.github.io/recipes/#automatic-code-reference-pages</p>"},{"location":"reference/frequenz/repo/config/mkdocs/#frequenz.repo.config.mkdocs-functions","title":"Functions","text":""},{"location":"reference/frequenz/repo/config/mkdocs/#frequenz.repo.config.mkdocs.generate_protobuf_api_pages","title":"<code>frequenz.repo.config.mkdocs.generate_protobuf_api_pages(src_path='proto', dst_path='protobuf-reference')</code>","text":"<p>Generate API documentation pages for the code.</p> <p>Internal modules (those starting with an underscore except from <code>__init__</code>) are not included.</p> <p>A summary page is generated as <code>SUMMARY.md</code> which is compatible with the <code>mkdocs-literary-nav</code> plugin.</p> PARAMETER DESCRIPTION <code>src_path</code> <p>Path where the code is located.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'proto'</code> </p> <code>dst_path</code> <p>Path where the documentation should be generated.  This is relative to the output directory of mkdocs.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'protobuf-reference'</code> </p> Source code in <code>src/frequenz/repo/config/mkdocs.py</code> <pre><code>def generate_protobuf_api_pages(\n    src_path: str = \"proto\", dst_path: str = \"protobuf-reference\"\n) -&gt; None:\n\"\"\"Generate API documentation pages for the code.\n\n    Internal modules (those starting with an underscore except from `__init__`) are\n    not included.\n\n    A summary page is generated as `SUMMARY.md` which is compatible with the\n    `mkdocs-literary-nav` plugin.\n\n    Args:\n        src_path: Path where the code is located.\n        dst_path: Path where the documentation should be generated.  This is relative\n            to the output directory of mkdocs.\n    \"\"\"\n    # type ignore because mkdocs_gen_files uses a very weird module-level\n    # __getattr__() which messes up the type system\n    nav = mkdocs_gen_files.Nav()  # type: ignore\n    config = _protobuf.ProtobufConfig.from_pyproject_toml(\n        proto_path=src_path, docs_path=dst_path\n    )\n\n    cwd = Path.cwd()\n\n    with tempfile.TemporaryDirectory(prefix=\"mkdocs-protobuf-reference-\") as tmp_path:\n        for path in sorted(Path(config.proto_path).rglob(\"*.proto\")):\n            doc_path = path.relative_to(config.proto_path).with_suffix(\".md\")\n            full_doc_path = Path(config.docs_path, doc_path)\n            parts = tuple(path.relative_to(config.proto_path).parts)\n            nav[parts] = doc_path.as_posix()\n            doc_tmp_path = tmp_path / doc_path\n            doc_tmp_path.parent.mkdir(parents=True, exist_ok=True)\n            try:\n                subprocess.run(\n                    [\n                        \"docker\",\n                        \"run\",\n                        \"--rm\",\n                        f\"-v{cwd}:{cwd}\",\n                        f\"-v{tmp_path}:{tmp_path}\",\n                        \"pseudomuto/protoc-gen-doc\",\n                        f\"-I{cwd / config.proto_path}\",\n                        *(f\"-I{cwd / p}\" for p in config.include_paths),\n                        f\"--doc_opt=markdown,{doc_path.name}\",\n                        f\"--doc_out={tmp_path / doc_path.parent}\",\n                        str(cwd / path),\n                    ],\n                    check=True,\n                )\n            except subprocess.CalledProcessError as error:\n                print(f\"Error generating protobuf reference page: {error}\")\n\n            with doc_tmp_path.open() as input_file, mkdocs_gen_files.open(\n                full_doc_path, \"w\"\n            ) as output_file:\n                output_file.write(input_file.read())\n\n            mkdocs_gen_files.set_edit_path(full_doc_path, Path(\"..\") / path)\n\n    with mkdocs_gen_files.open(Path(config.docs_path) / \"SUMMARY.md\", \"w\") as nav_file:\n        nav_file.writelines(nav.build_literate_nav())\n</code></pre>"},{"location":"reference/frequenz/repo/config/mkdocs/#frequenz.repo.config.mkdocs.generate_python_api_pages","title":"<code>frequenz.repo.config.mkdocs.generate_python_api_pages(src_path='src', dst_path='python-reference')</code>","text":"<p>Generate API documentation pages for the code.</p> <p>Internal modules (those starting with an underscore except from <code>__init__</code>) are not included.</p> <p>A summary page is generated as <code>SUMMARY.md</code> which is compatible with the <code>mkdocs-literary-nav</code> plugin.</p> PARAMETER DESCRIPTION <code>src_path</code> <p>Path where the code is located.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'src'</code> </p> <code>dst_path</code> <p>Path where the documentation should be generated.  This is relative to the output directory of mkdocs.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'python-reference'</code> </p> Source code in <code>src/frequenz/repo/config/mkdocs.py</code> <pre><code>def generate_python_api_pages(\n    src_path: str = \"src\", dst_path: str = \"python-reference\"\n) -&gt; None:\n\"\"\"Generate API documentation pages for the code.\n\n    Internal modules (those starting with an underscore except from `__init__`) are\n    not included.\n\n    A summary page is generated as `SUMMARY.md` which is compatible with the\n    `mkdocs-literary-nav` plugin.\n\n    Args:\n        src_path: Path where the code is located.\n        dst_path: Path where the documentation should be generated.  This is relative\n            to the output directory of mkdocs.\n    \"\"\"\n    # type ignore because mkdocs_gen_files uses a very weird module-level\n    # __getattr__() which messes up the type system\n    nav = mkdocs_gen_files.Nav()  # type: ignore\n\n    for path in sorted(Path(src_path).rglob(\"*.py\")):\n        module_path = path.relative_to(src_path).with_suffix(\"\")\n\n        doc_path = path.relative_to(src_path).with_suffix(\".md\")\n        full_doc_path = Path(dst_path, doc_path)\n        parts = tuple(module_path.parts)\n        if _is_internal(parts):\n            continue\n        if parts[-1] == \"__init__\":\n            doc_path = doc_path.with_name(\"index.md\")\n            full_doc_path = full_doc_path.with_name(\"index.md\")\n            parts = parts[:-1]\n\n        nav[parts] = doc_path.as_posix()\n\n        with mkdocs_gen_files.open(full_doc_path, \"w\") as output_file:\n            output_file.write(f\"::: {'.'.join(parts)}\\n\")\n\n        mkdocs_gen_files.set_edit_path(full_doc_path, Path(\"..\") / path)\n\n    with mkdocs_gen_files.open(Path(dst_path) / \"SUMMARY.md\", \"w\") as nav_file:\n        nav_file.writelines(nav.build_literate_nav())\n</code></pre>"},{"location":"reference/frequenz/repo/config/protobuf/","title":"protobuf","text":""},{"location":"reference/frequenz/repo/config/protobuf/#frequenz.repo.config.protobuf","title":"<code>frequenz.repo.config.protobuf</code>","text":"<p>Manages the configuration to generate files from the protobuf files.</p>"},{"location":"reference/frequenz/repo/config/protobuf/#frequenz.repo.config.protobuf-classes","title":"Classes","text":""},{"location":"reference/frequenz/repo/config/protobuf/#frequenz.repo.config.protobuf.ProtobufConfig","title":"<code>frequenz.repo.config.protobuf.ProtobufConfig</code>  <code>dataclass</code>","text":"<p>A configuration for the protobuf files.</p> <p>The configuration can be loaded from the <code>pyproject.toml</code> file using the class method <code>from_pyproject_toml()</code>.</p> Source code in <code>src/frequenz/repo/config/protobuf.py</code> <pre><code>@dataclasses.dataclass(frozen=True, kw_only=True)\nclass ProtobufConfig:\n\"\"\"A configuration for the protobuf files.\n\n    The configuration can be loaded from the `pyproject.toml` file using the class\n    method `from_pyproject_toml()`.\n    \"\"\"\n\n    proto_path: str = \"proto\"\n\"\"\"The path of the root directory containing the protobuf files.\"\"\"\n\n    proto_glob: str = \"*.proto\"\n\"\"\"The glob pattern to use to find the protobuf files.\"\"\"\n\n    include_paths: Sequence[str] = (\n        \"submodules/api-common-protos\",\n        \"submodules/frequenz-api-common/proto\",\n    )\n\"\"\"The paths to add to the include path when compiling the protobuf files.\"\"\"\n\n    py_path: str = \"py\"\n\"\"\"The path of the root directory where the Python files will be generated.\"\"\"\n\n    docs_path: str = \"protobuf-reference\"\n\"\"\"The path of the root directory where the documentation files will be generated.\"\"\"\n\n    @classmethod\n    def from_pyproject_toml(\n        cls, /, path: str = \"pyproject.toml\", **defaults: Any\n    ) -&gt; Self:\n\"\"\"Create a new configuration by loading the options from a `pyproject.toml` file.\n\n        The options are read from the `[tool.frequenz-repo-config.protobuf]`\n        section of the `pyproject.toml` file.\n\n        Args:\n            path: The path to the `pyproject.toml` file.\n            **defaults: The default values for the options missing in the file.  If\n                a default is missing too, then the default in this class will be used.\n\n        Returns:\n            The configuration.\n        \"\"\"\n        try:\n            with pathlib.Path(path).open(\"rb\") as toml_file:\n                pyproject_toml = tomllib.load(toml_file)\n        except FileNotFoundError:\n            return cls(**defaults)\n        except (IOError, OSError) as err:\n            _logger.warning(\"WARNING: Failed to load pyproject.toml: %s\", err)\n            return cls(**defaults)\n\n        try:\n            config = pyproject_toml[\"tool\"][\"frequenz-repo-config\"][\"protobuf\"]\n        except KeyError:\n            return cls(**defaults)\n\n        known_keys = frozenset(defaults.keys())\n        config_keys = frozenset(config.keys())\n        if unknown_keys := config_keys - known_keys:\n            _logger.warning(\n                \"WARNING: There are some configuration keys in pyproject.toml we don't \"\n                \"know about and will be ignored: %s\",\n                \", \".join(f\"'{k}'\" for k in unknown_keys),\n            )\n\n        attrs = dict(defaults, **{k: config[k] for k in (known_keys &amp; config_keys)})\n        return cls(**attrs)\n</code></pre>"},{"location":"reference/frequenz/repo/config/protobuf/#frequenz.repo.config.protobuf.ProtobufConfig-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/repo/config/protobuf/#frequenz.repo.config.protobuf.ProtobufConfig.docs_path","title":"<code>docs_path: str = 'protobuf-reference'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The path of the root directory where the documentation files will be generated.</p>"},{"location":"reference/frequenz/repo/config/protobuf/#frequenz.repo.config.protobuf.ProtobufConfig.include_paths","title":"<code>include_paths: Sequence[str] = ('submodules/api-common-protos', 'submodules/frequenz-api-common/proto')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The paths to add to the include path when compiling the protobuf files.</p>"},{"location":"reference/frequenz/repo/config/protobuf/#frequenz.repo.config.protobuf.ProtobufConfig.proto_glob","title":"<code>proto_glob: str = '*.proto'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The glob pattern to use to find the protobuf files.</p>"},{"location":"reference/frequenz/repo/config/protobuf/#frequenz.repo.config.protobuf.ProtobufConfig.proto_path","title":"<code>proto_path: str = 'proto'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The path of the root directory containing the protobuf files.</p>"},{"location":"reference/frequenz/repo/config/protobuf/#frequenz.repo.config.protobuf.ProtobufConfig.py_path","title":"<code>py_path: str = 'py'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The path of the root directory where the Python files will be generated.</p>"},{"location":"reference/frequenz/repo/config/protobuf/#frequenz.repo.config.protobuf.ProtobufConfig-functions","title":"Functions","text":""},{"location":"reference/frequenz/repo/config/protobuf/#frequenz.repo.config.protobuf.ProtobufConfig.from_pyproject_toml","title":"<code>from_pyproject_toml(path='pyproject.toml', **defaults)</code>  <code>classmethod</code>","text":"<p>Create a new configuration by loading the options from a <code>pyproject.toml</code> file.</p> <p>The options are read from the <code>[tool.frequenz-repo-config.protobuf]</code> section of the <code>pyproject.toml</code> file.</p> PARAMETER DESCRIPTION <code>path</code> <p>The path to the <code>pyproject.toml</code> file.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'pyproject.toml'</code> </p> <code>**defaults</code> <p>The default values for the options missing in the file.  If a default is missing too, then the default in this class will be used.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The configuration.</p> Source code in <code>src/frequenz/repo/config/protobuf.py</code> <pre><code>@classmethod\ndef from_pyproject_toml(\n    cls, /, path: str = \"pyproject.toml\", **defaults: Any\n) -&gt; Self:\n\"\"\"Create a new configuration by loading the options from a `pyproject.toml` file.\n\n    The options are read from the `[tool.frequenz-repo-config.protobuf]`\n    section of the `pyproject.toml` file.\n\n    Args:\n        path: The path to the `pyproject.toml` file.\n        **defaults: The default values for the options missing in the file.  If\n            a default is missing too, then the default in this class will be used.\n\n    Returns:\n        The configuration.\n    \"\"\"\n    try:\n        with pathlib.Path(path).open(\"rb\") as toml_file:\n            pyproject_toml = tomllib.load(toml_file)\n    except FileNotFoundError:\n        return cls(**defaults)\n    except (IOError, OSError) as err:\n        _logger.warning(\"WARNING: Failed to load pyproject.toml: %s\", err)\n        return cls(**defaults)\n\n    try:\n        config = pyproject_toml[\"tool\"][\"frequenz-repo-config\"][\"protobuf\"]\n    except KeyError:\n        return cls(**defaults)\n\n    known_keys = frozenset(defaults.keys())\n    config_keys = frozenset(config.keys())\n    if unknown_keys := config_keys - known_keys:\n        _logger.warning(\n            \"WARNING: There are some configuration keys in pyproject.toml we don't \"\n            \"know about and will be ignored: %s\",\n            \", \".join(f\"'{k}'\" for k in unknown_keys),\n        )\n\n    attrs = dict(defaults, **{k: config[k] for k in (known_keys &amp; config_keys)})\n    return cls(**attrs)\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/","title":"nox","text":""},{"location":"reference/frequenz/repo/config/nox/#frequenz.repo.config.nox","title":"<code>frequenz.repo.config.nox</code>","text":"<p>Utilities to build noxfiles.</p> <p>The main entry point is the <code>configure()</code> function, which will configure all nox sessions according to some configuration.</p> <p>To use the default options, you should call <code>configure()</code> using one of the repository types.  For example:</p> <pre><code>from frequenz.repo.config import RepositoryType, nox\n\nnox.configure(RepositoryType.LIB)\n</code></pre> <p>Again, make sure to pick the correct project typedefault configuration based on the type of your project (<code>actor_config</code>, <code>api_config</code>, <code>app_config</code>, <code>lib_config</code>, <code>model_config</code>).</p> <p>If you need to use some custom configuration, you can start from the default settings in the <code>frequenz.repo.config.nox.default</code> module, copying it and changing whatever you need to customize.  For example:</p> <pre><code>from frequenz.repo.config import nox\nfrom frequenz.repo.config.nox import default\n\nconfig = default.lib_config.copy()\nconfig.opts.black.append(\"--diff\")\nnox.configure(config)\n</code></pre> <p>If you need further customization or to define new sessions, you can use the following modules:</p> <ul> <li> <p><code>frequenz.repo.config.nox.config</code>: Low-level utilities to configure nox sessions.   It defines the <code>Config</code> and CommandsOptions<code>classes and the actual implementation of   the</code>configure()<code>function. It also defines the</code>get()` function, which can be used to   get the currently used configuration object.</p> </li> <li> <p><code>frequenz.repo.config.nox.session</code>: Predefined nox sessions. These are the   sessions that are used by default.</p> </li> <li> <p><code>frequenz.repo.config.nox.util</code>: General purpose utility functions.</p> </li> </ul>"},{"location":"reference/frequenz/repo/config/nox/#frequenz.repo.config.nox-functions","title":"Functions","text":""},{"location":"reference/frequenz/repo/config/nox/#frequenz.repo.config.nox.configure","title":"<code>frequenz.repo.config.nox.configure(conf, /, *, import_default_sessions=True)</code>","text":"<p>Configure nox using the provided configuration or repository type.</p> PARAMETER DESCRIPTION <code>conf</code> <p>The configuration to use to configure nox, or the repository type to use to configure nox.  The later will use the default configuration in <code>frequenz.repo.config.nox.default</code> for that type of repository.</p> <p> TYPE: <code>Config | RepositoryType</code> </p> <code>import_default_sessions</code> <p>Whether to import the default sessions or not. This is only necessary if you want to avoid using the default provided sessions and use your own.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/frequenz/repo/config/nox/config.py</code> <pre><code>def configure(\n    conf: Config | RepositoryType, /, *, import_default_sessions: bool = True\n) -&gt; None:\n\"\"\"Configure nox using the provided configuration or repository type.\n\n    Args:\n        conf: The configuration to use to configure nox, or the repository type to use\n            to configure nox.  The later will use the default configuration in\n            [`frequenz.repo.config.nox.default`][] for that type of repository.\n        import_default_sessions: Whether to import the default sessions or not.\n            This is only necessary if you want to avoid using the default provided\n            sessions and use your own.\n    \"\"\"\n    global _config  # pylint: disable=global-statement\n\n    # We need to make sure sessions are imported, otherwise they won't be visible to nox.\n    if import_default_sessions:\n        # pylint: disable=import-outside-toplevel,cyclic-import\n        from . import session as _\n\n    match conf:\n        case Config():\n            _config = conf\n        case RepositoryType() as repo_type:\n            # pylint: disable=import-outside-toplevel,cyclic-import\n            from . import default\n\n            match repo_type:\n                case RepositoryType.ACTOR:\n                    _config = default.actor_config\n                case RepositoryType.API:\n                    _config = default.api_config\n                case RepositoryType.APP:\n                    _config = default.app_config\n                case RepositoryType.LIB:\n                    _config = default.lib_config\n                case RepositoryType.MODEL:\n                    _config = default.model_config\n                case _ as unhandled:\n                    assert_never(unhandled)\n\n    _nox.options.sessions = _config.sessions\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/config/","title":"config","text":""},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config","title":"<code>frequenz.repo.config.nox.config</code>","text":"<p>Configuration utilities for nox.</p> <p>This module provides utilities to configure the nox sessions. It provides a <code>Config</code> and a <code>CommandsOptions</code> class, which are used to configure the nox sessions.</p> <p>The <code>get()</code> function can be used to retrieve the current configuration object so it can be used when implementing custom nox sessions.</p> <p>The <code>configure()</code> function must be called before <code>get()</code> is used.</p>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config-classes","title":"Classes","text":""},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.CommandsOptions","title":"<code>frequenz.repo.config.nox.config.CommandsOptions</code>  <code>dataclass</code>","text":"<p>Command-line options for each command.</p> Source code in <code>src/frequenz/repo/config/nox/config.py</code> <pre><code>@_dataclasses.dataclass(kw_only=True, slots=True)\nclass CommandsOptions:\n\"\"\"Command-line options for each command.\"\"\"\n\n    black: list[str] = _dataclasses.field(default_factory=lambda: [])\n\"\"\"Command-line options for the `black` command.\"\"\"\n\n    darglint: list[str] = _dataclasses.field(default_factory=lambda: [])\n\"\"\"Command-line options for the `darglint` command.\"\"\"\n\n    isort: list[str] = _dataclasses.field(default_factory=lambda: [])\n\"\"\"Command-line options for the `isort` command.\"\"\"\n\n    mypy: list[str] = _dataclasses.field(default_factory=lambda: [])\n\"\"\"Command-line options for the `mypy` command.\"\"\"\n\n    pydocstyle: list[str] = _dataclasses.field(default_factory=lambda: [])\n\"\"\"Command-line options for the `pydocstyle` command.\"\"\"\n\n    pylint: list[str] = _dataclasses.field(default_factory=lambda: [])\n\"\"\"Command-line options for the `pylint` command.\"\"\"\n\n    pytest: list[str] = _dataclasses.field(default_factory=lambda: [])\n\"\"\"Command-line options for the `pytest` command.\"\"\"\n\n    def copy(self) -&gt; Self:\n\"\"\"Create a new object as a copy of self.\n\n        Returns:\n            The copy of self.\n        \"\"\"\n        return _dataclasses.replace(self)\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.CommandsOptions-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.CommandsOptions.black","title":"<code>black: list[str] = _dataclasses.field(default_factory=lambda : [])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Command-line options for the <code>black</code> command.</p>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.CommandsOptions.darglint","title":"<code>darglint: list[str] = _dataclasses.field(default_factory=lambda : [])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Command-line options for the <code>darglint</code> command.</p>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.CommandsOptions.isort","title":"<code>isort: list[str] = _dataclasses.field(default_factory=lambda : [])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Command-line options for the <code>isort</code> command.</p>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.CommandsOptions.mypy","title":"<code>mypy: list[str] = _dataclasses.field(default_factory=lambda : [])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Command-line options for the <code>mypy</code> command.</p>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.CommandsOptions.pydocstyle","title":"<code>pydocstyle: list[str] = _dataclasses.field(default_factory=lambda : [])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Command-line options for the <code>pydocstyle</code> command.</p>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.CommandsOptions.pylint","title":"<code>pylint: list[str] = _dataclasses.field(default_factory=lambda : [])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Command-line options for the <code>pylint</code> command.</p>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.CommandsOptions.pytest","title":"<code>pytest: list[str] = _dataclasses.field(default_factory=lambda : [])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Command-line options for the <code>pytest</code> command.</p>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.CommandsOptions-functions","title":"Functions","text":""},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.CommandsOptions.copy","title":"<code>copy()</code>","text":"<p>Create a new object as a copy of self.</p> RETURNS DESCRIPTION <code>Self</code> <p>The copy of self.</p> Source code in <code>src/frequenz/repo/config/nox/config.py</code> <pre><code>def copy(self) -&gt; Self:\n\"\"\"Create a new object as a copy of self.\n\n    Returns:\n        The copy of self.\n    \"\"\"\n    return _dataclasses.replace(self)\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.Config","title":"<code>frequenz.repo.config.nox.config.Config</code>  <code>dataclass</code>","text":"<p>Configuration for nox sessions.</p> Source code in <code>src/frequenz/repo/config/nox/config.py</code> <pre><code>@_dataclasses.dataclass(kw_only=True, slots=True)\nclass Config:\n\"\"\"Configuration for nox sessions.\"\"\"\n\n    opts: CommandsOptions = _dataclasses.field(default_factory=CommandsOptions)\n\"\"\"Command-line options for each command used by sessions.\"\"\"\n\n    sessions: list[str] = _dataclasses.field(default_factory=lambda: [])\n\"\"\"List of sessions to run.\"\"\"\n\n    source_paths: list[str] = _dataclasses.field(default_factory=lambda: [])\n\"\"\"List of paths containing source files that should be analyzed by the sessions.\n\n    Source paths are inspected for `__init__.py` files to look for packages.\n    The path should be the top-level directory containing packages that will be\n    actually part of the distribution, not development paths, like tests,\n    benchmarks, etc.\n\n    This path will be removed when calculating the package name for the found\n    packages. `mypy` needs the package name to be able to do full import\n    checking.\n    \"\"\"\n\n    extra_paths: list[str] = _dataclasses.field(default_factory=lambda: [])\n\"\"\"List of extra paths to be analyzed by the sessions.\n\n    These are not inspected for packages, as they are passed verbatim to the\n    tools invoked by the sessions.\n    \"\"\"\n\n    def __post_init__(self) -&gt; None:\n\"\"\"Initialize the configuration object.\n\n        This will add extra paths discovered in config files and other sources.\n        \"\"\"\n        for path in _util.discover_paths():\n            if path not in self.extra_paths:\n                self.extra_paths.append(path)\n\n    def copy(self, /) -&gt; Self:\n\"\"\"Create a new object as a copy of self.\n\n        Returns:\n            The copy of self.\n        \"\"\"\n        return _dataclasses.replace(self)\n\n    def path_args(self, session: _nox.Session, /) -&gt; list[str]:\n\"\"\"Return the file paths to run the checks on.\n\n        If positional arguments are present in the nox session, those are used\n        as the file paths verbatim, and if not, all **existing** `source_paths`\n        and `extra_paths` are used.\n\n        Args:\n            session: The nox session to use to look for command-line arguments.\n\n        Returns:\n            The file paths to run the checks on.\n        \"\"\"\n        if session.posargs:\n            return session.posargs\n\n        return list(\n            str(p) for p in _util.existing_paths(self.source_paths + self.extra_paths)\n        )\n\n    def package_args(self, session: _nox.Session, /) -&gt; list[str]:\n\"\"\"Return the package names to run the checks on.\n\n        If positional arguments are present in the nox session, those are used\n        as the file paths verbatim, and if not, all **existing** `source_paths`\n        are searched for python packges by looking for `__init__.py` files.\n        `extra_paths` are used as is, only converting the paths to python\n        package names (replacing `/` with `.` and removing the suffix `.pyi?`\n        if it exists.\n\n        Args:\n            session: The nox session to use to look for command-line arguments.\n\n        Returns:\n            The package names found in the `source_paths`.\n        \"\"\"\n        if session.posargs:\n            return session.posargs\n\n        sources_package_dirs_with_roots = (\n            (p, _util.find_toplevel_package_dirs(p))\n            for p in _util.existing_paths(self.source_paths)\n        )\n\n        source_packages = (\n            _util.path_to_package(pkg_path, root=root)\n            for root, pkg_paths in sources_package_dirs_with_roots\n            for pkg_path in pkg_paths\n        )\n\n        extra_packages = (\n            _util.path_to_package(p) for p in _util.existing_paths(self.extra_paths)\n        )\n\n        return list(\n            _util.deduplicate(_itertools.chain(source_packages, extra_packages))\n        )\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.Config-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.Config.extra_paths","title":"<code>extra_paths: list[str] = _dataclasses.field(default_factory=lambda : [])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of extra paths to be analyzed by the sessions.</p> <p>These are not inspected for packages, as they are passed verbatim to the tools invoked by the sessions.</p>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.Config.opts","title":"<code>opts: CommandsOptions = _dataclasses.field(default_factory=CommandsOptions)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Command-line options for each command used by sessions.</p>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.Config.sessions","title":"<code>sessions: list[str] = _dataclasses.field(default_factory=lambda : [])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of sessions to run.</p>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.Config.source_paths","title":"<code>source_paths: list[str] = _dataclasses.field(default_factory=lambda : [])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of paths containing source files that should be analyzed by the sessions.</p> <p>Source paths are inspected for <code>__init__.py</code> files to look for packages. The path should be the top-level directory containing packages that will be actually part of the distribution, not development paths, like tests, benchmarks, etc.</p> <p>This path will be removed when calculating the package name for the found packages. <code>mypy</code> needs the package name to be able to do full import checking.</p>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.Config-functions","title":"Functions","text":""},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.Config.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Initialize the configuration object.</p> <p>This will add extra paths discovered in config files and other sources.</p> Source code in <code>src/frequenz/repo/config/nox/config.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Initialize the configuration object.\n\n    This will add extra paths discovered in config files and other sources.\n    \"\"\"\n    for path in _util.discover_paths():\n        if path not in self.extra_paths:\n            self.extra_paths.append(path)\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.Config.copy","title":"<code>copy()</code>","text":"<p>Create a new object as a copy of self.</p> RETURNS DESCRIPTION <code>Self</code> <p>The copy of self.</p> Source code in <code>src/frequenz/repo/config/nox/config.py</code> <pre><code>def copy(self, /) -&gt; Self:\n\"\"\"Create a new object as a copy of self.\n\n    Returns:\n        The copy of self.\n    \"\"\"\n    return _dataclasses.replace(self)\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.Config.package_args","title":"<code>package_args(session)</code>","text":"<p>Return the package names to run the checks on.</p> <p>If positional arguments are present in the nox session, those are used as the file paths verbatim, and if not, all existing <code>source_paths</code> are searched for python packges by looking for <code>__init__.py</code> files. <code>extra_paths</code> are used as is, only converting the paths to python package names (replacing <code>/</code> with <code>.</code> and removing the suffix <code>.pyi?</code> if it exists.</p> PARAMETER DESCRIPTION <code>session</code> <p>The nox session to use to look for command-line arguments.</p> <p> TYPE: <code>_nox.Session</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>The package names found in the <code>source_paths</code>.</p> Source code in <code>src/frequenz/repo/config/nox/config.py</code> <pre><code>def package_args(self, session: _nox.Session, /) -&gt; list[str]:\n\"\"\"Return the package names to run the checks on.\n\n    If positional arguments are present in the nox session, those are used\n    as the file paths verbatim, and if not, all **existing** `source_paths`\n    are searched for python packges by looking for `__init__.py` files.\n    `extra_paths` are used as is, only converting the paths to python\n    package names (replacing `/` with `.` and removing the suffix `.pyi?`\n    if it exists.\n\n    Args:\n        session: The nox session to use to look for command-line arguments.\n\n    Returns:\n        The package names found in the `source_paths`.\n    \"\"\"\n    if session.posargs:\n        return session.posargs\n\n    sources_package_dirs_with_roots = (\n        (p, _util.find_toplevel_package_dirs(p))\n        for p in _util.existing_paths(self.source_paths)\n    )\n\n    source_packages = (\n        _util.path_to_package(pkg_path, root=root)\n        for root, pkg_paths in sources_package_dirs_with_roots\n        for pkg_path in pkg_paths\n    )\n\n    extra_packages = (\n        _util.path_to_package(p) for p in _util.existing_paths(self.extra_paths)\n    )\n\n    return list(\n        _util.deduplicate(_itertools.chain(source_packages, extra_packages))\n    )\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.Config.path_args","title":"<code>path_args(session)</code>","text":"<p>Return the file paths to run the checks on.</p> <p>If positional arguments are present in the nox session, those are used as the file paths verbatim, and if not, all existing <code>source_paths</code> and <code>extra_paths</code> are used.</p> PARAMETER DESCRIPTION <code>session</code> <p>The nox session to use to look for command-line arguments.</p> <p> TYPE: <code>_nox.Session</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>The file paths to run the checks on.</p> Source code in <code>src/frequenz/repo/config/nox/config.py</code> <pre><code>def path_args(self, session: _nox.Session, /) -&gt; list[str]:\n\"\"\"Return the file paths to run the checks on.\n\n    If positional arguments are present in the nox session, those are used\n    as the file paths verbatim, and if not, all **existing** `source_paths`\n    and `extra_paths` are used.\n\n    Args:\n        session: The nox session to use to look for command-line arguments.\n\n    Returns:\n        The file paths to run the checks on.\n    \"\"\"\n    if session.posargs:\n        return session.posargs\n\n    return list(\n        str(p) for p in _util.existing_paths(self.source_paths + self.extra_paths)\n    )\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config-functions","title":"Functions","text":""},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.configure","title":"<code>frequenz.repo.config.nox.config.configure(conf, /, *, import_default_sessions=True)</code>","text":"<p>Configure nox using the provided configuration or repository type.</p> PARAMETER DESCRIPTION <code>conf</code> <p>The configuration to use to configure nox, or the repository type to use to configure nox.  The later will use the default configuration in <code>frequenz.repo.config.nox.default</code> for that type of repository.</p> <p> TYPE: <code>Config | RepositoryType</code> </p> <code>import_default_sessions</code> <p>Whether to import the default sessions or not. This is only necessary if you want to avoid using the default provided sessions and use your own.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/frequenz/repo/config/nox/config.py</code> <pre><code>def configure(\n    conf: Config | RepositoryType, /, *, import_default_sessions: bool = True\n) -&gt; None:\n\"\"\"Configure nox using the provided configuration or repository type.\n\n    Args:\n        conf: The configuration to use to configure nox, or the repository type to use\n            to configure nox.  The later will use the default configuration in\n            [`frequenz.repo.config.nox.default`][] for that type of repository.\n        import_default_sessions: Whether to import the default sessions or not.\n            This is only necessary if you want to avoid using the default provided\n            sessions and use your own.\n    \"\"\"\n    global _config  # pylint: disable=global-statement\n\n    # We need to make sure sessions are imported, otherwise they won't be visible to nox.\n    if import_default_sessions:\n        # pylint: disable=import-outside-toplevel,cyclic-import\n        from . import session as _\n\n    match conf:\n        case Config():\n            _config = conf\n        case RepositoryType() as repo_type:\n            # pylint: disable=import-outside-toplevel,cyclic-import\n            from . import default\n\n            match repo_type:\n                case RepositoryType.ACTOR:\n                    _config = default.actor_config\n                case RepositoryType.API:\n                    _config = default.api_config\n                case RepositoryType.APP:\n                    _config = default.app_config\n                case RepositoryType.LIB:\n                    _config = default.lib_config\n                case RepositoryType.MODEL:\n                    _config = default.model_config\n                case _ as unhandled:\n                    assert_never(unhandled)\n\n    _nox.options.sessions = _config.sessions\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.get","title":"<code>frequenz.repo.config.nox.config.get()</code>","text":"<p>Get the global configuration object.</p> <p>This will assert if <code>configure()</code> wasn't called before.</p> RETURNS DESCRIPTION <code>Config</code> <p>The global configuration object.</p> Source code in <code>src/frequenz/repo/config/nox/config.py</code> <pre><code>def get() -&gt; Config:\n\"\"\"Get the global configuration object.\n\n    This will assert if `configure()` wasn't called before.\n\n    Returns:\n        The global configuration object.\n    \"\"\"\n    assert _config is not None, \"You must call configure() before using this function\"\n    return _config\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/default/","title":"default","text":""},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default","title":"<code>frequenz.repo.config.nox.default</code>","text":"<p>Default nox configuration for different types of repositories.</p> <p>This module provides the default configuration for the different types of repositories defined by <code>frequenz.repo.config.RepositoryType</code>.</p> <p>The <code>actor_config</code>, <code>api_config</code>, <code>app_config</code>, <code>lib_config</code>, and <code>model_config</code> variables are the default configurations for libraries, APIs, actors and applications, respectively. The <code>common_config</code> variable is the default configuration for all types of repositories.</p> <p>The <code>actor_command_options</code>, <code>api_command_options</code>, <code>app_command_options</code>, <code>lib_command_options</code>, and <code>model_command_options</code> variables are the default command-line options for the same types of repositories, and the <code>common_command_options</code> variable is the default command-line options for all types of repositories.</p> <p>They can be modified before being passed to <code>nox.configure()</code> by using the <code>CommandsOptions.copy()</code> method.</p>"},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default.actor_command_options","title":"<code>frequenz.repo.config.nox.default.actor_command_options: _config.CommandsOptions = common_command_options.copy()</code>  <code>module-attribute</code>","text":"<p>Default command-line options for actors.</p>"},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default.actor_config","title":"<code>frequenz.repo.config.nox.default.actor_config: _config.Config = common_config.copy()</code>  <code>module-attribute</code>","text":"<p>Default configuration for actors.</p>"},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default.api_command_options","title":"<code>frequenz.repo.config.nox.default.api_command_options: _config.CommandsOptions = common_command_options.copy()</code>  <code>module-attribute</code>","text":"<p>Default command-line options for APIs.</p>"},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default.api_config","title":"<code>frequenz.repo.config.nox.default.api_config: _config.Config = dataclasses.replace(common_config, opts=api_command_options, source_paths=[], extra_paths=list(_util.replace(common_config.extra_paths, {'tests': 'pytests'})))</code>  <code>module-attribute</code>","text":"<p>Default configuration for APIs.</p> <p>Same as <code>common_config</code>, but with <code>source_paths</code> replacing <code>\"src\"</code> with <code>\"py\"</code> and <code>extra_paths</code> replacing <code>\"tests\"</code> with <code>\"pytests\"</code>.</p>"},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default.app_command_options","title":"<code>frequenz.repo.config.nox.default.app_command_options: _config.CommandsOptions = common_command_options.copy()</code>  <code>module-attribute</code>","text":"<p>Default command-line options for applications.</p>"},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default.app_config","title":"<code>frequenz.repo.config.nox.default.app_config: _config.Config = common_config.copy()</code>  <code>module-attribute</code>","text":"<p>Default configuration for applications.</p>"},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default.common_command_options","title":"<code>frequenz.repo.config.nox.default.common_command_options: _config.CommandsOptions = _config.CommandsOptions(black=['--check'], darglint=['-v2'], isort=['--diff', '--check'], mypy=['--install-types', '--namespace-packages', '--non-interactive', '--explicit-package-bases', '--strict'], pytest=['-W=all', '-vv'])</code>  <code>module-attribute</code>","text":"<p>Default command-line options for all types of repositories.</p>"},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default.common_config","title":"<code>frequenz.repo.config.nox.default.common_config = _config.Config(opts=common_command_options.copy(), sessions=['formatting', 'mypy', 'pylint', 'docstrings', 'pytest_min', 'pytest_max'], source_paths=['src'], extra_paths=['benchmarks', 'docs', 'examples', 'noxfile.py', 'tests'])</code>  <code>module-attribute</code>","text":"<p>Default configuration for all types of repositories.</p>"},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default.lib_command_options","title":"<code>frequenz.repo.config.nox.default.lib_command_options: _config.CommandsOptions = common_command_options.copy()</code>  <code>module-attribute</code>","text":"<p>Default command-line options for libraries.</p>"},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default.lib_config","title":"<code>frequenz.repo.config.nox.default.lib_config: _config.Config = common_config.copy()</code>  <code>module-attribute</code>","text":"<p>Default configuration for libraries.</p>"},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default.model_command_options","title":"<code>frequenz.repo.config.nox.default.model_command_options: _config.CommandsOptions = common_command_options.copy()</code>  <code>module-attribute</code>","text":"<p>Default command-line options for models.</p>"},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default.model_config","title":"<code>frequenz.repo.config.nox.default.model_config: _config.Config = common_config.copy()</code>  <code>module-attribute</code>","text":"<p>Default configuration for models.</p>"},{"location":"reference/frequenz/repo/config/nox/session/","title":"session","text":""},{"location":"reference/frequenz/repo/config/nox/session/#frequenz.repo.config.nox.session","title":"<code>frequenz.repo.config.nox.session</code>","text":"<p>Predefined nox sessions.</p> <p>This module defines the predefined nox sessions that are used by the default.</p>"},{"location":"reference/frequenz/repo/config/nox/session/#frequenz.repo.config.nox.session-functions","title":"Functions","text":""},{"location":"reference/frequenz/repo/config/nox/session/#frequenz.repo.config.nox.session.ci_checks_max","title":"<code>frequenz.repo.config.nox.session.ci_checks_max(session)</code>","text":"<p>Run all checks with max dependencies in a single session.</p> <p>This is faster than running the checks separately, so it is suitable for CI.</p> <p>This does NOT run pytest_min, so that needs to be run separately as well.</p> PARAMETER DESCRIPTION <code>session</code> <p>the nox session.</p> <p> TYPE: <code>nox.Session</code> </p> Source code in <code>src/frequenz/repo/config/nox/session.py</code> <pre><code>@nox.session\ndef ci_checks_max(session: nox.Session) -&gt; None:\n\"\"\"Run all checks with max dependencies in a single session.\n\n    This is faster than running the checks separately, so it is suitable for CI.\n\n    This does NOT run pytest_min, so that needs to be run separately as well.\n\n    Args:\n        session: the nox session.\n    \"\"\"\n    session.install(\"-e\", \".[dev]\")\n\n    formatting(session, False)\n    mypy(session, False)\n    pylint(session, False)\n    docstrings(session, False)\n    pytest_max(session, False)\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/session/#frequenz.repo.config.nox.session.docstrings","title":"<code>frequenz.repo.config.nox.session.docstrings(session, install_deps=True)</code>","text":"<p>Check docstring tone with pydocstyle and param descriptions with darglint.</p> PARAMETER DESCRIPTION <code>session</code> <p>the nox session.</p> <p> TYPE: <code>nox.Session</code> </p> <code>install_deps</code> <p>True if dependencies should be installed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/frequenz/repo/config/nox/session.py</code> <pre><code>@nox.session\ndef docstrings(session: nox.Session, install_deps: bool = True) -&gt; None:\n\"\"\"Check docstring tone with pydocstyle and param descriptions with darglint.\n\n    Args:\n        session: the nox session.\n        install_deps: True if dependencies should be installed.\n    \"\"\"\n    if install_deps:\n        session.install(\"-e\", \".[dev-docstrings]\")\n\n    conf = _config.get()\n    session.run(\"pydocstyle\", *conf.opts.pydocstyle, *conf.path_args(session))\n\n    # Darglint checks that function argument and return values are documented.\n    # This is needed only for the `src` dir, so we exclude the other top level\n    # dirs that contain code, unless some paths were specified by argument, in\n    # which case we use those untouched.\n    darglint_paths = session.posargs or filter(\n        # pylint: disable=fixme\n        # TODO: Make these exclusions configurable\n        lambda path: not (path.startswith(\"tests\") or path.startswith(\"benchmarks\")),\n        conf.path_args(session),\n    )\n    session.run(\"darglint\", *conf.opts.darglint, *darglint_paths)\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/session/#frequenz.repo.config.nox.session.formatting","title":"<code>frequenz.repo.config.nox.session.formatting(session, install_deps=True)</code>","text":"<p>Check code formatting with black and isort.</p> PARAMETER DESCRIPTION <code>session</code> <p>the nox session.</p> <p> TYPE: <code>nox.Session</code> </p> <code>install_deps</code> <p>True if dependencies should be installed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/frequenz/repo/config/nox/session.py</code> <pre><code>@nox.session\ndef formatting(session: nox.Session, install_deps: bool = True) -&gt; None:\n\"\"\"Check code formatting with black and isort.\n\n    Args:\n        session: the nox session.\n        install_deps: True if dependencies should be installed.\n    \"\"\"\n    if install_deps:\n        session.install(\"-e\", \".[dev-formatting]\")\n\n    conf = _config.get()\n    session.run(\"black\", *conf.opts.black, *conf.path_args(session))\n    session.run(\"isort\", *conf.opts.isort, *conf.path_args(session))\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/session/#frequenz.repo.config.nox.session.mypy","title":"<code>frequenz.repo.config.nox.session.mypy(session, install_deps=True)</code>","text":"<p>Check type hints with mypy.</p> PARAMETER DESCRIPTION <code>session</code> <p>the nox session.</p> <p> TYPE: <code>nox.Session</code> </p> <code>install_deps</code> <p>True if dependencies should be installed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/frequenz/repo/config/nox/session.py</code> <pre><code>@nox.session\ndef mypy(session: nox.Session, install_deps: bool = True) -&gt; None:\n\"\"\"Check type hints with mypy.\n\n    Args:\n        session: the nox session.\n        install_deps: True if dependencies should be installed.\n    \"\"\"\n    if install_deps:\n        # install the package itself as editable, so that it is possible to do\n        # fast local tests with `nox -R -e mypy`.\n        session.install(\"-e\", \".[dev-mypy]\")\n\n    conf = _config.get()\n    pkg_args = _util.flatten((\"-p\", p) for p in conf.package_args(session))\n    session.run(\"mypy\", *conf.opts.mypy, *pkg_args)\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/session/#frequenz.repo.config.nox.session.pylint","title":"<code>frequenz.repo.config.nox.session.pylint(session, install_deps=True)</code>","text":"<p>Check for code smells with pylint.</p> PARAMETER DESCRIPTION <code>session</code> <p>the nox session.</p> <p> TYPE: <code>nox.Session</code> </p> <code>install_deps</code> <p>True if dependencies should be installed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/frequenz/repo/config/nox/session.py</code> <pre><code>@nox.session\ndef pylint(session: nox.Session, install_deps: bool = True) -&gt; None:\n\"\"\"Check for code smells with pylint.\n\n    Args:\n        session: the nox session.\n        install_deps: True if dependencies should be installed.\n    \"\"\"\n    if install_deps:\n        # install the package itself as editable, so that it is possible to do\n        # fast local tests with `nox -R -e pylint`.\n        session.install(\"-e\", \".[dev-pylint]\")\n\n    conf = _config.get()\n    session.run(\"pylint\", *conf.opts.pylint, *conf.path_args(session))\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/session/#frequenz.repo.config.nox.session.pytest_max","title":"<code>frequenz.repo.config.nox.session.pytest_max(session, install_deps=True)</code>","text":"<p>Test the code against max dependency versions with pytest.</p> PARAMETER DESCRIPTION <code>session</code> <p>the nox session.</p> <p> TYPE: <code>nox.Session</code> </p> <code>install_deps</code> <p>True if dependencies should be installed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/frequenz/repo/config/nox/session.py</code> <pre><code>@nox.session\ndef pytest_max(session: nox.Session, install_deps: bool = True) -&gt; None:\n\"\"\"Test the code against max dependency versions with pytest.\n\n    Args:\n        session: the nox session.\n        install_deps: True if dependencies should be installed.\n    \"\"\"\n    if install_deps:\n        # install the package itself as editable, so that it is possible to do\n        # fast local tests with `nox -R -e pytest_max`.\n        session.install(\"-e\", \".[dev-pytest]\")\n\n    _pytest_impl(session, \"max\")\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/session/#frequenz.repo.config.nox.session.pytest_min","title":"<code>frequenz.repo.config.nox.session.pytest_min(session, install_deps=True)</code>","text":"<p>Test the code against min dependency versions with pytest.</p> PARAMETER DESCRIPTION <code>session</code> <p>the nox session.</p> <p> TYPE: <code>nox.Session</code> </p> <code>install_deps</code> <p>True if dependencies should be installed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>src/frequenz/repo/config/nox/session.py</code> <pre><code>@nox.session\ndef pytest_min(session: nox.Session, install_deps: bool = True) -&gt; None:\n\"\"\"Test the code against min dependency versions with pytest.\n\n    Args:\n        session: the nox session.\n        install_deps: True if dependencies should be installed.\n    \"\"\"\n    if install_deps:\n        # install the package itself as editable, so that it is possible to do\n        # fast local tests with `nox -R -e pytest_min`.\n        session.install(\"-e\", \".[dev-pytest]\", *_util.min_dependencies())\n\n    _pytest_impl(session, \"min\")\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/util/","title":"util","text":""},{"location":"reference/frequenz/repo/config/nox/util/#frequenz.repo.config.nox.util","title":"<code>frequenz.repo.config.nox.util</code>","text":"<p>General purpose utilities.</p> <p>This module contains general purpose utilities that are used by the other modules in this package.</p>"},{"location":"reference/frequenz/repo/config/nox/util/#frequenz.repo.config.nox.util-functions","title":"Functions","text":""},{"location":"reference/frequenz/repo/config/nox/util/#frequenz.repo.config.nox.util.deduplicate","title":"<code>frequenz.repo.config.nox.util.deduplicate(iterable)</code>","text":"<p>Filter out duplicates from an iterable preserving the original iterable order.</p> PARAMETER DESCRIPTION <code>iterable</code> <p>The iterable to remove duplicates from.</p> <p> TYPE: <code>Iterable[_T]</code> </p> RETURNS DESCRIPTION <code>Iterable[_T]</code> <p>The elements of <code>iterable</code>, without duplicates but preserving order.</p> Source code in <code>src/frequenz/repo/config/nox/util.py</code> <pre><code>def deduplicate(iterable: Iterable[_T], /) -&gt; Iterable[_T]:\n\"\"\"Filter out duplicates from an iterable preserving the original iterable order.\n\n    Args:\n        iterable: The iterable to remove duplicates from.\n\n    Returns:\n        The elements of `iterable`, without duplicates but preserving order.\n    \"\"\"\n    # We can't use a set() here because sets don't preserve order.  We use this hack\n    # with dict.fromkeys() because dicts do preserve order in Python 3.7+.\n    return dict.fromkeys(iterable).keys()\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/util/#frequenz.repo.config.nox.util.discover_paths","title":"<code>frequenz.repo.config.nox.util.discover_paths()</code>","text":"<p>Discover paths to check.</p> <p>Discover the paths to check by looking into different sources, like the <code>pyproject.toml</code> file.</p> <p>Currently the following paths are discovered:</p> <ul> <li>The <code>testpaths</code> option in the <code>tools.pytest.ini_options</code> section of   <code>pyproject.toml</code>.</li> </ul> RETURNS DESCRIPTION <code>list[str]</code> <p>The discovered paths to check.</p> Source code in <code>src/frequenz/repo/config/nox/util.py</code> <pre><code>def discover_paths() -&gt; list[str]:\n\"\"\"Discover paths to check.\n\n    Discover the paths to check by looking into different sources, like the\n    `pyproject.toml` file.\n\n    Currently the following paths are discovered:\n\n    - The `testpaths` option in the `tools.pytest.ini_options` section of\n      `pyproject.toml`.\n\n    Returns:\n        The discovered paths to check.\n    \"\"\"\n    with open(\"pyproject.toml\", \"rb\") as toml_file:\n        data = _tomllib.load(toml_file)\n\n    testpaths: list[str] = (\n        data.get(\"tool\", {})\n        .get(\"pytest\", {})\n        .get(\"ini_options\", {})\n        .get(\"testpaths\", [])\n    )\n\n    return list(deduplicate(testpaths))\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/util/#frequenz.repo.config.nox.util.existing_paths","title":"<code>frequenz.repo.config.nox.util.existing_paths(paths)</code>","text":"<p>Filter paths to only leave valid paths that exist and are unique.</p> PARAMETER DESCRIPTION <code>paths</code> <p>The paths to check and filter.</p> <p> TYPE: <code>Iterable[str]</code> </p> RETURNS DESCRIPTION <code>Iterable[_pathlib.Path]</code> <p>An iterable with the valid paths as <code>pathlib.Path</code> objects.</p> Example <p>assert list(existing_paths([\".\", \"/fake\"])) == [pathlib.Path(\".\")]</p> Source code in <code>src/frequenz/repo/config/nox/util.py</code> <pre><code>def existing_paths(paths: Iterable[str], /) -&gt; Iterable[_pathlib.Path]:\n\"\"\"Filter paths to only leave valid paths that exist and are unique.\n\n    Args:\n        paths: The paths to check and filter.\n\n    Returns:\n        An iterable with the valid paths as `pathlib.Path` objects.\n\n    Example:\n        &gt;&gt;&gt; assert list(existing_paths([\".\", \"/fake\"])) == [pathlib.Path(\".\")]\n    \"\"\"\n    return deduplicate(p for p in map(_pathlib.Path, paths) if p.exists())\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/util/#frequenz.repo.config.nox.util.find_toplevel_package_dirs","title":"<code>frequenz.repo.config.nox.util.find_toplevel_package_dirs(path, /, *, root=None)</code>","text":"<p>Find top-level packages directories in a <code>path</code>.</p> <p>Searches recursively for the top-level packages in <code>path</code>, relative to <code>root</code>.</p> PARAMETER DESCRIPTION <code>path</code> <p>The path to look for python packages.</p> <p> TYPE: <code>_pathlib.Path</code> </p> <code>root</code> <p>The part of the path that is considered the root and will be removed from the resulting path. If <code>None</code> then <code>path</code> is used as <code>root</code>.</p> <p> TYPE: <code>_pathlib.Path | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Iterable[_pathlib.Path]</code> <p>The top-level paths that contains a <code>__init__.py</code> file, with <code>root</code></p> <code>Iterable[_pathlib.Path]</code> <p>removed.</p> <p>Examples:</p> <p>If we have a directory like the following:</p> <pre><code>.\n\u251c\u2500\u2500 noxfile.py\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 frequenz\n        \u2514\u2500\u2500 repo\n            \u2514\u2500\u2500 config\n                \u251c\u2500\u2500 __init__.py\n                \u251c\u2500\u2500 nox\n                \u2502\u00a0\u00a0 \u251c\u2500\u2500 config.py\n                \u2502\u00a0\u00a0 \u251c\u2500\u2500 default.py\n                \u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n                \u2502\u00a0\u00a0 \u251c\u2500\u2500 session.py\n                \u2502\u00a0\u00a0 \u2514\u2500\u2500 util.py\n                \u2514\u2500\u2500 setuptools.py\n</code></pre> <p>Then calling <code>find_toplevel_package_dirs(pathlib.Path(\"src\"))</code> will return an iterator producing: <code>[\"frequenz/repo/config\"]</code>.</p> Source code in <code>src/frequenz/repo/config/nox/util.py</code> <pre><code>def find_toplevel_package_dirs(\n    path: _pathlib.Path, /, *, root: _pathlib.Path | None = None\n) -&gt; Iterable[_pathlib.Path]:\n\"\"\"Find top-level packages directories in a `path`.\n\n    Searches recursively for the top-level packages in `path`, relative to\n    `root`.\n\n    Args:\n        path: The path to look for python packages.\n        root: The part of the path that is considered the root and will be\n            removed from the resulting path. If `None` then `path` is used as\n            `root`.\n\n    Returns:\n        The top-level paths that contains a `__init__.py` file, with `root`\n        removed.\n\n    Examples:\n        If we have a directory like the following:\n\n        ```\n        .\n        \u251c\u2500\u2500 noxfile.py\n        \u2514\u2500\u2500 src\n            \u2514\u2500\u2500 frequenz\n                \u2514\u2500\u2500 repo\n                    \u2514\u2500\u2500 config\n                        \u251c\u2500\u2500 __init__.py\n                        \u251c\u2500\u2500 nox\n                        \u2502\u00a0\u00a0 \u251c\u2500\u2500 config.py\n                        \u2502\u00a0\u00a0 \u251c\u2500\u2500 default.py\n                        \u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n                        \u2502\u00a0\u00a0 \u251c\u2500\u2500 session.py\n                        \u2502\u00a0\u00a0 \u2514\u2500\u2500 util.py\n                        \u2514\u2500\u2500 setuptools.py\n        ```\n\n        Then calling `find_toplevel_package_dirs(pathlib.Path(\"src\"))` will\n        return an iterator producing: `[\"frequenz/repo/config\"]`.\n    \"\"\"\n    if root is None:\n        root = path\n    # Bail out early if it is a directory with a __init__.py to avoid getting\n    # sub-packages\n    if (path / \"__init__.py\").exists():\n        return [path.relative_to(root)]\n    if path.is_dir():\n        return flatten(\n            [find_toplevel_package_dirs(p, root=root) for p in path.iterdir()]\n        )\n    return ()\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/util/#frequenz.repo.config.nox.util.flatten","title":"<code>frequenz.repo.config.nox.util.flatten(iterables)</code>","text":"<p>Flatten an iterable of iterables into one iterable with all the elements.</p> PARAMETER DESCRIPTION <code>iterables</code> <p>The iterables to flatten.</p> <p> TYPE: <code>Iterable[Iterable[_T]]</code> </p> RETURNS DESCRIPTION <code>Iterable[_T]</code> <p>The flattened iterable.</p> Example <p>assert list(flatten([(1, 2), (3, 4)]) == [1, 2, 3, 4]</p> Source code in <code>src/frequenz/repo/config/nox/util.py</code> <pre><code>def flatten(iterables: Iterable[Iterable[_T]], /) -&gt; Iterable[_T]:\n\"\"\"Flatten an iterable of iterables into one iterable with all the elements.\n\n    Args:\n        iterables: The iterables to flatten.\n\n    Returns:\n        The flattened iterable.\n\n    Example:\n        &gt;&gt;&gt; assert list(flatten([(1, 2), (3, 4)]) == [1, 2, 3, 4]\n    \"\"\"\n    return (item for sublist in iterables for item in sublist)\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/util/#frequenz.repo.config.nox.util.is_python_file","title":"<code>frequenz.repo.config.nox.util.is_python_file(path)</code>","text":"<p>Check if a path is a Python file.</p> PARAMETER DESCRIPTION <code>path</code> <p>The path to check.</p> <p> TYPE: <code>_pathlib.Path</code> </p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the path is a Python file, <code>False</code> otherwise.</p> Source code in <code>src/frequenz/repo/config/nox/util.py</code> <pre><code>def is_python_file(path: _pathlib.Path, /) -&gt; bool:\n\"\"\"Check if a path is a Python file.\n\n    Args:\n        path: The path to check.\n\n    Returns:\n        `True` if the path is a Python file, `False` otherwise.\n    \"\"\"\n    return path.suffix in (\".py\", \".pyi\")\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/util/#frequenz.repo.config.nox.util.min_dependencies","title":"<code>frequenz.repo.config.nox.util.min_dependencies()</code>","text":"<p>Extract the minimum dependencies from pyproject.toml.</p> RETURNS DESCRIPTION <code>list[str]</code> <p>The minimun dependencies defined in pyproject.toml.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If minimun dependencies are not properly set in pyproject.toml.</p> Source code in <code>src/frequenz/repo/config/nox/util.py</code> <pre><code>def min_dependencies() -&gt; list[str]:\n\"\"\"Extract the minimum dependencies from pyproject.toml.\n\n    Returns:\n        The minimun dependencies defined in pyproject.toml.\n\n    Raises:\n        RuntimeError: If minimun dependencies are not properly set in pyproject.toml.\n    \"\"\"\n    with open(\"pyproject.toml\", \"rb\") as toml_file:\n        data = _tomllib.load(toml_file)\n\n    min_deps: list[str] = []\n\n    dependencies = data.get(\"project\", {}).get(\"dependencies\", {})\n    if not dependencies:\n        return min_deps\n\n    for dep in dependencies:\n        min_dep = dep.split(\",\")[0]\n        if any(op in min_dep for op in (\"&gt;=\", \"==\")):\n            min_deps.append(min_dep.replace(\"&gt;=\", \"==\"))\n        else:\n            raise RuntimeError(f\"Minimum requirement is not set: {dep}\")\n    return min_deps\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/util/#frequenz.repo.config.nox.util.path_to_package","title":"<code>frequenz.repo.config.nox.util.path_to_package(path, root=None)</code>","text":"<p>Convert paths to Python package names.</p> <p>Paths should exist and be either a directory or a file ending with <code>.pyi?</code> (otherwise this function will assert). The <code>root</code> and <code>path</code> are concatenated when performing the check.</p> <p>Directory separators in <code>path</code> are replaced with <code>.</code> and the <code>.pyi?</code> suffix is removed (if present).</p> PARAMETER DESCRIPTION <code>path</code> <p>The path to convert.</p> <p> TYPE: <code>_pathlib.Path</code> </p> <code>root</code> <p>The root where the path is located. If <code>None</code>, then it is considered present in the current working directory.</p> <p> TYPE: <code>_pathlib.Path | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The package name based on <code>path</code>.</p> <p>Examples:</p> <ul> <li><code>src/frequenz/pkg</code> (<code>root=\"src\"</code>) will be converted to <code>frequenz.pkg</code>.</li> <li><code>noxfile.py</code> (without <code>root</code>) will be converted to <code>noxfile</code>.</li> </ul> Source code in <code>src/frequenz/repo/config/nox/util.py</code> <pre><code>def path_to_package(path: _pathlib.Path, root: _pathlib.Path | None = None) -&gt; str:\n\"\"\"Convert paths to Python package names.\n\n    Paths should exist and be either a directory or a file ending with `.pyi?`\n    (otherwise this function will assert). The `root` and `path` are\n    concatenated when performing the check.\n\n    Directory separators in `path` are replaced with `.` and the `.pyi?` suffix\n    is removed (if present).\n\n    Args:\n        path: The path to convert.\n        root: The root where the path is located. If `None`, then it is\n            considered present in the current working directory.\n\n    Returns:\n        The package name based on `path`.\n\n    Examples:\n        * `src/frequenz/pkg` (`root=\"src\"`) will be converted to `frequenz.pkg`.\n        * `noxfile.py` (without `root`) will be converted to `noxfile`.\n    \"\"\"\n    real_path = path\n    if root is not None:\n        real_path = root / path\n    assert real_path.is_dir() or is_python_file(real_path)\n\n    if is_python_file(real_path):\n        path = path.with_suffix(\"\")\n    return path.as_posix().replace(\"/\", \".\")\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/util/#frequenz.repo.config.nox.util.replace","title":"<code>frequenz.repo.config.nox.util.replace(iterable, replacements)</code>","text":"<p>Replace elements in an iterable.</p> PARAMETER DESCRIPTION <code>iterable</code> <p>The iterable to replace elements in.</p> <p> TYPE: <code>Iterable[_T]</code> </p> <code>replacements</code> <p>A mapping of elements to replace with other elements.</p> <p> TYPE: <code>Mapping[_T, _T]</code> </p> YIELDS DESCRIPTION <code>Iterable[_T]</code> <p>The next element in the iterable, with the replacements applied.</p> Example <p>assert list(replace([1, 2, 3], {1: 4, 2: 5})) == [4, 5, 3]</p> Source code in <code>src/frequenz/repo/config/nox/util.py</code> <pre><code>def replace(iterable: Iterable[_T], replacements: Mapping[_T, _T], /) -&gt; Iterable[_T]:\n\"\"\"Replace elements in an iterable.\n\n    Args:\n        iterable: The iterable to replace elements in.\n        replacements: A mapping of elements to replace with other elements.\n\n    Yields:\n        The next element in the iterable, with the replacements applied.\n\n    Example:\n        &gt;&gt;&gt; assert list(replace([1, 2, 3], {1: 4, 2: 5})) == [4, 5, 3]\n    \"\"\"\n    for item in iterable:\n        if item in replacements:\n            yield replacements[item]\n        else:\n            yield item\n</code></pre>"},{"location":"reference/frequenz/repo/config/setuptools/","title":"setuptools","text":""},{"location":"reference/frequenz/repo/config/setuptools/#frequenz.repo.config.setuptools","title":"<code>frequenz.repo.config.setuptools</code>","text":"<p>Setuptools utilities.</p>"},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/","title":"grpc_tools","text":""},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools","title":"<code>frequenz.repo.config.setuptools.grpc_tools</code>","text":"<p>Setuptool hooks to build protobuf files.</p> <p>This module contains a setuptools command that can be used to compile protocol buffer files in a project.</p> <p>It also runs the command as the first sub-command for the build command, so protocol buffer files are compiled automatically before the project is built.</p>"},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools-classes","title":"Classes","text":""},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools.CompileProto","title":"<code>frequenz.repo.config.setuptools.grpc_tools.CompileProto</code>","text":"<p>         Bases: <code>_setuptools.Command</code></p> <p>Build the Python protobuf files.</p> Source code in <code>src/frequenz/repo/config/setuptools/grpc_tools.py</code> <pre><code>class CompileProto(_setuptools.Command):\n\"\"\"Build the Python protobuf files.\"\"\"\n\n    proto_path: str\n\"\"\"The path of the root directory containing the protobuf files.\"\"\"\n\n    proto_glob: str\n\"\"\"The glob pattern to use to find the protobuf files.\"\"\"\n\n    include_paths: str\n\"\"\"Comma-separated list of paths to include when compiling the protobuf files.\"\"\"\n\n    py_path: str\n\"\"\"The path of the root directory where the Python files will be generated.\"\"\"\n\n    description: str = \"compile protobuf files\"\n\"\"\"Description of the command.\"\"\"\n\n    user_options: list[tuple[str, str | None, str]] = [\n        (\n            \"proto-path=\",\n            None,\n            \"path of the root directory containing the protobuf files\",\n        ),\n        (\"proto-glob=\", None, \"glob pattern to use to find the protobuf files\"),\n        (\n            \"include-paths=\",\n            None,\n            \"comma-separated list of paths to include when compiling the protobuf files\",\n        ),\n        (\n            \"py-path=\",\n            None,\n            \"path of the root directory where the Python files will be generated\",\n        ),\n    ]\n\"\"\"Options of the command.\"\"\"\n\n    def initialize_options(self) -&gt; None:\n\"\"\"Initialize options.\"\"\"\n        config = _protobuf.ProtobufConfig.from_pyproject_toml()\n\n        self.proto_path = config.proto_path\n        self.proto_glob = config.proto_glob\n        self.include_paths = \",\".join(config.include_paths)\n        self.py_path = config.py_path\n\n    def finalize_options(self) -&gt; None:\n\"\"\"Finalize options.\"\"\"\n\n    def run(self) -&gt; None:\n\"\"\"Compile the Python protobuf files.\"\"\"\n        include_paths = self.include_paths.split(\",\")\n        proto_files = [\n            str(p) for p in _pathlib.Path(self.proto_path).rglob(self.proto_glob)\n        ]\n\n        if not proto_files:\n            print(\n                f\"No proto files found in {self.proto_path}/**/{self.proto_glob}/, \"\n                \"skipping compilation of proto files.\"\n            )\n            return\n\n        protoc_cmd = (\n            [_sys.executable, \"-m\", \"grpc_tools.protoc\"]\n            + [f\"-I{p}\" for p in [*include_paths, self.proto_path]]\n            + [\n                f\"--{opt}={self.py_path}\"\n                for opt in \"python_out grpc_python_out mypy_out mypy_grpc_out\".split()\n            ]\n            + proto_files\n        )\n\n        print(f\"Compiling proto files via: {' '.join(protoc_cmd)}\")\n        _subprocess.run(protoc_cmd, check=True)\n</code></pre>"},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools.CompileProto-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools.CompileProto.description","title":"<code>description: str = 'compile protobuf files'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Description of the command.</p>"},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools.CompileProto.include_paths","title":"<code>include_paths: str</code>  <code>instance-attribute</code>","text":"<p>Comma-separated list of paths to include when compiling the protobuf files.</p>"},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools.CompileProto.proto_glob","title":"<code>proto_glob: str</code>  <code>instance-attribute</code>","text":"<p>The glob pattern to use to find the protobuf files.</p>"},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools.CompileProto.proto_path","title":"<code>proto_path: str</code>  <code>instance-attribute</code>","text":"<p>The path of the root directory containing the protobuf files.</p>"},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools.CompileProto.py_path","title":"<code>py_path: str</code>  <code>instance-attribute</code>","text":"<p>The path of the root directory where the Python files will be generated.</p>"},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools.CompileProto.user_options","title":"<code>user_options: list[tuple[str, str | None, str]] = [('proto-path=', None, 'path of the root directory containing the protobuf files'), ('proto-glob=', None, 'glob pattern to use to find the protobuf files'), ('include-paths=', None, 'comma-separated list of paths to include when compiling the protobuf files'), ('py-path=', None, 'path of the root directory where the Python files will be generated')]</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Options of the command.</p>"},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools.CompileProto-functions","title":"Functions","text":""},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools.CompileProto.finalize_options","title":"<code>finalize_options()</code>","text":"<p>Finalize options.</p> Source code in <code>src/frequenz/repo/config/setuptools/grpc_tools.py</code> <pre><code>def finalize_options(self) -&gt; None:\n\"\"\"Finalize options.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools.CompileProto.initialize_options","title":"<code>initialize_options()</code>","text":"<p>Initialize options.</p> Source code in <code>src/frequenz/repo/config/setuptools/grpc_tools.py</code> <pre><code>def initialize_options(self) -&gt; None:\n\"\"\"Initialize options.\"\"\"\n    config = _protobuf.ProtobufConfig.from_pyproject_toml()\n\n    self.proto_path = config.proto_path\n    self.proto_glob = config.proto_glob\n    self.include_paths = \",\".join(config.include_paths)\n    self.py_path = config.py_path\n</code></pre>"},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools.CompileProto.run","title":"<code>run()</code>","text":"<p>Compile the Python protobuf files.</p> Source code in <code>src/frequenz/repo/config/setuptools/grpc_tools.py</code> <pre><code>def run(self) -&gt; None:\n\"\"\"Compile the Python protobuf files.\"\"\"\n    include_paths = self.include_paths.split(\",\")\n    proto_files = [\n        str(p) for p in _pathlib.Path(self.proto_path).rglob(self.proto_glob)\n    ]\n\n    if not proto_files:\n        print(\n            f\"No proto files found in {self.proto_path}/**/{self.proto_glob}/, \"\n            \"skipping compilation of proto files.\"\n        )\n        return\n\n    protoc_cmd = (\n        [_sys.executable, \"-m\", \"grpc_tools.protoc\"]\n        + [f\"-I{p}\" for p in [*include_paths, self.proto_path]]\n        + [\n            f\"--{opt}={self.py_path}\"\n            for opt in \"python_out grpc_python_out mypy_out mypy_grpc_out\".split()\n        ]\n        + proto_files\n    )\n\n    print(f\"Compiling proto files via: {' '.join(protoc_cmd)}\")\n    _subprocess.run(protoc_cmd, check=True)\n</code></pre>"}]}