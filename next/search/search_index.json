{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Frequenz Repository Configuration","text":""},{"location":"#introduction","title":"Introduction","text":"<p>This is a highly opinionated set of tools and configurations to set up a Python repository for Frequenz projects.</p> <p>It offers:</p> <ul> <li>Cookiecutter templates for scaffolding new projects</li> <li>Trivial build of <code>noxfile.py</code> with some predefined sessions that include all   common checks.</li> <li>Tools to build protobuf/grpc files as Python, including type information.</li> </ul>"},{"location":"#start-a-new-project","title":"Start a new project","text":"<p>To start a new project, you should first install Cookiecutter. It is normally available in any Linux distribution, but some have a very old version (for example, Ubuntu/Debian). You can check which version your distro has on Repology. You need at least version 2.1.0. To ensure you get an up-to-date version, you can always use <code>pip</code> and install it in a <code>venv</code>:</p> <pre><code>$ python -m venv cookiecutter\n$ cd cookiecutter\n$ . bin/activate\n[cookiecutter] $ pip install cookiecutter\nCollecting cookiecutter\n...\n</code></pre> <p>Then simply run Cookiecutter where you want to create the new project:</p> <pre><code>cookiecutter gh:frequenz-floss/frequenz-repo-config-python \\\n--directory=cookiecutter --checkout v0.6.2\n</code></pre> <p>This command will prompt you for the project type, name, and other configuration options, and it will generate the entire project for you in a new subdirectory.</p> <p>Warning</p> <p>This command needs to be typed literally!</p> <p><code>frequenz-floss/frequenz-repo-config-python</code> is the GitHub repository with the cookiecutter template that will be downloaded, and <code>--directory=cookiecutter</code> is needed because the cookiecutter template doesn't live at the top-level of that repository, but in a subdirectory called <code>cookiecutter</code>. The <code>--checkout</code> option is provided to use a template from a released version, otherwise the default (development) branch will be used.</p> <p>All information about your project will be prompted interactively by that command.</p> <p>After completing the project and fixing the <code>TODO</code>s, you can either amend the previous commit using <code>git commit --amend</code> or create a new commit for the changes using <code>git commit</code>.</p>"},{"location":"#template-variables-reference","title":"Template variables reference","text":"<ul> <li> <p><code>type</code>: The type of repository. It must be chosen from the list.</p> </li> <li> <p><code>name</code>: The name of the project. This will be used to build defaults for   other inputs, such as <code>title</code>, <code>python_package</code>, etc. It should be one word,   using only alphanumeric characters (and starting with a letter). It can   include also <code>_</code> and <code>-</code> which will be handled differently when building   other variables from it (replaced by spaces in titles for example).</p> </li> <li> <p><code>description</code>: A short description of the project. It will be used as the   description in the <code>README.md</code>, <code>pyproject.toml</code>, <code>mkdocs.yml</code>, etc.</p> </li> <li> <p><code>title</code>: A human-readable name or title for the project. It will be used in   the <code>README.md</code>, <code>CONTRIBUTING.md</code>, and other files to refer to the project,   as well as the site title in <code>mkdocs.yml</code>.</p> </li> <li> <p><code>keywords</code>: A comma-separated list of keywords that will be used in the   <code>pyproject.toml</code> file. If left untouched, it will use only some predefined   keywords. If anything else is entered, it will be added to the default   keywords.</p> </li> <li> <p><code>github_org</code>: The GitHub handle of the organization where the project will   reside. This will be used to generate links to the project on GitHub.</p> </li> <li> <p><code>license</code>: Currently, only two options are provided: <code>MIT</code>, which should be   used for open-source projects, and <code>Proprietary</code>, which should be used for   closed-source projects. This will be added to file headers and used as the   license in <code>pyproject.toml</code>.</p> </li> <li> <p><code>author_name</code>, <code>author_email</code>: The name and email address of the author of   the project. They will be used in the copyright notice in file headers and   as the author in <code>pyproject.toml</code>.</p> </li> <li> <p><code>python_package</code>: The Python package in which this project will reside. All   files provided by this project should be located in this package. This needs   to be a list of valid Python identifiers separated by dots. The source file   structure will be derived from this. For example, <code>frequenz.actor.example</code>   will generate files in <code>src/frequenz/actor/example</code>.</p> </li> <li> <p><code>pypi_package_name</code>: The name of the PyPI/wheel/distribution package. This   should be consistent with the <code>python_package</code>, usually replacing <code>.</code> with   <code>-</code>. For example, <code>frequenz-actor-example</code>.</p> </li> <li> <p><code>github_repo_name</code>: The handle of the GitHub repository where the project   will reside. This will be used to generate links to the project on GitHub and   as the top-level directory name.</p> </li> <li> <p><code>default_codeowners</code>: A space-separated list of GitHub teams (<code>@org/team</code>) or   users (<code>@user</code>) that will be the default code owners for this project. This   will be used to build the <code>CODEOWNERS</code> file. Please refer to the code owners   documentation for more details on the valid syntax.</p> </li> </ul>"},{"location":"#create-the-local-development-environment","title":"Create the local development environment","text":"<p>To start development, you need to make sure your environment is correctly set up. One way to do this is by using a virtual environment and installing all the dependencies there:</p> <pre><code># requires at least Python version 3.11\npython3 -m venv .venv\n. .venv/bin/activate\npip install -e .[dev]\n</code></pre> <p>This will install your package in editable mode, so you can open a Python interpreter and import your package modules, picking up any local changes without the need to reinstall. Now you can run tools directly, like <code>pytest</code>.</p>"},{"location":"#verify-the-new-repository-is-healthy-using-nox","title":"Verify the new repository is healthy using <code>nox</code>","text":"<p>If you prefer to keep your virtual environment cleaner and avoid installing development dependencies, you can also use <code>nox</code> to create isolated environments:</p> <pre><code>pip install -e .[dev-noxfile]\nnox --install-only  # Set up virtual environments once\nnox -R  # Run linting and testing reusing the existing virtual environments\n</code></pre> <p>This will only install your package in editable mode and the minimum dependencies required to run <code>nox</code>. It will then run all <code>nox</code> default sessions, which include running linters and tests.</p> <p>Note</p> <p>It's much faster to use <code>nox</code> with <code>--install-only</code> once (each time you change or update dependencies, you need to run it again) and then use <code>nox -R</code> to run the sessions without recreating the virtual environments.</p> <p>Otherwise, <code>nox</code> will create many virtual environments each time you run it, which is very slow.</p>"},{"location":"#configure-the-release-notes-check-github-workflow","title":"Configure the release notes check GitHub workflow","text":"<p>By default a workflow to check if the release notes were updated is included. This workflow will check PRs to see if a change was done in the <code>src/</code> directory, and if so, it will fail if the <code>RELEASE_NOTES.md</code> wasn't also updated.</p> <p>But this check will not be enforced unless some extra configuration is done. To enforce the check for PRs to be merged you need to go to the GitHub repository -&gt; Settings -&gt; Branches and select the rule for the branch you want to protect.</p> <p>Then in the rules search for the Require status checks to pass before merging checkbox and search for \"Check release notes are updated\" in the search box.</p> <p>As sometimes it is OK for PRs not to have release notes, as maybe some changes don't impact the end user, this workflow can be overridden by assigning the label <code>cmd:skip-release-notes</code> to the PR. To be able to do this, you also need to add that label to the repository.</p> <p>You can do this from the GitHub web interface, or using one of the following commands:</p> <pre><code>repo=...  # org/repo\ntoken=... # GitHub token with the correct permissions\nname=\"cmd:skip-release-notes\"\ndesc=\"It is not necessary to update release notes for this PR\"\ncolor=\"930F79\"\n# Using cURL\ncurl -L \\\n-X POST \\\n-H \"Accept: application/vnd.github+json\" \\\n-H \"Authorization: Bearer $token\" \\\n-H \"X-GitHub-Api-Version: 2022-11-28\" \\\n-d '{\"name\":\"'\"$name\"'\",\"description\":\"'\"$desc\"'\",\"color\":\"'\"$color\"'\"}' \\\n\"https://api.github.com/repos/$repo/labels\"\n# Using the gh tool (no need for a token if you already have it configured)\ngh api -X POST \\\n-f name=\"$name\" -f description=\"$desc\" -f color=\"$color\" \\\n\"repos/$repo/labels\"\n</code></pre>"},{"location":"#verify-the-generated-documentation-works","title":"Verify the generated documentation works","text":"<p>To generate the documentation, you can use <code>mkdocs</code>:</p> <pre><code>pip install .[dev-mkdocs]  # Not necessary if you already installed .[dev]\nmkdocs serve\n</code></pre> <p>If the command fails, look at the log warnings and errors and fix them. If it worked, now there is a local web server serving the documentation. You can point your browser to http://127.0.0.1:8000 to have a look.</p> <p>Info</p> <p>For API projects, <code>docker</code> is needed to generate and serve documentation, as the easiest way to use the tool to generate the documentation from <code>.proto</code> files is using <code>docker</code>.</p>"},{"location":"#initialize-the-github-pages-website","title":"Initialize the GitHub Pages website","text":"<p>The generated documentation can be easily published via GitHub Pages, and it will be automatically updated for new pushes and releases. However, some initial setup is needed for it to work correctly:</p> <pre><code>pip install -e .[dev-mkdocs]  # Not necessary if you already installed .[dev]\nmike deploy --update-aliases next latest  # Creates the branch gh-pages locally\nmike set-default latest  # Makes the latest alias the default version\ngit push upstream gh-pages  # Pushes the new branch upstream to publish the website\n</code></pre> <p>Then make sure that GitHub Pages is enabled in <code>https://github.com/&lt;repo-owner&gt;/&lt;repo-name&gt;/settings/pages</code>.</p> <p>If all went well, your website should be available soon via <code>https://&lt;repo-owner&gt;.github.io/&lt;repo-name&gt;/</code>.</p>"},{"location":"#website-versions-using-mike","title":"Website versions using Mike","text":"<p>The above commands create a new documentation version using Mike, which is used to keep multiple versions of the website.</p> <p>The new documentation version is called <code>next</code>, which is used as the name for the currently in-development branch. The <code>next</code> branch has an alias called <code>latest</code>, which is set as the default.</p> <p>If the website is visited without specifying an explicit version, the <code>latest</code> version will be displayed. It is recommended to point <code>latest</code> to the latest stable version instead of the currently in-devepoment version, so as soon as you make a release, you should update the alias.</p>"},{"location":"#auto-generation-of-pages-via-github-actions","title":"Auto-generation of pages via GitHub Actions","text":"<p>New versions of the documentation will be automatically generated and published via GitHub Actions on any push.</p> <p>If a push is to a branch with semver-like format (vX.Y.Z), then the generated version will replace the current <code>next</code> version.</p> <p>If a tag is pushed instead, then the generated version will replace the current <code>vX.Y</code> version (if there was any), and the aliases <code>vX</code> and <code>latest</code> will be updated to point to the new version.</p> <p>To summarize, we don't create versions for patch releases, only for minor versions, and we have an alias to point to the latest version of a major version too.</p>"},{"location":"#migrate-an-existing-project","title":"Migrate an existing project","text":"<p>The easiest way to migrate an existing project is to generate a new one based on the current project metadata and then overwrite the existing files.</p> <p>It is recommended to commit all changes before doing this, so you can then use <code>git</code> to look at the changes.</p> <p>If you generate the new repo in a temporary directory, you can easily overwrite the files in your existing project by using <code>rsync</code> or similar tools:</p> <pre><code>cd /tmp\ncookiecutter gh:frequenz-floss/frequenz-repo-config-python \\\n--directory=cookiecutter --checkout v0.6.2\nrsync -vr --exclude=.git/ new-project/ /path/to/existing/project\ncd /path/to/existing/project\ngit diff\n# Fix all the `TODO`s and clean up the generated files\ngit commit -a\n</code></pre> <p>Warning</p> <p>The trailing slash in <code>new-project/</code> and the lack of it in <code>/path/to/existing/project</code> are meaningful to <code>rsync</code>.</p> <p>Also, make sure to exclude the <code>.git/</code> directory to avoid messing up with your local Git repository.</p> <p>Tip</p> <p>Please have a look at the follow-up steps listed in the Start a new project section to finish the setup.</p>"},{"location":"#update-an-existing-project","title":"Update an existing project","text":"<p>To update an existing project, you can use the Cookiecutter replay file that was saved during the project generation. The file is saved as <code>.cookiecutter-replay.json</code>. Using this file, you can re-run Cookiecutter without having to enter all the inputs again.</p> <p>Warning</p> <ul> <li>Don't forget to commit all changes in your repository before doing this!   Files will be overwritten!</li> <li>Don't forget to check all the release   notes   for all the versions you are going to update, in particular the   Upgrading section, as there might be steps necessary before even   running the <code>cookiecutter</code> command for the update.</li> </ul> <pre><code>git commit -a  # commit all changes\ncd ..\ncookiecutter gh:frequenz-floss/frequenz-repo-config-python \\\n--directory=cookiecutter \\\n--checkout v0.6.2 \\\n--overwrite-if-exists \\\n--replay \\\n--replay-file project-directory/.cookiecutter-replay.json\n</code></pre> <p>This will create a new commit with all the changes to the overwritten files. Bear in mind that all the <code>TODO</code>s will come back, so there will be quite a bit of cleanup to do. You can easily check what was changed using <code>git show</code>, and you can use <code>git commit --amend</code> to amend the previous commit with the template updates, or create a new commit with the fixes. You can also use <code>git citool</code> or <code>git gui</code> to easily add, remove, or even discard (revert) changes in the templates update commit.</p> <p>Note</p> <p>The <code>project-directory</code> is the directory of your previously generated project. If you renamed it, then the files will be generated in a new directory with the original name. You can update the target directory in the replay file.</p> <p>Note</p> <p>Please remember to keep your replay file up to date if you change any metadata in the project.</p> <p>Tip</p> <p>Please have a look at the follow-up steps listed in the Start a new project section to finish the setup.</p>"},{"location":"#advanced-usage","title":"Advanced usage","text":"<p>The Cookiecutter template uses some tools provided as a library by this project.</p> <p>Usually, users don't need to deal with it directly, but if your project needs some extra customization (like disabling <code>nox</code> sessions or adding new ones, or using different CLI options for some tools), then you'll need to.</p> <p>You can find information about the extra features in the API reference.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to Frequenz Repository Configuration","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#golden-tests","title":"Golden Tests","text":"<p>To test the generated files using the Cookiecutter templates, the golden testing technique is used to ensure that changes in the templates don't occur unexpectedly.</p> <p>If a golden test fails, a <code>diff</code> of the contents will be provided in the test results.</p> <p>Failures in the golden tests could indicate two things:</p> <ol> <li> <p>The generated files don't match the golden files because an unintended    change was introduced. For example, there may be a bug that needs to be fixed    so that the generated files match the golden files again.</p> </li> <li> <p>The generated files don't match the golden files because an intended change    was introduced. In this case, the golden files need to be updated.</p> </li> </ol> <p>In the latter case, manually updating files is complicated and error-prone, so a simpler (though hacky) way is provided.</p> <p>To update the golden files, simply run <code>pytest</code> for the tests using golden files setting the environment variable <code>UPDATE_GOLDEN</code> to <code>1</code>:</p> <pre><code>UPDATE_GOLDEN=1 pytest tests/integration/test_cookiecutter_generation.py::test_golden\n</code></pre> <p>This will replace the existing golden files (stored in <code>tests_golden/</code>) with the newly generated files.</p> <p>Note that if you rename, or remove golden files, you should also manually remove the files that were affected. An easy way to make sure there are no old unused golden files left is to just wipe the whole <code>tests_golden/</code> directory before running <code>pytest</code> to generate the new ones.</p> <p>Please ensure that all introduced changes are intended before updating the golden files.</p>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>API Reference</li> <li>Contributing</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>repo<ul> <li>config<ul> <li>mkdocs</li> <li>nox<ul> <li>config</li> <li>default</li> <li>session</li> <li>util</li> </ul> </li> <li>protobuf</li> <li>pytest<ul> <li>examples</li> </ul> </li> <li>setuptools<ul> <li>grpc_tools</li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/frequenz/repo/config/","title":"Index","text":""},{"location":"reference/frequenz/repo/config/#frequenz.repo.config","title":"<code>frequenz.repo.config</code>","text":"<p>Frequenz project setup tools and common configuration.</p> <p>The tools are provided to configure the main types of repositories most commonly used at Frequenz, defined in <code>frequenz.repo.config.RepositoryType</code>.</p> <ul> <li>actor: SDK actors</li> <li>api: gRPC APIs</li> <li>app: SDK applications</li> <li>lib: General purpose Python libraries</li> <li>model: SDK machine learning models</li> </ul>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config--common","title":"Common","text":""},{"location":"reference/frequenz/repo/config/#frequenz.repo.config--nox-running-tests-and-linters","title":"<code>nox</code> (running tests and linters)","text":""},{"location":"reference/frequenz/repo/config/#frequenz.repo.config--writing-the-noxfilepy","title":"Writing the <code>noxfile.py</code>","text":"<p>Projects wanting to use <code>nox</code> to run lint checkers and other utilities can use the <code>frequenz.repo.config.nox</code> package.</p> <p>When writing the <code>noxfile.py</code> you should import the <code>nox</code> module from this package and use the <code>frequenz.repo.config.nox.configure</code> function, which will configure all nox sessions.</p> <p>To use the default options, you should call <code>configure()</code> using one of the repository types.  For example:</p> <pre><code>from frequenz.repo.config import RepositoryType, nox\nnox.configure(RepositoryType.LIB)\n</code></pre> <p>Again, make sure to pick the correct project typedefault configuration based on the type of your project (<code>actor_config</code>, <code>api_config</code>, <code>app_config</code>, <code>lib_config</code>, <code>model_config</code>).</p> <p>If you need to use some custom configuration, you can start from the default settings in the <code>frequenz.repo.config.nox.default</code> module, copying it and changing whatever you need to customize.  For example:</p> <pre><code>from frequenz.repo.config import nox\nfrom frequenz.repo.config.nox import default\nconfig = default.lib_config.copy()\nconfig.opts.black.append(\"--diff\")\nnox.configure(config)\n</code></pre> <p>Note</p> <p>When possible, it is recommended to define options in the <code>pyproject.toml</code> file (most tools can do this), so they can be consistently used even if the tool is used outside of <code>nox</code>.</p> <p>If you need further customization or to define new sessions, you can use the following modules:</p> <ul> <li> <p><code>frequenz.repo.config.nox.config</code>: Low-level utilities to configure nox   sessions. It defines the <code>Config</code> and CommandsOptions<code>classes and the actual   implementation of the</code>configure()<code>function. It also defines the</code>get()`   function, which can be used to get the currently used configuration object.</p> </li> <li> <p><code>frequenz.repo.config.nox.session</code>: Predefined nox sessions. These are   the sessions that are used by default.</p> </li> <li> <p><code>frequenz.repo.config.nox.util</code>: General purpose utility functions.</p> </li> </ul>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config--pyprojecttoml-configuration","title":"<code>pyproject.toml</code> configuration","text":"<p>All sessions configured by this package expect the <code>pyproject.toml</code> file to define specific dev dependencies that will be used by the different <code>nox</code> sessions.</p> <p>The following optional dependencies are used and must be defined:</p> <ul> <li><code>dev-flake8</code>: Dependencies to do flake8 lint, including the documentation.</li> </ul> <p>At least these packages should be included:</p> <ul> <li><code>pydocstyle</code>: To check the docstrings' format.</li> <li> <p><code>pydoclint</code>: To check the docstrings' content.</p> </li> <li> <p><code>dev-formatting</code>: Dependencies to check the code's formatting.</p> </li> </ul> <p>At least these packages should be included:</p> <ul> <li><code>black</code>: To check the code's formatting.</li> <li> <p><code>isort</code>: To check the imports' formatting.</p> </li> <li> <p><code>dev-mypy</code>: Dependencies to run <code>mypy</code> to check the code's type annotations.</p> </li> </ul> <p>At least these packages should be included:</p> <ul> <li> <p><code>mypy</code>: To check the code's type annotations.</p> </li> <li> <p><code>dev-pylint</code>: Dependencies to run <code>pylint</code> to lint the code.</p> </li> </ul> <p>At least these packages should be included:</p> <ul> <li> <p><code>pylint</code>: To lint the code.</p> </li> <li> <p><code>dev-pytest</code>: Dependencies to run the tests using <code>pytest</code>.</p> </li> </ul> <p>At least these packages should be included:</p> <ul> <li><code>pytest</code>: To run the tests.</li> </ul> <p>For some of these you should install too any other dependencies that are used by the project. For example, if the project uses <code>pytest-asyncio</code>, you should include it in the <code>dev-pytest</code> optional dependency.</p> <p>It is also recommended, but not required, to provide a global <code>dev</code> optional dependency that includes all the other optional dependencies, so users can install all the dependencies needed while developing the project without having to run <code>nox</code>, which might be a bit slow if you want to do quick iterations.</p> <pre><code>$ pip install -e .[dev]\n...\n$ pytest\n...\n</code></pre> <p>Here is a sample <code>pyproject.toml</code> file that defines all the optional dependencies:</p> <pre><code>[project]\nname = \"my-package\"\n# ...\n[project.optional-dependencies]\ndev-flake8 = [\n\"flake8 == 6.1.0\",\n\"flake8-docstrings == 1.7.0\",\n\"flake8-pyproject == 1.2.3\",  # For reading the flake8 config from pyproject.toml\n\"pydoclint == 0.3.1\",\n\"pydocstyle == 6.3.0\",\n]\ndev-formatting = [\"black == 23.3.0\", \"isort == 5.12.0\"]\ndev-mkdocs = [\n\"mike == 1.1.2\",\n\"mkdocs-gen-files == 0.5.0\",\n\"mkdocs-literate-nav == 0.6.0\",\n\"mkdocs-material == 9.1.16\",\n\"mkdocs-section-index == 0.3.5\",\n\"mkdocstrings[python] == 0.22.0\",\n]\ndev-mypy = [\n\"mypy == 1.1.1\",\n# For checking tests\n\"my-package[dev-mkdocs,dev-pytest]\",\n]\ndev-pylint = [\n\"pylint == 2.17.1\",\n\"pylint-google-style-guide-imports-enforcing == 1.3.0\",\n# For checking tests\n\"my-package[dev-mkdocs,dev-pytest]\",\n]\ndev-pytest = [\n\"pytest == 7.2.2\",\n\"pytest-asyncio == 0.21.0\",\n\"pytest-mock == 3.10.0\",\n]\ndev = [\n\"my-package[dev-mkdocs,dev-flake8,dev-formatting,dev-mypy,dev-nox,dev-pylint,dev-pytest]\",\n]\n</code></pre>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config--mypy-static-type-checking","title":"<code>mypy</code> (static type checking)","text":"<p>To configure <code>mypy</code> you can add the recommended options to the <code>pyproject.toml</code> file as follows:</p> <pre><code>[tool.mypy]\nexplicit_package_bases = true\nnamespace_packages = true\npackages = [\"your_package_name\"]  # Use the actual package name here\nstrict = true\n</code></pre> <p>You can just call <code>mypy</code> to check the package of your sources or you can use <code>mypy tests</code> to check the tests, for example.</p> <p>You might also need to extra optional dependencies to install type checking stubs for some packages.  For example for API projects you need the <code>grpc-stubs</code> package:</p> <pre><code>[project.optional-dependencies]\n# ...\ndev-mypy = [\n# ...\n\"grpc-stubs == 1.53.0.2\",\n# ...\n]\n</code></pre> <p>You can use <code>mypy --install-types</code> to install to get a list of missing stubs, <code>mypy</code> will list them for you and ask if you want to proceed with the installation.  You can answer no and copy the list of missing stubs to the <code>pyproject.toml</code> file.</p>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config--mkdocs-generating-documentation","title":"<code>mkdocs</code> (generating documentation)","text":""},{"location":"reference/frequenz/repo/config/#frequenz.repo.config--api-reference-generation","title":"API reference generation","text":"<p>The API documnentation can be automatically generated from the source files using the <code>frequenz.repo.config.mkdocs</code> package as when run as a <code>mkdocs-gen-files</code> plugin script.</p> <p>To enable it you just need to make sure the <code>mkdocs-gen-files</code>, <code>mkdocs-literate-nav</code> and <code>mkdocstrings[python]</code> packages are installed (look at the <code>pyproject.toml</code> configuration in the <code>nox</code> section) and add the following configuration to the <code>mkdocs.yml</code> file:</p> <pre><code>plugins:\n- gen-files:\nscripts:\n- path/to/my/custom/script.py\n</code></pre> <p>By default this script will look for files in the <code>src/</code> directory and generate the documentation files in the <code>python-reference/</code> directory inside <code>mkdocs</code> output directory (<code>site</code> by defaul).</p> <p>If you need to customize the above paths, you can create a new script to use with the <code>mkdocs-gen-files</code> plugin as follows:</p> <pre><code>from frequenz.repo.config import mkdocs\nmkdocs.generate_python_api_pages(\"my_sources\", \"API\")\n</code></pre> <p>Where <code>my_sources</code> is the directory containing the source files and <code>API</code> is the directory where to generate the documentation files (relative to <code>mkdocs</code> output directory).</p> <p>And then replace this configuration in the <code>mkdocs.yml</code> file:</p> <pre><code>plugins:\n- gen-files:\nscripts:\n- path/to/my/custom/script.py\n</code></pre>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config--pytest-running-tests","title":"<code>pytest</code> (running tests)","text":""},{"location":"reference/frequenz/repo/config/#frequenz.repo.config--linting-examples-in-the-source-codes-docstrings","title":"Linting examples in the source code's docstrings","text":"<p>To make sure the examples included in your source code's docstrings are valid, you can use <code>pytest</code> to automatically collect all the examples wrapped in triple backticks (<code>```python</code>) within our docstrings and validate them using <code>pylint</code>.</p> <p>To do so there is some setup that's needed:</p> <ol> <li> <p>Add a <code>conftest.py</code> file to the root directory containing your source code with the    following contents:</p> <pre><code>from frequenz.repo.config.pytest import examples\nfrom sybil import Sybil\npytest_collect_file = Sybil(**examples.get_sybil_arguments()).pytest()\n</code></pre> <p>Unfortunately, because of how Sybil works, the <code>Sybil</code> class needs to be instantiated in the <code>conftest.py</code> file. To easily do this, the convenience function <code>get_sybil_arguments()</code> is provided to get the arguments to pass to the <code>Sybil()</code> constructor to be able to collect and lint the examples.</p> </li> <li> <p>Add the following configuration to your <code>pyproject.toml</code> file (see    the <code>nox</code> section for details on how to configure    dependencies to play nicely with <code>nox</code>):</p> <pre><code>[project.optional-dependencies]\n# ...\ndev-pytest = [\n# ...\n\"frequenz-repo-config[extra-lint-examples] == 0.6.2\",\n]\n# ...\n[[tool.mypy.overrides]]\nmodule = [\n# ...\n\"sybil\",\n\"sybil.*\",\n]\nignore_missing_imports = true\n# ...\n[tool.pytest.ini_options]\ntestpaths = [\n# ...\n\"src\",\n]\n</code></pre> </li> </ol> <p>This will make sure that you have the appropriate dependencies installed to run the    the tests linting and that <code>mypy</code> doesn't complain about the <code>sybil</code> module not being    typed.</p> <ol> <li> <p>Exclude the <code>src/conftest.py</code> file from the distribution package, as it shouldn't be    shipped with the code, it is only for delelopment purposes. To do so, add the    following line to the <code>MANIFEST.in</code> file:</p> <pre><code># ...\nexclude src/conftest.py\n</code></pre> </li> </ol> <p>Now you should be able to run <code>nox -s pytest</code> (or <code>pytest</code> directly) and see the tests linting the examples in your code's docstrings.</p>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config--apis","title":"APIs","text":""},{"location":"reference/frequenz/repo/config/#frequenz.repo.config--protobuf-configuation","title":"Protobuf configuation","text":"<p>Support is provided to generate files from protobuf files.  To do this, it is possible to configure the options to use while generating the files for different purposes (language bindings, documentation, etc.).</p> <p>The configuration can be done in the <code>pyproject.toml</code> file as follows:</p> <pre><code>[tool.frequenz_repo_config.protobuf]\n# Location of the proto files relative to the root of the repository (default: \"proto\")\nproto_path = \"proto_files\"\n# Glob pattern to use to find the proto files in the proto_path (default: \"*.proto\")\nproto_glob = \"*.prt\"  # Default: \"*.proto\"\n# List of paths to pass to the protoc compiler as include paths (default:\n# [\"submodules/api-common-protos\", \"submodules/frequenz-api-common/proto\"])\ninclude_paths = [\"submodules/api-common-protos\"]\n# Path where to generate the Python files (default: \"py\")\npy_path = \"generated\"\n# Path where to generate the documentation files (default: \"protobuf-reference\")\ndocs_path = \"API\"\n</code></pre> <p>If the defaults are not suitable for you (for example you need to use more or less submodules or your proto files are located somewhere else), please adjust the configuration to match your project structure.</p>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config--mkdocs-api-reference-generation","title":"<code>mkdocs</code> API reference generation","text":"<p>If your project provides protobuf files, you can also generate the API documentation for them adding one more line to the script provided in the common section:</p> <pre><code>from frequenz.repo.config import mkdocs\nmkdocs.generate_python_api_pages(\"my_sources\", \"API-py\")\nmkdocs.generate_protobuf_api_pages()\n</code></pre> <p>This will use the configuration in the <code>pyproject.toml</code> file and requires <code>docker</code> to run (it uses the <code>pseudomuto/protoc-gen-doc</code> docker image.</p>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config--setuptools-grpc-support","title":"<code>setuptools</code> gRPC support","text":"<p>When configuring APIs it is assumed that they have a gRPC interface.</p> <p>The project structure is assumed to be as described in the Protobuf configuration section plus the following:</p> <ul> <li><code>pytests/</code>: Directory containing the tests for the Python code.</li> <li><code>submodules/api-common-protos</code>: Directory containing the Git submodule with the   <code>google/api-common-protos</code> repository.</li> <li><code>submodules/frequenz-api-common</code>: Directory containing the Git submodule with the   <code>frequenz-floss/frequenz-api-common</code> repository.</li> </ul> <p>Normally Frequenz APIs use basic types from <code>google/api-common-protos</code> and <code>frequenz-floss/frequenz-api-common</code>, so you need to make sure the proper submodules are added to your project:</p> <pre><code>mkdir submodules\ngit submodule add https://github.com/googleapis/api-common-protos.git \\\nsubmodules/api-common-protos\ngit submodule add https://github.com/frequenz-floss/frequenz-api-common.git \\\nsubmodules/frequenz-api-common\ngit commit -m \"Add api-common-protos and frequenz-api-common submodules\" submodules\n</code></pre> <p>Then you need to add this package as a build dependency and a few extra dependencies to your project, for example:</p> <pre><code>requires = [\n\"setuptools &gt;= 67.3.2, &lt; 68\",\n\"setuptools_scm[toml] &gt;= 7.1.0, &lt; 8\",\n\"frequenz-repo-config[api] &gt;= 0.6.2, &lt; 0.7.0\",\n]\nbuild-backend = \"setuptools.build_meta\"\n[project]\ndependencies = [\n\"frequenz-api-common &gt;= 0.2.0, &lt; 0.3.0\",\n\"googleapis-common-protos &gt;= 1.56.2, &lt; 2\",\n\"grpcio &gt;= 1.51.1, &lt; 2\",\n]\n</code></pre> <p>Note the <code>api</code> extra in <code>frequenz-repo-config[api]</code>, this will ensure all dependencies to build the protocol files will be installed when building the package. Of course you need to replace the version numbers with the correct ones too.</p> <p>You should also add the following configuration to your <code>pyproject.toml</code> file to make sure the generated files are included in the wheel:</p> <pre><code>[tool.setuptools.package-dir]\n\"\" = \"py\"\n[tool.setuptools.package-data]\n\"*\" = [\"*.pyi\"]\n[tools.pytest.ini_options]\ntestpaths = [\"pytests\"]\n</code></pre> <p>Finally you need to make sure to include the generated <code>*.pyi</code> files in the source distribution, as well as the Google api-common-protos files, as it is not handled automatically yet (#13). Make sure to include these lines in the <code>MANIFEST.in</code> file:</p> <pre><code>recursive-include submodules/api-common-protos/google *.proto\nrecursive-include submodules/frequenz-api-common/proto *.proto\n</code></pre> <p>Please adapt the instructions above to your project structure if you need to change the defaults.</p>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config-classes","title":"Classes","text":""},{"location":"reference/frequenz/repo/config/#frequenz.repo.config.RepositoryType","title":"<code>frequenz.repo.config.RepositoryType</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Supported types of repository.</p> Source code in <code></code> <pre><code>class RepositoryType(_enum.Enum):\n\"\"\"Supported types of repository.\"\"\"\nACTOR = \"actor\"\n\"\"\"SDK actor repository.\"\"\"\nAPI = \"api\"\n\"\"\"gRPC API repository.\"\"\"\nAPP = \"app\"\n\"\"\"SDK application repository.\"\"\"\nLIB = \"lib\"\n\"\"\"General purpose library repository.\"\"\"\nMODEL = \"model\"\n\"\"\"SDK machine learning model repository.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config.RepositoryType-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/repo/config/#frequenz.repo.config.RepositoryType.ACTOR","title":"<code>ACTOR = 'actor'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>SDK actor repository.</p>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config.RepositoryType.API","title":"<code>API = 'api'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>gRPC API repository.</p>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config.RepositoryType.APP","title":"<code>APP = 'app'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>SDK application repository.</p>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config.RepositoryType.LIB","title":"<code>LIB = 'lib'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>General purpose library repository.</p>"},{"location":"reference/frequenz/repo/config/#frequenz.repo.config.RepositoryType.MODEL","title":"<code>MODEL = 'model'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>SDK machine learning model repository.</p>"},{"location":"reference/frequenz/repo/config/mkdocs/","title":"mkdocs","text":""},{"location":"reference/frequenz/repo/config/mkdocs/#frequenz.repo.config.mkdocs","title":"<code>frequenz.repo.config.mkdocs</code>","text":"<p>Generate the code reference pages.</p> <p>It uses the following <code>mkdocs</code> plugins:</p> <ul> <li><code>mkdocs-gen-files</code> to generate the API documentation pages.</li> <li><code>mkdocs-literate-nav</code> to make use of the generate <code>SUMMARY.md</code> file.</li> </ul> <p>Based on the recipe at: https://mkdocstrings.github.io/recipes/#automatic-code-reference-pages</p>"},{"location":"reference/frequenz/repo/config/mkdocs/#frequenz.repo.config.mkdocs-functions","title":"Functions","text":""},{"location":"reference/frequenz/repo/config/mkdocs/#frequenz.repo.config.mkdocs.generate_protobuf_api_pages","title":"<code>frequenz.repo.config.mkdocs.generate_protobuf_api_pages(src_path='proto', dst_path='protobuf-reference')</code>","text":"<p>Generate API documentation pages for the code.</p> <p>Internal modules (those starting with an underscore except from <code>__init__</code>) are not included.</p> <p>A summary page is generated as <code>SUMMARY.md</code> which is compatible with the <code>mkdocs-literary-nav</code> plugin.</p> PARAMETER  DESCRIPTION <code>src_path</code> <p>Path where the code is located.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'proto'</code> </p> <code>dst_path</code> <p>Path where the documentation should be generated.  This is relative to the output directory of mkdocs.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'protobuf-reference'</code> </p> Source code in <code>frequenz/repo/config/mkdocs.py</code> <pre><code>def generate_protobuf_api_pages(\nsrc_path: str = \"proto\", dst_path: str = \"protobuf-reference\"\n) -&gt; None:\n\"\"\"Generate API documentation pages for the code.\n    Internal modules (those starting with an underscore except from `__init__`) are\n    not included.\n    A summary page is generated as `SUMMARY.md` which is compatible with the\n    `mkdocs-literary-nav` plugin.\n    Args:\n        src_path: Path where the code is located.\n        dst_path: Path where the documentation should be generated.  This is relative\n            to the output directory of mkdocs.\n    \"\"\"\n# type ignore because mkdocs_gen_files uses a very weird module-level\n# __getattr__() which messes up the type system\nnav = mkdocs_gen_files.Nav()  # type: ignore\nconfig = _protobuf.ProtobufConfig.from_pyproject_toml(\nproto_path=src_path, docs_path=dst_path\n)\ncwd = Path.cwd()\nwith tempfile.TemporaryDirectory(prefix=\"mkdocs-protobuf-reference-\") as tmp_path:\nfor path in sorted(Path(config.proto_path).rglob(\"*.proto\")):\ndoc_path = path.relative_to(config.proto_path).with_suffix(\".md\")\nfull_doc_path = Path(config.docs_path, doc_path)\nparts = tuple(path.relative_to(config.proto_path).parts)\nnav[parts] = doc_path.as_posix()\ndoc_tmp_path = tmp_path / doc_path\ndoc_tmp_path.parent.mkdir(parents=True, exist_ok=True)\ntry:\nsubprocess.run(\n[\n\"docker\",\n\"run\",\n\"--rm\",\nf\"-v{cwd}:{cwd}\",\nf\"-v{tmp_path}:{tmp_path}\",\n\"pseudomuto/protoc-gen-doc\",\nf\"-I{cwd / config.proto_path}\",\n*(f\"-I{cwd / p}\" for p in config.include_paths),\nf\"--doc_opt=markdown,{doc_path.name}\",\nf\"--doc_out={tmp_path / doc_path.parent}\",\nstr(cwd / path),\n],\ncheck=True,\n)\nexcept subprocess.CalledProcessError as error:\nprint(f\"Error generating protobuf reference page: {error}\")\nwith doc_tmp_path.open() as input_file, mkdocs_gen_files.open(\nfull_doc_path, \"w\"\n) as output_file:\noutput_file.write(input_file.read())\nmkdocs_gen_files.set_edit_path(full_doc_path, Path(\"..\") / path)\nwith mkdocs_gen_files.open(Path(config.docs_path) / \"SUMMARY.md\", \"w\") as nav_file:\nnav_file.writelines(nav.build_literate_nav())\n</code></pre>"},{"location":"reference/frequenz/repo/config/mkdocs/#frequenz.repo.config.mkdocs.generate_python_api_pages","title":"<code>frequenz.repo.config.mkdocs.generate_python_api_pages(src_path='src', dst_path='python-reference')</code>","text":"<p>Generate API documentation pages for the code.</p> <p>Internal modules (those starting with an underscore except from <code>__init__</code>) are not included.</p> <p>A summary page is generated as <code>SUMMARY.md</code> which is compatible with the <code>mkdocs-literary-nav</code> plugin.</p> PARAMETER  DESCRIPTION <code>src_path</code> <p>Path where the code is located.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'src'</code> </p> <code>dst_path</code> <p>Path where the documentation should be generated.  This is relative to the output directory of mkdocs.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'python-reference'</code> </p> Source code in <code>frequenz/repo/config/mkdocs.py</code> <pre><code>def generate_python_api_pages(\nsrc_path: str = \"src\", dst_path: str = \"python-reference\"\n) -&gt; None:\n\"\"\"Generate API documentation pages for the code.\n    Internal modules (those starting with an underscore except from `__init__`) are\n    not included.\n    A summary page is generated as `SUMMARY.md` which is compatible with the\n    `mkdocs-literary-nav` plugin.\n    Args:\n        src_path: Path where the code is located.\n        dst_path: Path where the documentation should be generated.  This is relative\n            to the output directory of mkdocs.\n    \"\"\"\n# type ignore because mkdocs_gen_files uses a very weird module-level\n# __getattr__() which messes up the type system\nnav = mkdocs_gen_files.Nav()  # type: ignore\nfor path in sorted(Path(src_path).rglob(\"*.py\")):\nmodule_path = path.relative_to(src_path).with_suffix(\"\")\ndoc_path = path.relative_to(src_path).with_suffix(\".md\")\nfull_doc_path = Path(dst_path, doc_path)\nparts = tuple(module_path.parts)\nif _is_internal(parts):\ncontinue\nif parts[-1] == \"__init__\":\ndoc_path = doc_path.with_name(\"index.md\")\nfull_doc_path = full_doc_path.with_name(\"index.md\")\nparts = parts[:-1]\nnav[parts] = doc_path.as_posix()\nwith mkdocs_gen_files.open(full_doc_path, \"w\") as output_file:\noutput_file.write(f\"::: {'.'.join(parts)}\\n\")\nmkdocs_gen_files.set_edit_path(full_doc_path, Path(\"..\") / path)\nwith mkdocs_gen_files.open(Path(dst_path) / \"SUMMARY.md\", \"w\") as nav_file:\nnav_file.writelines(nav.build_literate_nav())\n</code></pre>"},{"location":"reference/frequenz/repo/config/protobuf/","title":"protobuf","text":""},{"location":"reference/frequenz/repo/config/protobuf/#frequenz.repo.config.protobuf","title":"<code>frequenz.repo.config.protobuf</code>","text":"<p>Manages the configuration to generate files from the protobuf files.</p>"},{"location":"reference/frequenz/repo/config/protobuf/#frequenz.repo.config.protobuf-classes","title":"Classes","text":""},{"location":"reference/frequenz/repo/config/protobuf/#frequenz.repo.config.protobuf.ProtobufConfig","title":"<code>frequenz.repo.config.protobuf.ProtobufConfig</code>  <code>dataclass</code>","text":"<p>A configuration for the protobuf files.</p> <p>The configuration can be loaded from the <code>pyproject.toml</code> file using the class method <code>from_pyproject_toml()</code>.</p> Source code in <code>frequenz/repo/config/protobuf.py</code> <pre><code>@dataclasses.dataclass(frozen=True, kw_only=True)\nclass ProtobufConfig:\n\"\"\"A configuration for the protobuf files.\n    The configuration can be loaded from the `pyproject.toml` file using the class\n    method `from_pyproject_toml()`.\n    \"\"\"\nproto_path: str = \"proto\"\n\"\"\"The path of the root directory containing the protobuf files.\"\"\"\nproto_glob: str = \"*.proto\"\n\"\"\"The glob pattern to use to find the protobuf files.\"\"\"\ninclude_paths: Sequence[str] = (\n\"submodules/api-common-protos\",\n\"submodules/frequenz-api-common/proto\",\n)\n\"\"\"The paths to add to the include path when compiling the protobuf files.\"\"\"\npy_path: str = \"py\"\n\"\"\"The path of the root directory where the Python files will be generated.\"\"\"\ndocs_path: str = \"protobuf-reference\"\n\"\"\"The path of the root directory where the documentation files will be generated.\"\"\"\n@classmethod\ndef from_pyproject_toml(\ncls, path: str = \"pyproject.toml\", /, **defaults: Any\n) -&gt; Self:\n\"\"\"Create a new configuration by loading the options from a `pyproject.toml` file.\n        The options are read from the `[tool.frequenz-repo-config.protobuf]`\n        section of the `pyproject.toml` file.\n        Args:\n            path: The path to the `pyproject.toml` file.\n            **defaults: The default values for the options missing in the file.  If\n                a default is missing too, then the default in this class will be used.\n        Returns:\n            The configuration.\n        \"\"\"\ntry:\nwith pathlib.Path(path).open(\"rb\") as toml_file:\npyproject_toml = tomllib.load(toml_file)\nexcept FileNotFoundError:\nreturn cls(**defaults)\nexcept (IOError, OSError) as err:\n_logger.warning(\"WARNING: Failed to load pyproject.toml: %s\", err)\nreturn cls(**defaults)\ntry:\nconfig = pyproject_toml[\"tool\"][\"frequenz-repo-config\"][\"protobuf\"]\nexcept KeyError:\nreturn cls(**defaults)\ndefault = cls(**defaults)\nknown_keys = frozenset(dataclasses.asdict(default).keys())\nconfig_keys = frozenset(config.keys())\nif unknown_keys := config_keys - known_keys:\n_logger.warning(\n\"WARNING: There are some configuration keys in pyproject.toml we don't \"\n\"know about and will be ignored: %s\",\n\", \".join(f\"'{k}'\" for k in unknown_keys),\n)\nattrs = dict(defaults, **{k: config[k] for k in (known_keys &amp; config_keys)})\nreturn dataclasses.replace(default, **attrs)\n</code></pre>"},{"location":"reference/frequenz/repo/config/protobuf/#frequenz.repo.config.protobuf.ProtobufConfig-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/repo/config/protobuf/#frequenz.repo.config.protobuf.ProtobufConfig.docs_path","title":"<code>docs_path: str = 'protobuf-reference'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The path of the root directory where the documentation files will be generated.</p>"},{"location":"reference/frequenz/repo/config/protobuf/#frequenz.repo.config.protobuf.ProtobufConfig.include_paths","title":"<code>include_paths: Sequence[str] = ('submodules/api-common-protos', 'submodules/frequenz-api-common/proto')</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The paths to add to the include path when compiling the protobuf files.</p>"},{"location":"reference/frequenz/repo/config/protobuf/#frequenz.repo.config.protobuf.ProtobufConfig.proto_glob","title":"<code>proto_glob: str = '*.proto'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The glob pattern to use to find the protobuf files.</p>"},{"location":"reference/frequenz/repo/config/protobuf/#frequenz.repo.config.protobuf.ProtobufConfig.proto_path","title":"<code>proto_path: str = 'proto'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The path of the root directory containing the protobuf files.</p>"},{"location":"reference/frequenz/repo/config/protobuf/#frequenz.repo.config.protobuf.ProtobufConfig.py_path","title":"<code>py_path: str = 'py'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The path of the root directory where the Python files will be generated.</p>"},{"location":"reference/frequenz/repo/config/protobuf/#frequenz.repo.config.protobuf.ProtobufConfig-functions","title":"Functions","text":""},{"location":"reference/frequenz/repo/config/protobuf/#frequenz.repo.config.protobuf.ProtobufConfig.from_pyproject_toml","title":"<code>from_pyproject_toml(path='pyproject.toml', /, **defaults)</code>  <code>classmethod</code>","text":"<p>Create a new configuration by loading the options from a <code>pyproject.toml</code> file.</p> <p>The options are read from the <code>[tool.frequenz-repo-config.protobuf]</code> section of the <code>pyproject.toml</code> file.</p> PARAMETER  DESCRIPTION <code>path</code> <p>The path to the <code>pyproject.toml</code> file.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'pyproject.toml'</code> </p> <code>**defaults</code> <p>The default values for the options missing in the file.  If a default is missing too, then the default in this class will be used.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Self</code> <p>The configuration.</p> Source code in <code>frequenz/repo/config/protobuf.py</code> <pre><code>@classmethod\ndef from_pyproject_toml(\ncls, path: str = \"pyproject.toml\", /, **defaults: Any\n) -&gt; Self:\n\"\"\"Create a new configuration by loading the options from a `pyproject.toml` file.\n    The options are read from the `[tool.frequenz-repo-config.protobuf]`\n    section of the `pyproject.toml` file.\n    Args:\n        path: The path to the `pyproject.toml` file.\n        **defaults: The default values for the options missing in the file.  If\n            a default is missing too, then the default in this class will be used.\n    Returns:\n        The configuration.\n    \"\"\"\ntry:\nwith pathlib.Path(path).open(\"rb\") as toml_file:\npyproject_toml = tomllib.load(toml_file)\nexcept FileNotFoundError:\nreturn cls(**defaults)\nexcept (IOError, OSError) as err:\n_logger.warning(\"WARNING: Failed to load pyproject.toml: %s\", err)\nreturn cls(**defaults)\ntry:\nconfig = pyproject_toml[\"tool\"][\"frequenz-repo-config\"][\"protobuf\"]\nexcept KeyError:\nreturn cls(**defaults)\ndefault = cls(**defaults)\nknown_keys = frozenset(dataclasses.asdict(default).keys())\nconfig_keys = frozenset(config.keys())\nif unknown_keys := config_keys - known_keys:\n_logger.warning(\n\"WARNING: There are some configuration keys in pyproject.toml we don't \"\n\"know about and will be ignored: %s\",\n\", \".join(f\"'{k}'\" for k in unknown_keys),\n)\nattrs = dict(defaults, **{k: config[k] for k in (known_keys &amp; config_keys)})\nreturn dataclasses.replace(default, **attrs)\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/","title":"Index","text":""},{"location":"reference/frequenz/repo/config/nox/#frequenz.repo.config.nox","title":"<code>frequenz.repo.config.nox</code>","text":"<p>Utilities to build noxfiles.</p> <p>The main entry point is the <code>configure()</code> function, which will configure all nox sessions according to some configuration.</p> <p>To use the default options, you should call <code>configure()</code> using one of the repository types.  For example:</p> <pre><code>from frequenz.repo.config import RepositoryType, nox\nnox.configure(RepositoryType.LIB)\n</code></pre> <p>Again, make sure to pick the correct project typedefault configuration based on the type of your project (<code>actor_config</code>, <code>api_config</code>, <code>app_config</code>, <code>lib_config</code>, <code>model_config</code>).</p> <p>If you need to use some custom configuration, you can start from the default settings in the <code>frequenz.repo.config.nox.default</code> module, copying it and changing whatever you need to customize.  For example:</p> <pre><code>from frequenz.repo.config import nox\nfrom frequenz.repo.config.nox import default\nconfig = default.lib_config.copy()\nconfig.opts.black.append(\"--diff\")\nnox.configure(config)\n</code></pre> <p>If you need further customization or to define new sessions, you can use the following modules:</p> <ul> <li> <p><code>frequenz.repo.config.nox.config</code>: Low-level utilities to configure nox sessions.   It defines the <code>Config</code> and CommandsOptions<code>classes and the actual implementation of   the</code>configure()<code>function. It also defines the</code>get()` function, which can be used to   get the currently used configuration object.</p> </li> <li> <p><code>frequenz.repo.config.nox.session</code>: Predefined nox sessions. These are the   sessions that are used by default.</p> </li> <li> <p><code>frequenz.repo.config.nox.util</code>: General purpose utility functions.</p> </li> </ul>"},{"location":"reference/frequenz/repo/config/nox/#frequenz.repo.config.nox-functions","title":"Functions","text":""},{"location":"reference/frequenz/repo/config/nox/#frequenz.repo.config.nox.configure","title":"<code>frequenz.repo.config.nox.configure(conf, /, *, import_default_sessions=True)</code>","text":"<p>Configure nox using the provided configuration or repository type.</p> PARAMETER  DESCRIPTION <code>conf</code> <p>The configuration to use to configure nox, or the repository type to use to configure nox.  The later will use the default configuration in <code>frequenz.repo.config.nox.default</code> for that type of repository.</p> <p> TYPE: <code>Config | RepositoryType</code> </p> <code>import_default_sessions</code> <p>Whether to import the default sessions or not. This is only necessary if you want to avoid using the default provided sessions and use your own.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code></code> <pre><code>def configure(\nconf: Config | RepositoryType, /, *, import_default_sessions: bool = True\n) -&gt; None:\n\"\"\"Configure nox using the provided configuration or repository type.\n    Args:\n        conf: The configuration to use to configure nox, or the repository type to use\n            to configure nox.  The later will use the default configuration in\n            [`frequenz.repo.config.nox.default`][] for that type of repository.\n        import_default_sessions: Whether to import the default sessions or not.\n            This is only necessary if you want to avoid using the default provided\n            sessions and use your own.\n    \"\"\"\nglobal _config  # pylint: disable=global-statement\n# We need to make sure sessions are imported, otherwise they won't be visible to nox.\nif import_default_sessions:\n# pylint: disable=import-outside-toplevel,cyclic-import\nfrom . import session as _  # noqa: F401\nmatch conf:\ncase Config():\n_config = conf\ncase RepositoryType() as repo_type:\n# pylint: disable=import-outside-toplevel,cyclic-import\nfrom . import default\nmatch repo_type:\ncase RepositoryType.ACTOR:\n_config = default.actor_config\ncase RepositoryType.API:\n_config = default.api_config\ncase RepositoryType.APP:\n_config = default.app_config\ncase RepositoryType.LIB:\n_config = default.lib_config\ncase RepositoryType.MODEL:\n_config = default.model_config\ncase _ as unhandled:\nassert_never(unhandled)\n_nox.options.sessions = _config.sessions\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/config/","title":"config","text":""},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config","title":"<code>frequenz.repo.config.nox.config</code>","text":"<p>Configuration utilities for nox.</p> <p>This module provides utilities to configure the nox sessions. It provides a <code>Config</code> and a <code>CommandsOptions</code> class, which are used to configure the nox sessions.</p> <p>The <code>get()</code> function can be used to retrieve the current configuration object so it can be used when implementing custom nox sessions.</p> <p>The <code>configure()</code> function must be called before <code>get()</code> is used.</p>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config-classes","title":"Classes","text":""},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.CommandsOptions","title":"<code>frequenz.repo.config.nox.config.CommandsOptions</code>  <code>dataclass</code>","text":"<p>Command-line options for each command.</p> Source code in <code>frequenz/repo/config/nox/config.py</code> <pre><code>@_dataclasses.dataclass(kw_only=True, slots=True)\nclass CommandsOptions:\n\"\"\"Command-line options for each command.\"\"\"\nblack: list[str] = _dataclasses.field(default_factory=lambda: [])\n\"\"\"Command-line options for the `black` command.\"\"\"\nflake8: list[str] = _dataclasses.field(default_factory=lambda: [])\n\"\"\"Command-line options for the `flake8` command.\"\"\"\nisort: list[str] = _dataclasses.field(default_factory=lambda: [])\n\"\"\"Command-line options for the `isort` command.\"\"\"\nmypy: list[str] = _dataclasses.field(default_factory=lambda: [])\n\"\"\"Command-line options for the `mypy` command.\"\"\"\npylint: list[str] = _dataclasses.field(default_factory=lambda: [])\n\"\"\"Command-line options for the `pylint` command.\"\"\"\npytest: list[str] = _dataclasses.field(default_factory=lambda: [])\n\"\"\"Command-line options for the `pytest` command.\"\"\"\ndef copy(self) -&gt; Self:\n\"\"\"Create a new object as a copy of self.\n        Returns:\n            The copy of self.\n        \"\"\"\nreturn _dataclasses.replace(\nself,\nblack=self.black.copy(),\nflake8=self.flake8.copy(),\nisort=self.isort.copy(),\nmypy=self.mypy.copy(),\npylint=self.pylint.copy(),\npytest=self.pytest.copy(),\n)\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.CommandsOptions-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.CommandsOptions.black","title":"<code>black: list[str] = _dataclasses.field(default_factory=lambda : [])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Command-line options for the <code>black</code> command.</p>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.CommandsOptions.flake8","title":"<code>flake8: list[str] = _dataclasses.field(default_factory=lambda : [])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Command-line options for the <code>flake8</code> command.</p>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.CommandsOptions.isort","title":"<code>isort: list[str] = _dataclasses.field(default_factory=lambda : [])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Command-line options for the <code>isort</code> command.</p>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.CommandsOptions.mypy","title":"<code>mypy: list[str] = _dataclasses.field(default_factory=lambda : [])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Command-line options for the <code>mypy</code> command.</p>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.CommandsOptions.pylint","title":"<code>pylint: list[str] = _dataclasses.field(default_factory=lambda : [])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Command-line options for the <code>pylint</code> command.</p>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.CommandsOptions.pytest","title":"<code>pytest: list[str] = _dataclasses.field(default_factory=lambda : [])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Command-line options for the <code>pytest</code> command.</p>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.CommandsOptions-functions","title":"Functions","text":""},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.CommandsOptions.copy","title":"<code>copy()</code>","text":"<p>Create a new object as a copy of self.</p> RETURNS DESCRIPTION <code>Self</code> <p>The copy of self.</p> Source code in <code>frequenz/repo/config/nox/config.py</code> <pre><code>def copy(self) -&gt; Self:\n\"\"\"Create a new object as a copy of self.\n    Returns:\n        The copy of self.\n    \"\"\"\nreturn _dataclasses.replace(\nself,\nblack=self.black.copy(),\nflake8=self.flake8.copy(),\nisort=self.isort.copy(),\nmypy=self.mypy.copy(),\npylint=self.pylint.copy(),\npytest=self.pytest.copy(),\n)\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.Config","title":"<code>frequenz.repo.config.nox.config.Config</code>  <code>dataclass</code>","text":"<p>Configuration for nox sessions.</p> Source code in <code>frequenz/repo/config/nox/config.py</code> <pre><code>@_dataclasses.dataclass(kw_only=True, slots=True)\nclass Config:\n\"\"\"Configuration for nox sessions.\"\"\"\nopts: CommandsOptions = _dataclasses.field(default_factory=CommandsOptions)\n\"\"\"Command-line options for each command used by sessions.\"\"\"\nsessions: list[str] = _dataclasses.field(default_factory=lambda: [])\n\"\"\"List of sessions to run.\"\"\"\nsource_paths: list[str] = _dataclasses.field(default_factory=lambda: [])\n\"\"\"List of paths containing source files that should be analyzed by the sessions.\n    Source paths are inspected for `__init__.py` files to look for packages.\n    The path should be the top-level directory containing packages that will be\n    actually part of the distribution, not development paths, like tests,\n    benchmarks, etc.\n    This path will be removed when calculating the package name for the found\n    packages. `mypy` needs the package name to be able to do full import\n    checking.\n    \"\"\"\nextra_paths: list[str] = _dataclasses.field(default_factory=lambda: [])\n\"\"\"List of extra paths to be analyzed by the sessions.\n    These are not inspected for packages, as they are passed verbatim to the\n    tools invoked by the sessions.\n    \"\"\"\ndef __post_init__(self) -&gt; None:\n\"\"\"Initialize the configuration object.\n        This will add extra paths discovered in config files and other sources.\n        \"\"\"\nfor path in _util.discover_paths():\nif path not in self.extra_paths and path not in self.source_paths:\nself.extra_paths.append(path)\ndef copy(self, /) -&gt; Self:\n\"\"\"Create a new object as a copy of self.\n        Returns:\n            The copy of self.\n        \"\"\"\nreturn _dataclasses.replace(\nself,\nopts=self.opts.copy(),\nsessions=self.sessions.copy(),\nsource_paths=self.source_paths.copy(),\nextra_paths=self.extra_paths.copy(),\n)\ndef path_args(\nself,\nsession: _nox.Session,\n/,\n*,\ninclude_sources: bool = True,\ninclude_extra: bool = True,\n) -&gt; list[str]:\n\"\"\"Return the file paths to run the checks on.\n        If positional arguments are present in the nox session, those are used\n        as the file paths verbatim, and if not, all **existing** `source_paths`\n        and `extra_paths` are used.\n        Args:\n            session: The nox session to use to look for command-line arguments.\n            include_sources: Whether to include the source paths or not.\n            include_extra: Whether to include the extra paths or not.\n        Returns:\n            The file paths to run the checks on.\n        \"\"\"\nif session.posargs:\nreturn session.posargs\npaths: list[str] = []\nif include_sources:\npaths.extend(self.source_paths)\nif include_extra:\npaths.extend(self.extra_paths)\nreturn list(str(p) for p in _util.existing_paths(paths))\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.Config-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.Config.extra_paths","title":"<code>extra_paths: list[str] = _dataclasses.field(default_factory=lambda : [])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of extra paths to be analyzed by the sessions.</p> <p>These are not inspected for packages, as they are passed verbatim to the tools invoked by the sessions.</p>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.Config.opts","title":"<code>opts: CommandsOptions = _dataclasses.field(default_factory=CommandsOptions)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Command-line options for each command used by sessions.</p>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.Config.sessions","title":"<code>sessions: list[str] = _dataclasses.field(default_factory=lambda : [])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of sessions to run.</p>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.Config.source_paths","title":"<code>source_paths: list[str] = _dataclasses.field(default_factory=lambda : [])</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of paths containing source files that should be analyzed by the sessions.</p> <p>Source paths are inspected for <code>__init__.py</code> files to look for packages. The path should be the top-level directory containing packages that will be actually part of the distribution, not development paths, like tests, benchmarks, etc.</p> <p>This path will be removed when calculating the package name for the found packages. <code>mypy</code> needs the package name to be able to do full import checking.</p>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.Config-functions","title":"Functions","text":""},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.Config.__post_init__","title":"<code>__post_init__()</code>","text":"<p>Initialize the configuration object.</p> <p>This will add extra paths discovered in config files and other sources.</p> Source code in <code>frequenz/repo/config/nox/config.py</code> <pre><code>def __post_init__(self) -&gt; None:\n\"\"\"Initialize the configuration object.\n    This will add extra paths discovered in config files and other sources.\n    \"\"\"\nfor path in _util.discover_paths():\nif path not in self.extra_paths and path not in self.source_paths:\nself.extra_paths.append(path)\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.Config.copy","title":"<code>copy()</code>","text":"<p>Create a new object as a copy of self.</p> RETURNS DESCRIPTION <code>Self</code> <p>The copy of self.</p> Source code in <code>frequenz/repo/config/nox/config.py</code> <pre><code>def copy(self, /) -&gt; Self:\n\"\"\"Create a new object as a copy of self.\n    Returns:\n        The copy of self.\n    \"\"\"\nreturn _dataclasses.replace(\nself,\nopts=self.opts.copy(),\nsessions=self.sessions.copy(),\nsource_paths=self.source_paths.copy(),\nextra_paths=self.extra_paths.copy(),\n)\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.Config.path_args","title":"<code>path_args(session, /, *, include_sources=True, include_extra=True)</code>","text":"<p>Return the file paths to run the checks on.</p> <p>If positional arguments are present in the nox session, those are used as the file paths verbatim, and if not, all existing <code>source_paths</code> and <code>extra_paths</code> are used.</p> PARAMETER  DESCRIPTION <code>session</code> <p>The nox session to use to look for command-line arguments.</p> <p> TYPE: <code>Session</code> </p> <code>include_sources</code> <p>Whether to include the source paths or not.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>include_extra</code> <p>Whether to include the extra paths or not.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>list[str]</code> <p>The file paths to run the checks on.</p> Source code in <code>frequenz/repo/config/nox/config.py</code> <pre><code>def path_args(\nself,\nsession: _nox.Session,\n/,\n*,\ninclude_sources: bool = True,\ninclude_extra: bool = True,\n) -&gt; list[str]:\n\"\"\"Return the file paths to run the checks on.\n    If positional arguments are present in the nox session, those are used\n    as the file paths verbatim, and if not, all **existing** `source_paths`\n    and `extra_paths` are used.\n    Args:\n        session: The nox session to use to look for command-line arguments.\n        include_sources: Whether to include the source paths or not.\n        include_extra: Whether to include the extra paths or not.\n    Returns:\n        The file paths to run the checks on.\n    \"\"\"\nif session.posargs:\nreturn session.posargs\npaths: list[str] = []\nif include_sources:\npaths.extend(self.source_paths)\nif include_extra:\npaths.extend(self.extra_paths)\nreturn list(str(p) for p in _util.existing_paths(paths))\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config-functions","title":"Functions","text":""},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.configure","title":"<code>frequenz.repo.config.nox.config.configure(conf, /, *, import_default_sessions=True)</code>","text":"<p>Configure nox using the provided configuration or repository type.</p> PARAMETER  DESCRIPTION <code>conf</code> <p>The configuration to use to configure nox, or the repository type to use to configure nox.  The later will use the default configuration in <code>frequenz.repo.config.nox.default</code> for that type of repository.</p> <p> TYPE: <code>Config | RepositoryType</code> </p> <code>import_default_sessions</code> <p>Whether to import the default sessions or not. This is only necessary if you want to avoid using the default provided sessions and use your own.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>frequenz/repo/config/nox/config.py</code> <pre><code>def configure(\nconf: Config | RepositoryType, /, *, import_default_sessions: bool = True\n) -&gt; None:\n\"\"\"Configure nox using the provided configuration or repository type.\n    Args:\n        conf: The configuration to use to configure nox, or the repository type to use\n            to configure nox.  The later will use the default configuration in\n            [`frequenz.repo.config.nox.default`][] for that type of repository.\n        import_default_sessions: Whether to import the default sessions or not.\n            This is only necessary if you want to avoid using the default provided\n            sessions and use your own.\n    \"\"\"\nglobal _config  # pylint: disable=global-statement\n# We need to make sure sessions are imported, otherwise they won't be visible to nox.\nif import_default_sessions:\n# pylint: disable=import-outside-toplevel,cyclic-import\nfrom . import session as _  # noqa: F401\nmatch conf:\ncase Config():\n_config = conf\ncase RepositoryType() as repo_type:\n# pylint: disable=import-outside-toplevel,cyclic-import\nfrom . import default\nmatch repo_type:\ncase RepositoryType.ACTOR:\n_config = default.actor_config\ncase RepositoryType.API:\n_config = default.api_config\ncase RepositoryType.APP:\n_config = default.app_config\ncase RepositoryType.LIB:\n_config = default.lib_config\ncase RepositoryType.MODEL:\n_config = default.model_config\ncase _ as unhandled:\nassert_never(unhandled)\n_nox.options.sessions = _config.sessions\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/config/#frequenz.repo.config.nox.config.get","title":"<code>frequenz.repo.config.nox.config.get()</code>","text":"<p>Get the global configuration object.</p> <p>This will assert if <code>configure()</code> wasn't called before.</p> RETURNS DESCRIPTION <code>Config</code> <p>The global configuration object.</p> Source code in <code>frequenz/repo/config/nox/config.py</code> <pre><code>def get() -&gt; Config:\n\"\"\"Get the global configuration object.\n    This will assert if `configure()` wasn't called before.\n    Returns:\n        The global configuration object.\n    \"\"\"\nassert _config is not None, \"You must call configure() before using this function\"\nreturn _config\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/default/","title":"default","text":""},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default","title":"<code>frequenz.repo.config.nox.default</code>","text":"<p>Default nox configuration for different types of repositories.</p> <p>This module provides the default configuration for the different types of repositories defined by <code>frequenz.repo.config.RepositoryType</code>.</p> <p>The <code>actor_config</code>, <code>api_config</code>, <code>app_config</code>, <code>lib_config</code>, and <code>model_config</code> variables are the default configurations for libraries, APIs, actors and applications, respectively. The <code>common_config</code> variable is the default configuration for all types of repositories.</p> <p>The <code>actor_command_options</code>, <code>api_command_options</code>, <code>app_command_options</code>, <code>lib_command_options</code>, and <code>model_command_options</code> variables are the default command-line options for the same types of repositories, and the <code>common_command_options</code> variable is the default command-line options for all types of repositories.</p> <p>They can be modified before being passed to <code>nox.configure()</code> by using the <code>CommandsOptions.copy()</code> method.</p>"},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default.actor_command_options","title":"<code>frequenz.repo.config.nox.default.actor_command_options: _config.CommandsOptions = common_command_options.copy()</code>  <code>module-attribute</code>","text":"<p>Default command-line options for actors.</p>"},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default.actor_config","title":"<code>frequenz.repo.config.nox.default.actor_config: _config.Config = common_config.copy()</code>  <code>module-attribute</code>","text":"<p>Default configuration for actors.</p>"},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default.api_command_options","title":"<code>frequenz.repo.config.nox.default.api_command_options: _config.CommandsOptions = common_command_options.copy()</code>  <code>module-attribute</code>","text":"<p>Default command-line options for APIs.</p>"},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default.api_config","title":"<code>frequenz.repo.config.nox.default.api_config: _config.Config = common_config.copy()</code>  <code>module-attribute</code>","text":"<p>Default configuration for APIs.</p> <p>Same as <code>common_config</code>, but with an empty <code>source_paths</code> (as the sources are automatically generated, we don't want to test anything in there).</p>"},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default.app_command_options","title":"<code>frequenz.repo.config.nox.default.app_command_options: _config.CommandsOptions = common_command_options.copy()</code>  <code>module-attribute</code>","text":"<p>Default command-line options for applications.</p>"},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default.app_config","title":"<code>frequenz.repo.config.nox.default.app_config: _config.Config = common_config.copy()</code>  <code>module-attribute</code>","text":"<p>Default configuration for applications.</p>"},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default.common_command_options","title":"<code>frequenz.repo.config.nox.default.common_command_options: _config.CommandsOptions = _config.CommandsOptions(black=['--check'], flake8=[], isort=['--diff', '--check'], mypy=[], pytest=['-W=all', '-vv'])</code>  <code>module-attribute</code>","text":"<p>Default command-line options for all types of repositories.</p>"},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default.common_config","title":"<code>frequenz.repo.config.nox.default.common_config = _config.Config(opts=common_command_options.copy(), sessions=['formatting', 'flake8', 'mypy', 'pylint', 'pytest_min', 'pytest_max'], source_paths=['src'], extra_paths=['benchmarks', 'docs', 'examples', 'noxfile.py', 'tests'])</code>  <code>module-attribute</code>","text":"<p>Default configuration for all types of repositories.</p>"},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default.lib_command_options","title":"<code>frequenz.repo.config.nox.default.lib_command_options: _config.CommandsOptions = common_command_options.copy()</code>  <code>module-attribute</code>","text":"<p>Default command-line options for libraries.</p>"},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default.lib_config","title":"<code>frequenz.repo.config.nox.default.lib_config: _config.Config = common_config.copy()</code>  <code>module-attribute</code>","text":"<p>Default configuration for libraries.</p>"},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default.model_command_options","title":"<code>frequenz.repo.config.nox.default.model_command_options: _config.CommandsOptions = common_command_options.copy()</code>  <code>module-attribute</code>","text":"<p>Default command-line options for models.</p>"},{"location":"reference/frequenz/repo/config/nox/default/#frequenz.repo.config.nox.default.model_config","title":"<code>frequenz.repo.config.nox.default.model_config: _config.Config = common_config.copy()</code>  <code>module-attribute</code>","text":"<p>Default configuration for models.</p>"},{"location":"reference/frequenz/repo/config/nox/session/","title":"session","text":""},{"location":"reference/frequenz/repo/config/nox/session/#frequenz.repo.config.nox.session","title":"<code>frequenz.repo.config.nox.session</code>","text":"<p>Predefined nox sessions.</p> <p>This module defines the predefined nox sessions that are used by the default.</p>"},{"location":"reference/frequenz/repo/config/nox/session/#frequenz.repo.config.nox.session-functions","title":"Functions","text":""},{"location":"reference/frequenz/repo/config/nox/session/#frequenz.repo.config.nox.session.ci_checks_max","title":"<code>frequenz.repo.config.nox.session.ci_checks_max(session)</code>","text":"<p>Run all checks with max dependencies in a single session.</p> <p>This is faster than running the checks separately, so it is suitable for CI.</p> <p>This does NOT run pytest_min, so that needs to be run separately as well.</p> PARAMETER  DESCRIPTION <code>session</code> <p>the nox session.</p> <p> TYPE: <code>Session</code> </p> Source code in <code>frequenz/repo/config/nox/session.py</code> <pre><code>@nox.session\ndef ci_checks_max(session: nox.Session) -&gt; None:\n\"\"\"Run all checks with max dependencies in a single session.\n    This is faster than running the checks separately, so it is suitable for CI.\n    This does NOT run pytest_min, so that needs to be run separately as well.\n    Args:\n        session: the nox session.\n    \"\"\"\nsession.install(\"-e\", \".[dev]\")\nformatting(session, False)\nflake8(session, False)\nmypy(session, False)\npylint(session, False)\npytest_max(session, False)\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/session/#frequenz.repo.config.nox.session.flake8","title":"<code>frequenz.repo.config.nox.session.flake8(session, install_deps=True)</code>","text":"<p>Check for common errors and in particular documentation format and style.</p> PARAMETER  DESCRIPTION <code>session</code> <p>the nox session.</p> <p> TYPE: <code>Session</code> </p> <code>install_deps</code> <p>True if dependencies should be installed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>frequenz/repo/config/nox/session.py</code> <pre><code>@nox.session\ndef flake8(session: nox.Session, install_deps: bool = True) -&gt; None:\n\"\"\"Check for common errors and in particular documentation format and style.\n    Args:\n        session: the nox session.\n        install_deps: True if dependencies should be installed.\n    \"\"\"\nif install_deps:\nsession.install(\"-e\", \".[dev-flake8]\")\nconf = _config.get()\nsession.run(\"flake8\", *conf.opts.flake8, *conf.path_args(session))\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/session/#frequenz.repo.config.nox.session.formatting","title":"<code>frequenz.repo.config.nox.session.formatting(session, install_deps=True)</code>","text":"<p>Check code formatting with black and isort.</p> PARAMETER  DESCRIPTION <code>session</code> <p>the nox session.</p> <p> TYPE: <code>Session</code> </p> <code>install_deps</code> <p>True if dependencies should be installed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>frequenz/repo/config/nox/session.py</code> <pre><code>@nox.session\ndef formatting(session: nox.Session, install_deps: bool = True) -&gt; None:\n\"\"\"Check code formatting with black and isort.\n    Args:\n        session: the nox session.\n        install_deps: True if dependencies should be installed.\n    \"\"\"\nif install_deps:\nsession.install(\"-e\", \".[dev-formatting]\")\nconf = _config.get()\nsession.run(\"black\", *conf.opts.black, *conf.path_args(session))\nsession.run(\"isort\", *conf.opts.isort, *conf.path_args(session))\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/session/#frequenz.repo.config.nox.session.mypy","title":"<code>frequenz.repo.config.nox.session.mypy(session, install_deps=True)</code>","text":"<p>Check type hints with mypy.</p> PARAMETER  DESCRIPTION <code>session</code> <p>the nox session.</p> <p> TYPE: <code>Session</code> </p> <code>install_deps</code> <p>True if dependencies should be installed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>frequenz/repo/config/nox/session.py</code> <pre><code>@nox.session\ndef mypy(session: nox.Session, install_deps: bool = True) -&gt; None:\n\"\"\"Check type hints with mypy.\n    Args:\n        session: the nox session.\n        install_deps: True if dependencies should be installed.\n    \"\"\"\nif install_deps:\n# install the package itself as editable, so that it is possible to do\n# fast local tests with `nox -R -e mypy`.\nsession.install(\"-e\", \".[dev-mypy]\")\nconf = _config.get()\n# If we get CLI options, we run mypy on those, but still passing the\n# configured options (they can be overridden by the CLI options).\nif session.posargs:\nsession.run(\"mypy\", *conf.opts.mypy, *session.posargs)\nreturn\n# We separate running the mypy checks into two runs, one is the default, as\n# configured in `pyproject.toml`, which should run against the sources.\nsession.run(\"mypy\", *conf.opts.mypy)\n# The second run checks development files, like tests, benchmarks, etc.\n# This is an attempt to minimize mypy internal errors.\nsession.run(\n\"mypy\", *conf.opts.mypy, *conf.path_args(session, include_sources=False)\n)\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/session/#frequenz.repo.config.nox.session.pylint","title":"<code>frequenz.repo.config.nox.session.pylint(session, install_deps=True)</code>","text":"<p>Check for code smells with pylint.</p> PARAMETER  DESCRIPTION <code>session</code> <p>the nox session.</p> <p> TYPE: <code>Session</code> </p> <code>install_deps</code> <p>True if dependencies should be installed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>frequenz/repo/config/nox/session.py</code> <pre><code>@nox.session\ndef pylint(session: nox.Session, install_deps: bool = True) -&gt; None:\n\"\"\"Check for code smells with pylint.\n    Args:\n        session: the nox session.\n        install_deps: True if dependencies should be installed.\n    \"\"\"\nif install_deps:\n# install the package itself as editable, so that it is possible to do\n# fast local tests with `nox -R -e pylint`.\nsession.install(\"-e\", \".[dev-pylint]\")\nconf = _config.get()\nsession.run(\"pylint\", *conf.opts.pylint, *conf.path_args(session))\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/session/#frequenz.repo.config.nox.session.pytest_max","title":"<code>frequenz.repo.config.nox.session.pytest_max(session, install_deps=True)</code>","text":"<p>Test the code against max dependency versions with pytest.</p> PARAMETER  DESCRIPTION <code>session</code> <p>the nox session.</p> <p> TYPE: <code>Session</code> </p> <code>install_deps</code> <p>True if dependencies should be installed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>frequenz/repo/config/nox/session.py</code> <pre><code>@nox.session\ndef pytest_max(session: nox.Session, install_deps: bool = True) -&gt; None:\n\"\"\"Test the code against max dependency versions with pytest.\n    Args:\n        session: the nox session.\n        install_deps: True if dependencies should be installed.\n    \"\"\"\nif install_deps:\n# install the package itself as editable, so that it is possible to do\n# fast local tests with `nox -R -e pytest_max`.\nsession.install(\"-e\", \".[dev-pytest]\")\n_pytest_impl(session, \"max\")\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/session/#frequenz.repo.config.nox.session.pytest_min","title":"<code>frequenz.repo.config.nox.session.pytest_min(session, install_deps=True)</code>","text":"<p>Test the code against min dependency versions with pytest.</p> PARAMETER  DESCRIPTION <code>session</code> <p>the nox session.</p> <p> TYPE: <code>Session</code> </p> <code>install_deps</code> <p>True if dependencies should be installed.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>frequenz/repo/config/nox/session.py</code> <pre><code>@nox.session\ndef pytest_min(session: nox.Session, install_deps: bool = True) -&gt; None:\n\"\"\"Test the code against min dependency versions with pytest.\n    Args:\n        session: the nox session.\n        install_deps: True if dependencies should be installed.\n    \"\"\"\nif install_deps:\n# install the package itself as editable, so that it is possible to do\n# fast local tests with `nox -R -e pytest_min`.\nsession.install(\"-e\", \".[dev-pytest]\", *_util.min_dependencies())\n_pytest_impl(session, \"min\")\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/util/","title":"util","text":""},{"location":"reference/frequenz/repo/config/nox/util/#frequenz.repo.config.nox.util","title":"<code>frequenz.repo.config.nox.util</code>","text":"<p>General purpose utilities.</p> <p>This module contains general purpose utilities that are used by the other modules in this package.</p>"},{"location":"reference/frequenz/repo/config/nox/util/#frequenz.repo.config.nox.util-functions","title":"Functions","text":""},{"location":"reference/frequenz/repo/config/nox/util/#frequenz.repo.config.nox.util.deduplicate","title":"<code>frequenz.repo.config.nox.util.deduplicate(iterable)</code>","text":"<p>Filter out duplicates from an iterable preserving the original iterable order.</p> PARAMETER  DESCRIPTION <code>iterable</code> <p>The iterable to remove duplicates from.</p> <p> TYPE: <code>Iterable[_T]</code> </p> RETURNS DESCRIPTION <code>Iterable[_T]</code> <p>The elements of <code>iterable</code>, without duplicates but preserving order.</p> Source code in <code>frequenz/repo/config/nox/util.py</code> <pre><code>def deduplicate(iterable: Iterable[_T], /) -&gt; Iterable[_T]:\n\"\"\"Filter out duplicates from an iterable preserving the original iterable order.\n    Args:\n        iterable: The iterable to remove duplicates from.\n    Returns:\n        The elements of `iterable`, without duplicates but preserving order.\n    \"\"\"\n# We can't use a set() here because sets don't preserve order.  We use this hack\n# with dict.fromkeys() because dicts do preserve order in Python 3.7+.\nreturn dict.fromkeys(iterable).keys()\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/util/#frequenz.repo.config.nox.util.discover_paths","title":"<code>frequenz.repo.config.nox.util.discover_paths()</code>","text":"<p>Discover paths to check.</p> <p>Discover the paths to check by looking into different sources, like the <code>pyproject.toml</code> file.</p> <p>Currently the following paths are discovered:</p> <ul> <li>The <code>testpaths</code> option in the <code>tools.pytest.ini_options</code> section of   <code>pyproject.toml</code>.</li> </ul> RETURNS DESCRIPTION <code>list[str]</code> <p>The discovered paths to check.</p> Source code in <code>frequenz/repo/config/nox/util.py</code> <pre><code>def discover_paths() -&gt; list[str]:\n\"\"\"Discover paths to check.\n    Discover the paths to check by looking into different sources, like the\n    `pyproject.toml` file.\n    Currently the following paths are discovered:\n    - The `testpaths` option in the `tools.pytest.ini_options` section of\n      `pyproject.toml`.\n    Returns:\n        The discovered paths to check.\n    \"\"\"\nwith open(\"pyproject.toml\", \"rb\") as toml_file:\ndata = _tomllib.load(toml_file)\ntestpaths: list[str] = (\ndata.get(\"tool\", {})\n.get(\"pytest\", {})\n.get(\"ini_options\", {})\n.get(\"testpaths\", [])\n)\nreturn list(deduplicate(testpaths))\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/util/#frequenz.repo.config.nox.util.existing_paths","title":"<code>frequenz.repo.config.nox.util.existing_paths(paths)</code>","text":"<p>Filter paths to only leave valid paths that exist and are unique.</p> PARAMETER  DESCRIPTION <code>paths</code> <p>The paths to check and filter.</p> <p> TYPE: <code>Iterable[str]</code> </p> RETURNS DESCRIPTION <code>Iterable[Path]</code> <p>An iterable with the valid paths as <code>pathlib.Path</code> objects.</p> Example <p>assert list(existing_paths([\".\", \"/fake\"])) == [pathlib.Path(\".\")]</p> Source code in <code>frequenz/repo/config/nox/util.py</code> <pre><code>def existing_paths(paths: Iterable[str], /) -&gt; Iterable[_pathlib.Path]:\n\"\"\"Filter paths to only leave valid paths that exist and are unique.\n    Args:\n        paths: The paths to check and filter.\n    Returns:\n        An iterable with the valid paths as `pathlib.Path` objects.\n    Example:\n        &gt;&gt;&gt; assert list(existing_paths([\".\", \"/fake\"])) == [pathlib.Path(\".\")]\n    \"\"\"\nreturn deduplicate(p for p in map(_pathlib.Path, paths) if p.exists())\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/util/#frequenz.repo.config.nox.util.find_toplevel_package_dirs","title":"<code>frequenz.repo.config.nox.util.find_toplevel_package_dirs(path, /, *, root=None)</code>","text":"<p>Find top-level packages directories in a <code>path</code>.</p> <p>Searches recursively for the top-level packages in <code>path</code>, relative to <code>root</code>.</p> PARAMETER  DESCRIPTION <code>path</code> <p>The path to look for python packages.</p> <p> TYPE: <code>Path</code> </p> <code>root</code> <p>The part of the path that is considered the root and will be removed from the resulting path. If <code>None</code> then <code>path</code> is used as <code>root</code>.</p> <p> TYPE: <code>Path | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Iterable[Path]</code> <p>The top-level paths that contains a <code>__init__.py</code> file, with <code>root</code></p> <code>Iterable[Path]</code> <p>removed.</p> <p>Examples:</p> <p>If we have a directory like the following:</p> <pre><code>.\n\u251c\u2500\u2500 noxfile.py\n\u2514\u2500\u2500 src\n    \u2514\u2500\u2500 frequenz\n        \u2514\u2500\u2500 repo\n            \u2514\u2500\u2500 config\n                \u251c\u2500\u2500 __init__.py\n                \u251c\u2500\u2500 nox\n                \u2502\u00a0\u00a0 \u251c\u2500\u2500 config.py\n                \u2502\u00a0\u00a0 \u251c\u2500\u2500 default.py\n                \u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n                \u2502\u00a0\u00a0 \u251c\u2500\u2500 session.py\n                \u2502\u00a0\u00a0 \u2514\u2500\u2500 util.py\n                \u2514\u2500\u2500 setuptools.py\n</code></pre> <p>Then calling <code>find_toplevel_package_dirs(pathlib.Path(\"src\"))</code> will return an iterator producing: <code>[\"frequenz/repo/config\"]</code>.</p> Source code in <code>frequenz/repo/config/nox/util.py</code> <pre><code>def find_toplevel_package_dirs(\npath: _pathlib.Path, /, *, root: _pathlib.Path | None = None\n) -&gt; Iterable[_pathlib.Path]:\n\"\"\"Find top-level packages directories in a `path`.\n    Searches recursively for the top-level packages in `path`, relative to\n    `root`.\n    Args:\n        path: The path to look for python packages.\n        root: The part of the path that is considered the root and will be\n            removed from the resulting path. If `None` then `path` is used as\n            `root`.\n    Returns:\n        The top-level paths that contains a `__init__.py` file, with `root`\n        removed.\n    Examples:\n        If we have a directory like the following:\n        ```\n        .\n        \u251c\u2500\u2500 noxfile.py\n        \u2514\u2500\u2500 src\n            \u2514\u2500\u2500 frequenz\n                \u2514\u2500\u2500 repo\n                    \u2514\u2500\u2500 config\n                        \u251c\u2500\u2500 __init__.py\n                        \u251c\u2500\u2500 nox\n                        \u2502\u00a0\u00a0 \u251c\u2500\u2500 config.py\n                        \u2502\u00a0\u00a0 \u251c\u2500\u2500 default.py\n                        \u2502\u00a0\u00a0 \u251c\u2500\u2500 __init__.py\n                        \u2502\u00a0\u00a0 \u251c\u2500\u2500 session.py\n                        \u2502\u00a0\u00a0 \u2514\u2500\u2500 util.py\n                        \u2514\u2500\u2500 setuptools.py\n        ```\n        Then calling `find_toplevel_package_dirs(pathlib.Path(\"src\"))` will\n        return an iterator producing: `[\"frequenz/repo/config\"]`.\n    \"\"\"\nif root is None:\nroot = path\n# Bail out early if it is a directory with a __init__.py to avoid getting\n# sub-packages\nif (path / \"__init__.py\").exists():\nreturn [path.relative_to(root)]\nif path.is_dir():\nreturn flatten(\n[find_toplevel_package_dirs(p, root=root) for p in path.iterdir()]\n)\nreturn ()\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/util/#frequenz.repo.config.nox.util.flatten","title":"<code>frequenz.repo.config.nox.util.flatten(iterables)</code>","text":"<p>Flatten an iterable of iterables into one iterable with all the elements.</p> PARAMETER  DESCRIPTION <code>iterables</code> <p>The iterables to flatten.</p> <p> TYPE: <code>Iterable[Iterable[_T]]</code> </p> RETURNS DESCRIPTION <code>Iterable[_T]</code> <p>The flattened iterable.</p> Example <p>assert list(flatten([(1, 2), (3, 4)]) == [1, 2, 3, 4]</p> Source code in <code>frequenz/repo/config/nox/util.py</code> <pre><code>def flatten(iterables: Iterable[Iterable[_T]], /) -&gt; Iterable[_T]:\n\"\"\"Flatten an iterable of iterables into one iterable with all the elements.\n    Args:\n        iterables: The iterables to flatten.\n    Returns:\n        The flattened iterable.\n    Example:\n        &gt;&gt;&gt; assert list(flatten([(1, 2), (3, 4)]) == [1, 2, 3, 4]\n    \"\"\"\nreturn (item for sublist in iterables for item in sublist)\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/util/#frequenz.repo.config.nox.util.is_python_file","title":"<code>frequenz.repo.config.nox.util.is_python_file(path)</code>","text":"<p>Check if a path is a Python file.</p> PARAMETER  DESCRIPTION <code>path</code> <p>The path to check.</p> <p> TYPE: <code>Path</code> </p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the path is a Python file, <code>False</code> otherwise.</p> Source code in <code>frequenz/repo/config/nox/util.py</code> <pre><code>def is_python_file(path: _pathlib.Path, /) -&gt; bool:\n\"\"\"Check if a path is a Python file.\n    Args:\n        path: The path to check.\n    Returns:\n        `True` if the path is a Python file, `False` otherwise.\n    \"\"\"\nreturn path.suffix in (\".py\", \".pyi\")\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/util/#frequenz.repo.config.nox.util.min_dependencies","title":"<code>frequenz.repo.config.nox.util.min_dependencies()</code>","text":"<p>Extract the minimum dependencies from pyproject.toml.</p> RETURNS DESCRIPTION <code>list[str]</code> <p>The minimun dependencies defined in pyproject.toml.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If minimun dependencies are not properly set in pyproject.toml.</p> Source code in <code>frequenz/repo/config/nox/util.py</code> <pre><code>def min_dependencies() -&gt; list[str]:\n\"\"\"Extract the minimum dependencies from pyproject.toml.\n    Returns:\n        The minimun dependencies defined in pyproject.toml.\n    Raises:\n        RuntimeError: If minimun dependencies are not properly set in pyproject.toml.\n    \"\"\"\nwith open(\"pyproject.toml\", \"rb\") as toml_file:\ndata = _tomllib.load(toml_file)\nmin_deps: list[str] = []\ndependencies = data.get(\"project\", {}).get(\"dependencies\", {})\nif not dependencies:\nreturn min_deps\nfor dep in dependencies:\nmin_dep = dep.split(\",\")[0]\nif any(op in min_dep for op in (\"&gt;=\", \"==\", \"@\")):\nmin_deps.append(min_dep.replace(\"&gt;=\", \"==\"))\nelse:\nraise RuntimeError(f\"Minimum requirement is not set: {dep}\")\nreturn min_deps\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/util/#frequenz.repo.config.nox.util.path_to_package","title":"<code>frequenz.repo.config.nox.util.path_to_package(path, root=None)</code>","text":"<p>Convert paths to Python package names.</p> <p>Paths should exist and be either a directory or a file ending with <code>.pyi?</code> (otherwise this function will assert). The <code>root</code> and <code>path</code> are concatenated when performing the check.</p> <p>Directory separators in <code>path</code> are replaced with <code>.</code> and the <code>.pyi?</code> suffix is removed (if present).</p> PARAMETER  DESCRIPTION <code>path</code> <p>The path to convert.</p> <p> TYPE: <code>Path</code> </p> <code>root</code> <p>The root where the path is located. If <code>None</code>, then it is considered present in the current working directory.</p> <p> TYPE: <code>Path | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The package name based on <code>path</code>.</p> <p>Examples:</p> <ul> <li><code>src/frequenz/pkg</code> (<code>root=\"src\"</code>) will be converted to <code>frequenz.pkg</code>.</li> <li><code>noxfile.py</code> (without <code>root</code>) will be converted to <code>noxfile</code>.</li> </ul> Source code in <code>frequenz/repo/config/nox/util.py</code> <pre><code>def path_to_package(path: _pathlib.Path, root: _pathlib.Path | None = None) -&gt; str:\n\"\"\"Convert paths to Python package names.\n    Paths should exist and be either a directory or a file ending with `.pyi?`\n    (otherwise this function will assert). The `root` and `path` are\n    concatenated when performing the check.\n    Directory separators in `path` are replaced with `.` and the `.pyi?` suffix\n    is removed (if present).\n    Args:\n        path: The path to convert.\n        root: The root where the path is located. If `None`, then it is\n            considered present in the current working directory.\n    Returns:\n        The package name based on `path`.\n    Examples:\n        * `src/frequenz/pkg` (`root=\"src\"`) will be converted to `frequenz.pkg`.\n        * `noxfile.py` (without `root`) will be converted to `noxfile`.\n    \"\"\"\nreal_path = path\nif root is not None:\nreal_path = root / path\nassert real_path.is_dir() or is_python_file(real_path)\nif is_python_file(real_path):\npath = path.with_suffix(\"\")\nreturn path.as_posix().replace(\"/\", \".\")\n</code></pre>"},{"location":"reference/frequenz/repo/config/nox/util/#frequenz.repo.config.nox.util.replace","title":"<code>frequenz.repo.config.nox.util.replace(iterable, replacements)</code>","text":"<p>Replace elements in an iterable.</p> PARAMETER  DESCRIPTION <code>iterable</code> <p>The iterable to replace elements in.</p> <p> TYPE: <code>Iterable[_T]</code> </p> <code>replacements</code> <p>A mapping of elements to replace with other elements.</p> <p> TYPE: <code>Mapping[_T, _T]</code> </p> YIELDS DESCRIPTION <code>Iterable[_T]</code> <p>The next element in the iterable, with the replacements applied.</p> Example <p>assert list(replace([1, 2, 3], {1: 4, 2: 5})) == [4, 5, 3]</p> Source code in <code>frequenz/repo/config/nox/util.py</code> <pre><code>def replace(iterable: Iterable[_T], replacements: Mapping[_T, _T], /) -&gt; Iterable[_T]:\n\"\"\"Replace elements in an iterable.\n    Args:\n        iterable: The iterable to replace elements in.\n        replacements: A mapping of elements to replace with other elements.\n    Yields:\n        The next element in the iterable, with the replacements applied.\n    Example:\n        &gt;&gt;&gt; assert list(replace([1, 2, 3], {1: 4, 2: 5})) == [4, 5, 3]\n    \"\"\"\nfor item in iterable:\nif item in replacements:\nyield replacements[item]\nelse:\nyield item\n</code></pre>"},{"location":"reference/frequenz/repo/config/pytest/","title":"Index","text":""},{"location":"reference/frequenz/repo/config/pytest/#frequenz.repo.config.pytest","title":"<code>frequenz.repo.config.pytest</code>","text":"<p>Pytest utilities.</p> <p>This package contains utilities for testing with <code>pytest</code>.</p> <p>The following modules are available:</p> <ul> <li><code>examples</code>: Utilities to enable linting of   code examples in docstrings.</li> </ul>"},{"location":"reference/frequenz/repo/config/pytest/examples/","title":"examples","text":""},{"location":"reference/frequenz/repo/config/pytest/examples/#frequenz.repo.config.pytest.examples","title":"<code>frequenz.repo.config.pytest.examples</code>","text":"<p>Utility to enable linting of code examples in docstrings.</p> <p>Code examples are often wrapped in triple backticks (<code>```python</code>) within our docstrings. This plugin extracts these code examples and validates them using pylint.</p> <p>The main utility function is <code>get_sybil_arguments()</code>, which returns a dictionary that can be used to pass to the <code>Sybil()</code> constructor.</p> <p>You still need to create a <code>conftest.py</code> file in the root of your project's sources, typically <code>src/conftest.py</code>, with the following contents:</p> <pre><code>from frequenz.repo.config.pytest import examples\nfrom sybil import Sybil\npytest_collect_file = Sybil(**examples.get_sybil_arguments()).pytest()\n</code></pre>"},{"location":"reference/frequenz/repo/config/pytest/examples/#frequenz.repo.config.pytest.examples-functions","title":"Functions","text":""},{"location":"reference/frequenz/repo/config/pytest/examples/#frequenz.repo.config.pytest.examples.get_sybil_arguments","title":"<code>frequenz.repo.config.pytest.examples.get_sybil_arguments()</code>","text":"<p>Get the arguments to pass when instantiating the Sybil object to lint docs examples.</p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>The arguments to pass when instantiating the Sybil object.</p> Source code in <code>frequenz/repo/config/pytest/examples.py</code> <pre><code>def get_sybil_arguments() -&gt; dict[str, Any]:\n\"\"\"Get the arguments to pass when instantiating the Sybil object to lint docs examples.\n    Returns:\n        The arguments to pass when instantiating the Sybil object.\n    \"\"\"\nreturn {\n\"parsers\": [_CustomPythonCodeBlockParser()],\n\"patterns\": [\"*.py\"],\n# This is a hack because Sybil seems to have issues with `__init__.py` files.\n# See https://github.com/frequenz-floss/frequenz-repo-config-python/issues/113\n# for details\n\"excludes\": [\"__init__.py\"],\n}\n</code></pre>"},{"location":"reference/frequenz/repo/config/setuptools/","title":"Index","text":""},{"location":"reference/frequenz/repo/config/setuptools/#frequenz.repo.config.setuptools","title":"<code>frequenz.repo.config.setuptools</code>","text":"<p>Setuptools utilities.</p>"},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/","title":"grpc_tools","text":""},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools","title":"<code>frequenz.repo.config.setuptools.grpc_tools</code>","text":"<p>Setuptool hooks to build protobuf files.</p> <p>This module contains a setuptools command that can be used to compile protocol buffer files in a project.</p> <p>It also runs the command as the first sub-command for the build command, so protocol buffer files are compiled automatically before the project is built.</p>"},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools-classes","title":"Classes","text":""},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools.CompileProto","title":"<code>frequenz.repo.config.setuptools.grpc_tools.CompileProto</code>","text":"<p>             Bases: <code>Command</code></p> <p>Build the Python protobuf files.</p> Source code in <code>frequenz/repo/config/setuptools/grpc_tools.py</code> <pre><code>class CompileProto(_setuptools.Command):\n\"\"\"Build the Python protobuf files.\"\"\"\nproto_path: str\n\"\"\"The path of the root directory containing the protobuf files.\"\"\"\nproto_glob: str\n\"\"\"The glob pattern to use to find the protobuf files.\"\"\"\ninclude_paths: str\n\"\"\"Comma-separated list of paths to include when compiling the protobuf files.\"\"\"\npy_path: str\n\"\"\"The path of the root directory where the Python files will be generated.\"\"\"\ndescription: str = \"compile protobuf files\"\n\"\"\"Description of the command.\"\"\"\nuser_options: list[tuple[str, str | None, str]] = [\n(\n\"proto-path=\",\nNone,\n\"path of the root directory containing the protobuf files\",\n),\n(\"proto-glob=\", None, \"glob pattern to use to find the protobuf files\"),\n(\n\"include-paths=\",\nNone,\n\"comma-separated list of paths to include when compiling the protobuf files\",\n),\n(\n\"py-path=\",\nNone,\n\"path of the root directory where the Python files will be generated\",\n),\n]\n\"\"\"Options of the command.\"\"\"\ndef initialize_options(self) -&gt; None:\n\"\"\"Initialize options.\"\"\"\nconfig = _protobuf.ProtobufConfig.from_pyproject_toml()\nself.proto_path = config.proto_path\nself.proto_glob = config.proto_glob\nself.include_paths = \",\".join(config.include_paths)\nself.py_path = config.py_path\ndef finalize_options(self) -&gt; None:\n\"\"\"Finalize options.\"\"\"\ndef run(self) -&gt; None:\n\"\"\"Compile the Python protobuf files.\"\"\"\ninclude_paths = self.include_paths.split(\",\")\nproto_files = [\nstr(p) for p in _pathlib.Path(self.proto_path).rglob(self.proto_glob)\n]\nif not proto_files:\nprint(\nf\"No proto files found in {self.proto_path}/**/{self.proto_glob}/, \"\n\"skipping compilation of proto files.\"\n)\nreturn\nprotoc_cmd = (\n[_sys.executable, \"-m\", \"grpc_tools.protoc\"]\n+ [f\"-I{p}\" for p in [*include_paths, self.proto_path]]\n+ [\nf\"--{opt}={self.py_path}\"\nfor opt in \"python_out grpc_python_out mypy_out mypy_grpc_out\".split()\n]\n+ proto_files\n)\nprint(f\"Compiling proto files via: {' '.join(protoc_cmd)}\")\n_subprocess.run(protoc_cmd, check=True)\n</code></pre>"},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools.CompileProto-attributes","title":"Attributes","text":""},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools.CompileProto.description","title":"<code>description: str = 'compile protobuf files'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Description of the command.</p>"},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools.CompileProto.include_paths","title":"<code>include_paths: str</code>  <code>instance-attribute</code>","text":"<p>Comma-separated list of paths to include when compiling the protobuf files.</p>"},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools.CompileProto.proto_glob","title":"<code>proto_glob: str</code>  <code>instance-attribute</code>","text":"<p>The glob pattern to use to find the protobuf files.</p>"},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools.CompileProto.proto_path","title":"<code>proto_path: str</code>  <code>instance-attribute</code>","text":"<p>The path of the root directory containing the protobuf files.</p>"},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools.CompileProto.py_path","title":"<code>py_path: str</code>  <code>instance-attribute</code>","text":"<p>The path of the root directory where the Python files will be generated.</p>"},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools.CompileProto.user_options","title":"<code>user_options: list[tuple[str, str | None, str]] = [('proto-path=', None, 'path of the root directory containing the protobuf files'), ('proto-glob=', None, 'glob pattern to use to find the protobuf files'), ('include-paths=', None, 'comma-separated list of paths to include when compiling the protobuf files'), ('py-path=', None, 'path of the root directory where the Python files will be generated')]</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Options of the command.</p>"},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools.CompileProto-functions","title":"Functions","text":""},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools.CompileProto.finalize_options","title":"<code>finalize_options()</code>","text":"<p>Finalize options.</p> Source code in <code>frequenz/repo/config/setuptools/grpc_tools.py</code> <pre><code>def finalize_options(self) -&gt; None:\n\"\"\"Finalize options.\"\"\"\n</code></pre>"},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools.CompileProto.initialize_options","title":"<code>initialize_options()</code>","text":"<p>Initialize options.</p> Source code in <code>frequenz/repo/config/setuptools/grpc_tools.py</code> <pre><code>def initialize_options(self) -&gt; None:\n\"\"\"Initialize options.\"\"\"\nconfig = _protobuf.ProtobufConfig.from_pyproject_toml()\nself.proto_path = config.proto_path\nself.proto_glob = config.proto_glob\nself.include_paths = \",\".join(config.include_paths)\nself.py_path = config.py_path\n</code></pre>"},{"location":"reference/frequenz/repo/config/setuptools/grpc_tools/#frequenz.repo.config.setuptools.grpc_tools.CompileProto.run","title":"<code>run()</code>","text":"<p>Compile the Python protobuf files.</p> Source code in <code>frequenz/repo/config/setuptools/grpc_tools.py</code> <pre><code>def run(self) -&gt; None:\n\"\"\"Compile the Python protobuf files.\"\"\"\ninclude_paths = self.include_paths.split(\",\")\nproto_files = [\nstr(p) for p in _pathlib.Path(self.proto_path).rglob(self.proto_glob)\n]\nif not proto_files:\nprint(\nf\"No proto files found in {self.proto_path}/**/{self.proto_glob}/, \"\n\"skipping compilation of proto files.\"\n)\nreturn\nprotoc_cmd = (\n[_sys.executable, \"-m\", \"grpc_tools.protoc\"]\n+ [f\"-I{p}\" for p in [*include_paths, self.proto_path]]\n+ [\nf\"--{opt}={self.py_path}\"\nfor opt in \"python_out grpc_python_out mypy_out mypy_grpc_out\".split()\n]\n+ proto_files\n)\nprint(f\"Compiling proto files via: {' '.join(protoc_cmd)}\")\n_subprocess.run(protoc_cmd, check=True)\n</code></pre>"}]}